<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EVE Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/dexie/dist/dexie.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;500;600;700&family=Comic+Neue:wght@400;700&family=Fredoka+One&family=Nunito:wght@400;500;600;700&family=Montserrat:wght@400;500;600&family=Inter:wght@400;500;600&family=Roboto:wght@400;500&family=Raleway:wght@400;500;600&family=Lato:wght@400;700&family=Poppins:wght@400;500;600&family=Quicksand:wght@400;500;600&family=Varela+Round&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
        <!-- 推送通知容器 -->
        <div id="notification-container"></div>
    <div id="phone-frame">
    <div id="phone-screen">
        <div class="wallpaper" id="wallpaper-element">
            <!-- 主屏幕状态栏 -->
            <div id="status-bar">
                <span id="status-bar-time">14:25</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">ᰔᩚ</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>
            
            <!-- 时钟容器 -->
            <div id="clock-container">
                <div id="main-time">14:25</div>
                <div id="main-date">12月18日 星期一</div>
            </div>
            
            <div id="worldbook-screen" class="app-screen">
                <div class="app-status-bar">
                    <div class="app-status-time"></div>
                    <div class="app-battery-container">
                        <span class="battery-text">ᰔᩚ</span>
                        <div class="app-battery-icon">
                            <div class="app-battery-level"></div>
                        </div>
                    </div>
                </div>
                <div class="app-header">
                    <button class="back-button" onclick="hideApp('worldbook-screen')">‹</button>
                    <div class="app-title">世界书</div>
                    <div class="add-worldbook-btn worldbook-add-btn" onclick="onWorldbookAddClick()">
                        <i class="fas fa-plus"></i>
                    </div>
                </div>

                <div class="app-content">
                    <div id="global-worldbooks-content" class="worldbook-content-pane">
                        </div>
                    <div id="local-worldbooks-content" class="worldbook-content-pane" style="display: none;">
                        </div>
                    <div id="character-worldbooks-content" class="worldbook-content-pane" style="display: none;">
                        </div>
                </div>

                <!-- 世界书分类选择器 -->
                <div class="worldbook-category-selector" id="worldbook-category-selector" style="display: none;">
                    <div class="category-selector-content">
                        <div class="category-selector-title">选择角色分类</div>
                        <div class="category-options" id="category-options">
                            <!-- 动态生成角色分类 -->
                        </div>
                        <div class="category-selector-actions">
                            <button class="category-cancel-btn" onclick="hideCategorySelector()">取消</button>
                        </div>
                    </div>
                </div>

                <div class="worldbook-tabs">
                    <div class="worldbook-tab active" onclick="switchWorldbookTab('global')">
                        <i class="fas fa-globe-asia"></i>
                        <span>全局设定</span>
                    </div>
                    <div class="worldbook-tab" onclick="switchWorldbookTab('local')">
                        <i class="fas fa-comment-dots"></i>
                        <span>局部设定</span>
                    </div>
                    <div class="worldbook-tab" onclick="switchWorldbookTab('character')">
                        <i class="fas fa-users"></i>
                        <span id="character-tab-text">角色设定</span>
                    </div>
                </div>
            </div>
                
                <!-- 应用图标 -->
                <div id="app-grid">
                    <div class="app-row">
                        <a href="#" class="app" onclick="showApp('chat-screen')">
                            <div class="app-icon">
                                <img src="https://i.postimg.cc/dVSd9QBz/IMG-3063.jpg" alt="Chat" class="app-icon-img">
                            </div>
                            <span>Chat</span>
                        </a>
                        <a href="#" class="app" onclick="showApp('worldbook-screen'); switchWorldbookTab('global');">
                            <div class="app-icon">
                                <img src="https://i.postimg.cc/Xqz3zPz7/IMG-3080.jpg" alt="世界书" class="app-icon-img">
                            </div>
                            <span>世界书</span>
                        </a>
                        <a href="#" class="app" onclick="showApp('settings-screen')">
                            <div class="app-icon">
                                <img src="https://i.postimg.cc/764L3jpF/IMG-3079.jpg" alt="设置" class="app-icon-img">
                            </div>
                            <span>设置</span>
                        </a>
                    </div>
                    <div class="app-row">
                                        <a href="#" class="app" onclick="showApp('game-screen')">
                            <div class="app-icon">
                        <i class="fas fa-gamepad"></i>
                            </div>
                    <span>游戏</span>
                        </a>
                        <a href="#" class="app" onclick="showApp('music-screen')">
                            <div class="app-icon">
                                <i class="fas fa-music"></i>
                            </div>
                            <span>音乐</span>
                        </a>
                                        <a href="#" class="app" onclick="showApp('forum-screen')">
                            <div class="app-icon">
                        <i class="fas fa-comments"></i>
                            </div>
                    <span>论坛</span>
                        </a>
                    </div>
                </div>

                
                <!-- 聊天界面 -->
                <div id="chat-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('chat-screen')">‹</button>
                        <div class="app-title">💬</div>
                        <div class="chat-header-actions">
                            <div id="group-manage-btn" class="header-action-btn" onclick="enterGroupManageMode()" title="管理分组">
                                <i class="fas fa-cog"></i>
                            </div>
                            <div id="add-contact-btn" class="add-btn" onclick="showCharacterForm()">
                                <i class="fas fa-plus"></i>
                            </div>
                            <div id="add-chat-btn" class="add-btn" onclick="showChatOptions()">
                                <i class="fas fa-plus"></i>
                            </div>
                        </div>
                    </div>
                    
                    <div class="app-content" id="chat-content">
                        <!-- 默认显示消息列表 -->
                        <div class="message-list" id="message-list">
                            <!-- 消息列表将通过JS动态生成 -->
                        </div>
                        
                        <!-- 通讯录 -->
                        <div class="contact-list hide" id="contact-list">
                            <div class="contact-section">
        
                                <!-- 联系人列表将通过JS动态生成 -->
                            </div>

                        </div>
                        
                        <!-- 动态页面 -->
                        <div class="moments-page hide moments-page-no-padding" id="moments-page">
                            <div class="moments-header">
                                <div class="moments-cover" onclick="changeCoverImage()">
                                    <div class="cover-image-placeholder" id="cover-placeholder">
                                        <div class="cover-placeholder-text">点击更换封面</div>
                                        </div>
                                    <img class="cover-image hide" id="cover-image" src="">
                                    </div>
                                
                                <!-- 用户名，独立放置在头像左上角 -->
                                <div class="moments-username" onclick="changeUsername(event)" id="moments-username">用户</div>
                                
                                <!-- 独立的头像，跨越背景和动态列表区域，放在header外面 -->
                                <div class="moments-avatar" onclick="changeAvatarImage(event)" id="moments-avatar">
                                    <i class="fas fa-user moments-avatar-icon"></i>
                                </div>
                            </div>
                            
                            <div class="moments-list" id="moments-list">
                                <!-- 动态列表将通过JS动态生成 -->
                            </div>
                            

                        </div>

                        
                        <!-- 面具区域 -->
                        <div class="profile-page hide" id="profile-page">
                            <div class="persona-header">
                                <div class="persona-title">
                                    <h2>我的面具</h2>
                                    <p>管理你的多重身份设定</p>
                                </div>
                                <div class="add-persona-btn persona-add-btn" onclick="showPersonaForm()">
                                    <i class="fas fa-plus"></i>
                                </div>
                            </div>
                            
                            <div class="persona-list" id="persona-list">
                                <!-- 面具列表将通过JS动态生成 -->
                            </div>
                            

                        </div>
                    </div>
                    
                    <div class="chat-tabs">
                        <div class="chat-tab active" onclick="switchChatTab('message-list')" id="message-tab">
                            <i class="fas fa-comments"></i>
                            <span>消息</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('contact-list')">
                            <i class="fas fa-user-friends"></i>
                            <span>角色</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('moments-page')">
                            <i class="fas fa-globe-americas"></i>
                            <span>动态</span>
                        </div>
                        <div class="chat-tab" onclick="switchChatTab('profile-page')">
                            <i class="fas fa-user-circle"></i>
                            <span>我</span>
                        </div>
                    </div>
                </div>
                
                <!-- 发布动态界面 -->
                <div id="publish-moment-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hidePublishMoment()">‹</button>
                        <div class="app-title">发表动态</div>
                        <button class="publish-btn" onclick="publishMoment()">发表</button>
                    </div>
                    <div class="app-content">
                        <div class="publish-moment-form">
                            <!-- 文字输入区域 -->
                            <div class="moment-text-input">
                                <textarea 
                                    id="moment-text" 
                                    placeholder="分享新鲜事..." 
                                    class="moment-textarea"
                                    maxlength="500"
                                    oninput="updateTextCount()"></textarea>
                                <div class="text-count" id="text-count">0/500</div>
                            </div>
                            
                            <!-- 图片上传区域 -->
                            <div class="moment-images-section">
                                <div class="moment-images-grid" id="moment-images-grid">
                                    <!-- 动态添加的图片预览 -->
                                </div>
                                <div class="add-image-btn" onclick="addMomentImage()">
                                    <i class="fas fa-plus"></i>
                                    <span>添加图片</span>
                                </div>
                            </div>
                            
                            <!-- 发布选项 -->
                            <div class="publish-options">
                                <div class="option-item">
                                    <i class="fas fa-map-marker-alt"></i>
                                    <span>所在位置</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <div class="option-item">
                                    <i class="fas fa-users"></i>
                                    <span>提醒谁看</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                                <div class="option-item">
                                    <i class="fas fa-eye"></i>
                                    <span>谁可以看</span>
                                    <span class="option-value">公开</span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 论坛界面 -->
                <div id="forum-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('forum-screen')">‹</button>
                        <div class="app-title">论坛</div>
                    </div>
                    <div class="app-content">
                        <div class="forum-categories">
                            <div class="forum-category">
                                <div class="category-icon">
                                    <i class="fas fa-fire"></i>
                                </div>
                                <div class="category-info">
                                    <div class="category-name">热门话题</div>
                                    <div class="category-desc">最受欢迎的讨论</div>
                            </div>
                                <div class="category-count">128</div>
                            </div>
                            <div class="forum-category">
                                <div class="category-icon">
                                    <i class="fas fa-gamepad"></i>
                            </div>
                                <div class="category-info">
                                    <div class="category-name">游戏讨论</div>
                                    <div class="category-desc">分享游戏心得</div>
                                </div>
                                <div class="category-count">89</div>
                                </div>
                            <div class="forum-category">
                                <div class="category-icon">
                                    <i class="fas fa-heart"></i>
                                </div>
                                <div class="category-info">
                                    <div class="category-name">角色互动</div>
                                    <div class="category-desc">与AI角色的故事</div>
                                </div>
                                <div class="category-count">256</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 世界书编辑表单 -->
                <div id="worldbook-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideWorldbookForm()">‹</button>
                        <div class="app-title" id="worldbook-form-title">新建世界书</div>
                        <button class="save-worldbook-btn save-btn-absolute" onclick="saveWorldbook()">保存</button>
                    </div>
                    <div class="app-content">
                        <div class="worldbook-form">
                            <div class="form-group">
                                <label class="form-label">标题</label>
                                <input type="text" id="worldbook-title" class="form-input" placeholder="请输入世界书标题">
                            </div>
                            <div class="form-group">
                                <label class="form-label">内容</label>
                                <textarea id="worldbook-content" class="form-textarea textarea-large" placeholder="请输入世界书内容，这里可以描述角色背景、世界观设定等..."></textarea>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 音乐应用界面 -->
                <div id="music-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('music-screen')">‹</button>
                        <div class="app-title">音乐</div>
                    </div>
                    <div class="app-content">
                        <div class="music-player">
                            <div class="now-playing">
                                <div class="album-cover" id="album-cover">
                                    <i class="fas fa-music"></i>
                                </div>
                                <div class="song-info">
                                    <div class="song-title" id="song-title">选择一首歌曲</div>
                                    <div class="artist-name" id="artist-name">未知艺术家</div>
                                </div>
                            </div>
                            
                            <div class="progress-container">
                                <div class="progress-bar">
                                    <div class="progress" id="progress"></div>
                                </div>
                                <div class="time-info">
                                    <span id="current-time">0:00</span>
                                    <span id="total-time">0:00</span>
                                </div>
                            </div>
                            
                            <div class="music-controls">
                                <button class="control-btn" onclick="previousSong()">
                                    <i class="fas fa-step-backward"></i>
                                </button>
                                <button class="control-btn play-pause" id="play-pause-btn" onclick="togglePlayPause()">
                                    <i class="fas fa-play"></i>
                                </button>
                                <button class="control-btn" onclick="nextSong()">
                                    <i class="fas fa-step-forward"></i>
                                </button>
                            </div>
                            
                            <div class="playlist-section">
                                <div class="section-header">
                                    <h3>播放列表</h3>
                                    <button class="add-music-btn" onclick="addMusicToPlaylist()">
                                        <i class="fas fa-plus"></i>
                                    </button>
                                </div>
                                <div class="playlist" id="playlist">
                                    <!-- 播放列表将通过JS动态生成 -->
                                </div>
                            </div>
                            
                            <div class="character-listening">
                                <div class="listening-header">
                                    <h3>一起听歌的角色</h3>
                                    <button class="invite-character-btn" onclick="inviteCharacterToListen()">
                                        <i class="fas fa-user-plus"></i>
                                    </button>
                                </div>
                                <div class="listening-characters" id="listening-characters">
                                    <!-- 听歌角色将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 聊天设置界面 -->
                <div id="api-chat-settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideChatSettings()">‹</button>
                        <div class="app-title">聊天设置</div>
                    </div>
                    <div class="app-content padding-none-flex overflow-auto">
                        <div class="settings-container">
                            
                            <!-- 群聊专用设置 - 仿QQ/微信群聊界面 -->
                            <div class="settings-section" id="group-chat-settings" style="display: none;">
                                <!-- 群聊信息卡片 -->
                                <div class="group-info-card">
                                    <div class="group-avatar-section" onclick="changeGroupAvatar()">
                                        <img id="group-avatar-preview" src="" class="group-avatar-large" alt="群头像">
                                        <div class="group-avatar-edit-hint">点击修改</div>
                                    </div>
                                    <div class="group-basic-info">
                                        <div class="group-name" onclick="changeGroupName()" id="group-name-display">群聊名称</div>
                                        <div class="group-member-count" id="group-member-count-display">0名成员</div>
                                        <div class="group-description" onclick="editGroupDescription()" id="group-description-display">群公告：点击设置群公告</div>
                                    </div>
                                </div>

                                <!-- 群成员展示区域 -->
                                <div class="group-members-section">
                                    <div class="section-title">群成员</div>
                                    <div class="group-members-grid" id="group-members-grid">
                                        <!-- 群成员头像将动态生成 -->
                                        <div class="member-item add-member" onclick="addGroupMember()">
                                            <div class="member-avatar">
                                                <i class="fas fa-plus"></i>
                                            </div>
                                            <div class="member-name">邀请</div>
                                        </div>
                                        <div class="member-item remove-member" onclick="removeGroupMember()">
                                            <div class="member-avatar">
                                                <i class="fas fa-minus"></i>
                                            </div>
                                            <div class="member-name">移除</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- 群功能设置 -->
                                <div class="setting-card">
                                    <div class="setting-item" onclick="changeMyGroupNickname()">
                                        <div class="setting-left">
                                            <div class="setting-label">我在本群的昵称</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-my-group-nickname">未选择</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showGroupNotice()">
                                        <div class="setting-left">
                                            <div class="setting-label">群公告</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value">查看详情</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                </div>

                                <!-- 群应用中心 -->
                                <div class="group-apps-section">
                                    <div class="section-title">群应用</div>
                                    <div class="group-apps-grid">
                                        <div class="app-item" onclick="showGroupVote()">
                                            <i class="fas fa-vote-yea app-icon"></i>
                                            <span class="app-name">投票</span>
                                        </div>
                                        <div class="app-item" onclick="showGroupActivity()">
                                            <i class="fas fa-calendar-alt app-icon"></i>
                                            <span class="app-name">群活动</span>
                                        </div>
                                        <div class="app-item" onclick="showGroupTask()">
                                            <i class="fas fa-tasks app-icon"></i>
                                            <span class="app-name">群任务</span>
                                        </div>
                                        <div class="app-item" onclick="showMoreApps()">
                                            <i class="fas fa-ellipsis-h app-icon"></i>
                                            <span class="app-name">更多</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- 聊天窗口设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-user-edit section-icon"></i>
                                    <span class="section-title">聊天窗口设置</span>
                                </div>
                                <div class="setting-card">
                                    <!-- 身份选择功能已移除，身份在创建对话时选择 -->
                                    <!-- 单聊时显示双方设置，群聊时隐藏 -->
                                    <div class="setting-item single-chat-only" onclick="showAvatarSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">双方头像设置</div>
                                            <div class="setting-desc">设置在此聊天窗口中显示的头像</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only" onclick="showNicknameSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">双方备注设置</div>
                                            <div class="setting-desc">设置在此聊天窗口中显示的昵称</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showBackgroundSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">聊天背景设置</div>
                                            <div class="setting-desc">自定义聊天界面的背景图片</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showBubbleStyleSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">气泡样式设置</div>
                                            <div class="setting-desc">选择气泡外观样式和颜色</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-bubble-style">默认样式</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item single-chat-only">
                                        <div class="setting-left">
                                            <div class="setting-label">显示角色状态</div>
                                            <div class="setting-desc">在聊天界面显示角色的在线状态和活动</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="character-status-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    
                                    <!-- 🔥【新增】状态更新频率设置 -->
                                    <div class="setting-item single-chat-only" id="status-frequency-setting" style="display: none;">
                                        <div class="setting-left">
                                            <div class="setting-label">状态更新频率</div>
                                            <div class="setting-desc">控制角色状态的检查和更新频率</div>
                                        </div>
                                        <div class="setting-right">
                                            <select class="setting-select" id="status-update-frequency">
                                                <option value="high">高频 (目前频率)</option>
                                                <option value="medium-high">中高频 (1分钟)</option>
                                                <option value="medium">中频 (3分钟)</option>
                                                <option value="medium-low">中低频 (5分钟)</option>
                                                <option value="low">低频 (10分钟)</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 戳一戳功能设置 - 单聊特有 -->
                            <div class="settings-section" id="poke-settings-section">
                                <div class="section-header">
                                    <i class="fas fa-hand-paper section-icon"></i>
                                    <span class="section-title">戳一戳功能</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">启用戳一戳</div>
                                            <div class="setting-desc">允许发送戳一戳消息，双方可自定义戳一戳后缀</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="poke-enabled" checked>
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-item poke-settings poke-settings-visible" id="poke-suffix-settings" onclick="showPokeSuffixSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">戳一戳后缀设置</div>
                                            <div class="setting-desc">自定义双方的戳一戳动作后缀</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-explanation">
                                        <div class="explanation-text">
                                            <strong>功能说明：</strong><br>
                                            • 点击对方头像即可发送戳一戳<br>
                                            • 你可以自定义戳一戳后缀，如"的小脸蛋"、"的小手"等<br>
                                            • 角色也会根据心情和聊天内容自主修改自己的戳一戳后缀
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 记忆设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-brain section-icon"></i>
                                    <span class="section-title">记忆设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item" onclick="showHistorySettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">附带历史消息数</div>
                                            <div class="setting-desc">自定义角色回复时参考的历史对话数量</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-history-count">5回合</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showMemoryMountSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">挂载其他聊天记忆</div>
                                            <div class="setting-desc">让角色参考其他聊天窗口的对话记忆</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-memory-mount">已关闭</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showWorldbookMountSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">挂载世界书</div>
                                            <div class="setting-desc">让角色参考选定的世界书内容作为背景知识</div>
                                        </div>
                                        <div class="setting-right">
                                            <span class="setting-value" id="current-worldbook-mount">未挂载</span>
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 时间感知设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-clock section-icon"></i>
                                    <span class="section-title">时间感知</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">时间感知开关</div>
                                            <div class="setting-desc">角色会感知当前时间并调整回复</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="time-awareness-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 通话设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-phone section-icon"></i>
                                    <span class="section-title">通话设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">角色主动拨打电话</div>
                                            <div class="setting-desc">允许角色根据对话内容主动发起通话</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="ai-call-enabled" class="ai-call-enabled-checkbox">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-explanation">
                                        <div class="explanation-text">
                                            <strong>功能说明：</strong><br>
                                            • <strong>开启时：</strong>当本轮聊天中提到通话相关内容时，角色有20%概率主动给你打电话<br>
                                            • <strong>关闭时：</strong>角色不会主动拨打电话，只能由用户主动发起通话<br>
                                            • <strong>通话关键词：</strong>通话、电话、视频、语音、打给你、想听、想看等
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- AI心率监测 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-heartbeat section-icon"></i>
                                    <span class="section-title">角色心率监测</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">心率监测显示</div>
                                            <div class="setting-desc">在状态栏显示角色的情感心率</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="ai-heartrate-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 聊天模式设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-comments section-icon"></i>
                                    <span class="section-title">聊天模式</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">模式选择</div>
                                            <div class="setting-desc">选择线上纯聊天或线下剧情模式</div>
                                        </div>
                                    </div>
                                    <div class="chat-mode-switch">
                                        <div class="chat-mode-option">
                                            <input type="radio" id="chat-mode-online" name="chat-mode" value="online" checked>
                                            <label for="chat-mode-online">线上模式</label>
                                        </div>
                                        <div class="chat-mode-option">
                                            <input type="radio" id="chat-mode-offline" name="chat-mode" value="offline">
                                            <label for="chat-mode-offline">线下模式</label>
                                        </div>
                                    </div>
                                    <div class="offline-length-control hide" id="offline-length-control">
                                        <span class="control-label">每条消息最长：</span>
                                        <input type="number" id="offline-mode-max-length" min="50" max="500" value="100">
                                        <span class="control-unit">字</span>
                                    </div>
                                </div>
                            </div>



                            <!-- 后台互动设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-robot section-icon"></i>
                                    <span class="section-title">后台互动</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">后台互动开关</div>
                                            <div class="setting-desc">角色可在后台主动活动并发送推送</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="background-interaction-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="background-interaction-details hide" id="background-interaction-settings">
                                        <div class="setting-item">
                                        <div class="setting-left">
                                                <div class="setting-label">主动聊天</div>
                                                <div class="setting-desc">角色在你10分钟未回复时主动发消息</div>
                                        </div>
                                        <div class="setting-right">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="background-chat-enabled">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                        </div>
                                    </div>
                                        
                                        <div class="setting-item" id="chat-frequency-setting" style="display: none;">
                                        <div class="setting-left">
                                                <div class="setting-label">主动聊天频率</div>
                                                <div class="setting-desc">角色主动发起对话的频率</div>
                                        </div>
                                        <div class="setting-right">
                                                <select id="background-chat-frequency" class="setting-select">
                                                    <option value="low">低 (1-2小时/次)</option>
                                                    <option value="medium">中 (30-60分钟/次)</option>
                                                    <option value="high">高 (10-30分钟/次)</option>
                                                </select>
                                </div>
                            </div>

                                    <div class="setting-item">
                                        <div class="setting-left">
                                                <div class="setting-label">主动发动态</div>
                                                <div class="setting-desc">角色根据人设主动发布动态</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                    <input type="checkbox" id="background-moments-enabled">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>

                                        <div class="setting-item" id="moments-frequency-setting" style="display: none; justify-content: space-between !important; align-items: center !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">主动发动态频率</div>
                                                <div class="setting-desc">角色主动发布社交动态的频率</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; align-items: center !important; flex-shrink: 0 !important;">
                                                <select id="background-moments-frequency" class="setting-select">
                                                    <option value="low">低 (4-8小时/次)</option>
                                                    <option value="medium">中 (2-4小时/次)</option>
                                                    <option value="high">高 (1-2小时/次)</option>
                                                </select>
                                            </div>
                                        </div>
                                        
                                        <div class="setting-item" id="scheduled-moments-setting" style="display: none; justify-content: space-between !important; align-items: flex-start !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">定时发布动态</div>
                                                <div class="setting-desc">设置固定时间点自动发布动态</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; flex-direction: column !important; align-items: flex-end !important; gap: 8px !important; flex-shrink: 0 !important;">
                                                <label class="toggle-switch">
                                                    <input type="checkbox" id="scheduled-moments-enabled">
                                                    <span class="toggle-slider"></span>
                                                </label>
                                                <button onclick="showScheduleTimesModal()" style="background-color: #4a84c1; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    <span id="schedule-times-display">未设置</span>
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <div class="setting-item" id="test-publish-setting" style="display: none; justify-content: space-between !important; align-items: center !important;">
                                            <div class="setting-left" style="flex: 1 !important;">
                                                <div class="setting-label">测试发布</div>
                                                <div class="setting-desc">让角色立即发布一条测试动态</div>
                                            </div>
                                            <div class="setting-right" style="display: flex !important; align-items: center !important; flex-shrink: 0 !important; gap: 8px;">
                                                <button onclick="testPublishMoment()" style="background-color: #4a84c1; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    发布
                                                </button>
                                                <button onclick="fixAvatarData()" style="background-color: #ff6b6b; color: white; border: none; padding: 6px 12px; border-radius: 15px; font-size: 12px;">
                                                    修复头像
                                                </button>
                                            </div>
                                        </div>
                                        
                                                                            <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">主动拨打电话</div>
                                            <div class="setting-desc">角色在适当时机主动拨打电话</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="background-ai-call-enabled" class="ai-call-enabled-checkbox">
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 其他设置 -->
                            <div class="settings-section">
                                <div class="section-header">
                                    <i class="fas fa-cog section-icon"></i>
                                    <span class="section-title">其他设置</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item">
                                        <div class="setting-left">
                                            <div class="setting-label">显示时间戳</div>
                                            <div class="setting-desc">在聊天消息中显示时间信息</div>
                                        </div>
                                        <div class="setting-right">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="timestamp-enabled" checked>
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="showTimestampSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">时间戳设置</div>
                                            <div class="setting-desc">设置时间戳显示位置和格式</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="searchChatContent()">
                                        <div class="setting-left">
                                            <div class="setting-label">查找聊天内容</div>
                                            <div class="setting-desc">搜索历史消息中的关键词</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item" onclick="exportChatHistory()">
                                        <div class="setting-left">
                                            <div class="setting-label">导出聊天记录</div>
                                            <div class="setting-desc">导出当前对话的所有消息</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>

                                </div>
                            </div>

                            <!-- 危险操作 -->
                            <div class="settings-section">
                                <div class="section-header">
                                                    <i class="fas fa-exclamation-triangle section-icon danger-section-icon"></i>
                <span class="section-title danger-section-title">危险操作</span>
                                </div>
                                <div class="setting-card">
                                    <div class="setting-item" onclick="showBlacklistSettings()">
                                        <div class="setting-left">
                                            <div class="setting-label">拉黑管理</div>
                                            <div class="setting-desc">拉黑/解除拉黑，设置冷静时间</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right"></i>
                                        </div>
                                    </div>
                                    <div class="setting-item danger-item" onclick="clearChatHistory()">
                                        <div class="setting-left">
                                            <div class="setting-label danger-color">清空聊天记录</div>
                                            <div class="setting-desc">删除所有历史消息，不可恢复</div>
                                        </div>
                                        <div class="setting-right">
                                            <i class="fas fa-chevron-right danger-color"></i>
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
                
                <!-- 人物编辑表单 -->
                <div id="character-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideCharacterForm()">‹</button>
                        <div class="app-title" id="character-form-title">新建人物</div>
                        <button class="import-character-btn" id="import-character-btn" onclick="importCharacterCard()" title="导入角色卡">
                            <i class="fas fa-upload"></i>
                        </button>
                        <button class="export-character-btn" id="export-character-btn" onclick="exportCharacterCard()" title="导出角色卡" style="display: none;">
                            <i class="fas fa-download"></i>
                        </button>
                    </div>
                    <div class="app-content">
                        <div class="character-form">
                            <div class="form-group avatar-upload">
                                <label class="form-label">头像</label>
                                <div class="avatar-preview" id="avatar-preview">
                                    <div class="avatar-preview-text" id="avatar-preview-text">A</div>
                                </div>
                                <input type="file" id="avatar-upload" accept="image/*" class="file-input-hidden">
                            <input type="file" id="character-card-upload" accept=".png,.json" class="file-input-hidden">
                                <button class="upload-button" onclick="handleAvatarUploadClick()">上传头像</button>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">姓名</label>
                                <input type="text" class="form-input" id="character-name" placeholder="输入姓名">
                            </div>
                            <div class="form-group">
                                <label class="form-label">人设</label>
                                <textarea class="form-textarea" id="character-bio" placeholder="输入人物设定"></textarea>
                            </div>
                            <div class="form-actions form-actions-flex">
                                <button class="form-submit form-submit-flex">保存</button>
                                <button class="form-delete form-delete-red" id="character-delete-btn" onclick="deleteCurrentCharacter()">删除</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 面具创建表单 -->
                <div id="persona-form-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hidePersonaForm()">‹</button>
                        <div class="app-title" id="persona-form-title">新建面具</div>
                    </div>
                    <div class="app-content">
                        <div class="character-form">
                            <div class="form-group avatar-upload">
                                <label class="form-label">头像</label>
                                <div class="avatar-preview" id="persona-avatar-preview">
                                    <div class="avatar-preview-text" id="persona-avatar-preview-text">我</div>
                                </div>
                                <input type="file" id="persona-avatar-upload" accept="image/*" class="file-input-hidden">
                                <button class="upload-button" onclick="handlePersonaAvatarUploadClick()">上传头像</button>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">我的名称</label>
                                <input type="text" class="form-input" id="persona-name" placeholder="例如：user小明、user学生、user工作者">
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">我的描述</label>
                                <textarea class="form-textarea" id="persona-description" placeholder="描述这个身份的特点，包括性格、说话风格、使用场合等..."></textarea>
                            </div>
                            
                            <button class="form-submit" onclick="savePersona()">保存面具</button>
                        </div>
                    </div>
                </div>
                
                <!-- API聊天界面 -->
                <div id="api-chat-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div id="ai-heartrate-display" style="display: none;">♥️ 72 bpm</div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="header">
                        <div class="default-controls">
                            <button class="back-btn" onclick="backToChatApp()">‹</button>
                            <span class="header-title" id="api-chat-title">角色聊天</span>
                            <div class="header-actions">
                                <span class="action-btn" onclick="showChatSettings()">
                                <i class="fas fa-ellipsis-v"></i>
                                </span>
                            </div>
                        </div>
                        <div class="selection-controls">
                            <span id="selection-cancel-btn">取消</span>
                            <span id="selection-count"></span>
                            <span id="selection-delete-btn">删除</span>
                        </div>
                    </div>
                    <div class="app-content padding-none-flex">

                        <div class="chat-dialog">
                            <div class="chat-messages" id="api-chat-messages">
                                <!-- 聊天消息将通过JS动态生成 -->
                            </div>
                            
                            <!-- 悬浮按钮组 -->
                            <div class="floating-actions" id="floating-actions">
                                <button class="floating-btn" id="regenerate-btn" onclick="regenerateLastResponse()" title="重新生成回答">
                                    <i class="fas fa-redo-alt"></i>
                                </button>
                            </div>
                            
                            <div class="chat-input-area">
                                <!-- 展开的工具面板 -->
                                <div class="tools-panel" id="tools-panel" style="display: none;">
                                    <div class="tools-grid">
                                        <div class="tool-item" onclick="handleVoiceRecording(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-microphone"></i>
                                            </div>
                                            <span class="tool-label">语音</span>
                                        </div>
                                        <div class="tool-item" onclick="showCustomEmojiPanel(); hideToolsPanel();">
                                            <div class="tool-icon">
                                                <i class="fas fa-smile"></i>
                                            </div>
                                            <span class="tool-label">表情</span>
                                        </div>
                                        <div class="tool-item" onclick="openCamera(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-camera"></i>
                                            </div>
                                            <span class="tool-label">拍照</span>
                                        </div>
                                        <div class="tool-item" onclick="uploadImage(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-image"></i>
                                            </div>
                                            <span class="tool-label">图片</span>
                                        </div>
                                        <div class="tool-item" onclick="openTransfer(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-exchange-alt"></i>
                                            </div>
                                            <span class="tool-label">转账</span>
                                        </div>
                                        <div class="tool-item" onclick="makeCall(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-phone"></i>
                                            </div>
                                            <span class="tool-label">电话</span>
                                        </div>
                                        <div class="tool-item" onclick="openVideoCall(); hideToolsPanel();">
                                            <div class="tool-icon">
                                        <i class="fas fa-video"></i>
                                            </div>
                                            <span class="tool-label">视频</span>
                                        </div>
                                                                <div class="tool-item" onclick="shareLocation(); hideToolsPanel();">
                            <div class="tool-icon">
                        <i class="fas fa-map-marker-alt"></i>
                            </div>
                            <span class="tool-label">位置</span>
                        </div>
                        <div class="tool-item" onclick="showDiaryOptions(); hideToolsPanel();">
                            <div class="tool-icon">
                        <i class="fas fa-book"></i>
                            </div>
                            <span class="tool-label">日记</span>
                        </div>
                    </div>
                </div>
                                
                                <!-- 输入区域 -->
                                <div class="input-controls">
                                <button class="chat-action-btn toggle-tools-btn" onclick="toggleToolsPanel()" title="功能菜单" id="toggle-tools-btn">
                                    <i class="fas fa-plus"></i>
                                </button>
                                <textarea class="chat-input" id="api-chat-input" rows="1" placeholder="输入消息..."></textarea>
                                    <button class="chat-action-btn" onclick="triggerSmartReply()" title="获取AI回复">
                                        <i class="fas fa-comment-dots"></i>
                                </button>
                                <button class="send-button" onclick="sendApiMessage()">
                                    发送
                                </button>
                                </div>
                                <!-- @成员选择列表 - 移到input-controls外面 -->
                                <div id="mention-dropdown" class="mention-dropdown" style="display: none;">
                                    <!-- 动态生成群成员列表 -->
                                </div>
                                <input type="file" id="image-upload" accept="image/*" class="file-input-hidden">
                                <input type="file" id="emoji-upload" accept="image/*" class="file-input-hidden" multiple>
                            </div>
                        </div>
                        
                        <!-- 自定义表情包面板 -->
                        <div class="custom-emoji-panel" id="custom-emoji-panel">
                            <div class="emoji-tabs">
                                <div class="emoji-tab active" data-tab="recent">最近</div>
                                <div class="emoji-tab" data-tab="custom">全部</div>
                            </div>
                            <div class="emoji-content">
                                <div class="emoji-grid" id="emoji-grid">
                                    <!-- 表情包网格将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 浏览器界面 -->
                <div id="browser-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('browser-screen')">‹</button>
                        <div class="app-title">浏览器</div>
                    </div>
                    <div class="app-content padding-none-flex">
                        <div class="browser-toolbar">
                            <input type="text" class="browser-url-bar" id="browser-url" placeholder="输入网址">
                            <button onclick="loadUrl()">前往</button>
                        </div>
                        <iframe class="browser-content" id="browser-frame"></iframe>
                    </div>
                </div>
                

                
                <!-- 游戏界面 -->
                <div id="game-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('game-screen')">‹</button>
                        <div class="app-title">游戏中心</div>
                    </div>
                    <div class="app-content">
                        <div class="game-list">
                            <div class="game-item" onclick="startGame('witchPotion')">
                                <div class="game-icon">
                                    <i class="fas fa-flask"></i>
                        </div>
                                <div class="game-info">
                                    <div class="game-name">女巫的解药</div>
                                    <div class="game-desc">与AI角色一起调制神秘药水</div>
                                </div>
                                <div class="game-badge">NEW</div>
                            </div>
                            <div class="game-item coming-soon">
                                <div class="game-icon">
                                    <i class="fas fa-dice"></i>
                                </div>
                                <div class="game-info">
                                    <div class="game-name">角色猜谜</div>
                                    <div class="game-desc">即将推出</div>
                                </div>
                            </div>
                            <div class="game-item coming-soon">
                                <div class="game-icon">
                                    <i class="fas fa-book"></i>
                                </div>
                                <div class="game-info">
                                    <div class="game-name">互动故事</div>
                                    <div class="game-desc">即将推出</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                

                

                
                <!-- 设置应用 -->
                <div id="settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('settings-screen')">‹</button>
                        <div class="app-title">设置</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item" onclick="showApp('api-settings-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon wifi">
                                    <i class="fas fa-wifi"></i>
                                </div>
                                <div>API设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('theme-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon settings-icon-custom">
                                    <i class="fas fa-palette"></i>
                                </div>
                                <div>主题设置</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('display-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon display">
                                    <i class="fas fa-font"></i>
                                </div>
                                <div>字号大小</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('appearance-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon display">
                                    <i class="fas fa-mobile-alt"></i>
                                </div>
                                <div>
                                    <div class="setting-label">外观设置</div>
                                </div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('wallpaper-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon wallpaper">
                                    <i class="fas fa-image"></i>
                                </div>
                                <div>壁纸</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('datetime-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon datetime">
                                    <i class="fas fa-clock"></i>
                                </div>
                                <div>日期与时间</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div class="settings-icon notification">
                                    <i class="fas fa-bell"></i>
                                </div>
                                <div>通知</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('data-management-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon data-management">
                                    <i class="fas fa-database"></i>
                                </div>
                                <div>数据管理</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showApp('about-screen')">
                            <div class="settings-item-left">
                                <div class="settings-icon about">
                                    <i class="fas fa-info-circle"></i>
                                </div>
                                <div>关于我们</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 日期与时间设置 -->
                <div id="datetime-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('datetime-screen')">‹</button>
                        <div class="app-title">日期与时间</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>自动设置</div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" checked>
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- 数据管理 -->
                <div id="data-management-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('data-management-screen')">‹</button>
                        <div class="app-title">数据管理</div>
                    </div>
                    <div class="app-content">
                        <!-- 存储空间使用情况 -->
                        <div class="data-section">
                            <div class="data-section-title">存储空间使用情况</div>
                            <div class="storage-usage" id="storage-usage">
                                <div class="storage-item">
                                    <div class="storage-label">聊天记录</div>
                                    <div class="storage-size" id="chat-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">角色数据</div>
                                    <div class="storage-size" id="character-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">聊天设置</div>
                                    <div class="storage-size" id="settings-storage-size">计算中...</div>
                                </div>
                                <div class="storage-item">
                                    <div class="storage-label">表情包</div>
                                    <div class="storage-size" id="emoji-storage-size">计算中...</div>
                                </div>
                                <div class="storage-total">
                                    <div class="storage-label">总计</div>
                                    <div class="storage-size" id="total-storage-size">计算中...</div>
                                </div>
                            </div>
                        </div>

                        <!-- 数据导入导出 -->
                        <div class="data-section">
                            <div class="data-section-title">数据备份与恢复</div>
                            <div class="settings-item" onclick="exportAllData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon export">
                                        <i class="fas fa-download"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">导出所有数据</div>
                                        <div class="setting-desc">将所有聊天记录和设置导出为JSON文件</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="importDataFromFile()">
                                <div class="settings-item-left">
                                    <div class="settings-icon import">
                                        <i class="fas fa-upload"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">导入数据</div>
                                        <div class="setting-desc">从JSON文件恢复聊天记录和设置</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>

                        <!-- 数据检查与修复 -->
                        <div class="data-section">
                            <div class="data-section-title">数据检查与修复</div>
                            <div class="settings-item" onclick="checkAndFixChatHistory()">
                                <div class="settings-item-left">
                                    <div class="settings-icon import">
                                        <i class="fas fa-search"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">检查聊天历史</div>
                                        <div class="setting-desc">检查并修复聊天记录数据，恢复丢失的消息</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        
                        <!-- 选择性清理 -->
                        <div class="data-section">
                            <div class="data-section-title">存储清理</div>
                            <div class="settings-item" onclick="cleanupOrphanedContacts()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-user-slash"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">清理孤立联系人</div>
                                        <div class="setting-desc">清理不存在的角色联系人和相关数据</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>

                            <div class="settings-item" onclick="showCleanupOptions()">
                                <div class="settings-item-left">
                                    <div class="settings-icon cleanup">
                                        <i class="fas fa-broom"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">选择性清理</div>
                                        <div class="setting-desc">清理特定类型的数据以释放空间</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="settings-item" onclick="compressAllImages()">
                                <div class="settings-item-left">
                                    <div class="settings-icon compress">
                                        <i class="fas fa-compress-arrows-alt"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">压缩图片</div>
                                        <div class="setting-desc">压缩所有头像和背景图片以节省空间</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>

                        <!-- 危险操作 -->
                        <div class="data-section danger-section">
                            <div class="data-section-title">危险操作</div>
                            <div class="settings-item danger-item" onclick="clearAllData()">
                                <div class="settings-item-left">
                                    <div class="settings-icon danger">
                                        <i class="fas fa-trash-alt"></i>
                                    </div>
                                    <div>
                                        <div class="setting-label">清空所有数据</div>
                                        <div class="setting-desc">删除所有聊天记录、角色和设置（不可恢复）</div>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 关于我们 -->
                <div id="about-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('about-screen')">‹</button>
                        <div class="app-title">关于我们</div>
                    </div>
                    <div class="app-content">
                        <div class="about-content">
                            <div class="about-title">iPhone 模拟器</div>
                            <div class="about-version">版本 1.0.0</div>
                            <div class="about-author">作者@EVE</div>
                        </div>
                    </div>
                </div>
                
                <!-- 电话通话界面 -->
                <div id="phone-call-screen" class="app-screen">
                    <div class="call-background"></div>
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="call-content">
                        <div class="call-header">
                            <div class="call-avatar">
                                <img id="call-avatar-img" src="" alt="通话头像">
                            </div>
                            <div class="call-name" id="call-name">角色名称</div>
                            <div class="call-status" id="call-status">正在通话中...</div>
                            <div class="call-time" id="call-timer">00:00</div>
                        </div>
                        
                        <div class="call-message-container" id="call-message-container">
                            <!-- 通话中的消息将在这里显示 -->
                        </div>
                        
                        <div class="call-input-area">
                            <input type="text" id="call-input" placeholder="输入消息..." class="call-text-input" onkeypress="if(event.key === 'Enter') { event.preventDefault(); sendCallMessage(); }">
                            <button class="call-send-btn" onclick="sendCallMessage()">
                                <i class="fas fa-paper-plane"></i>
                            </button>
                        </div>
                        
                        <div class="call-controls">
                                                    <button class="call-control-btn end-call-btn" onclick="endCall()"></button>
                        </div>
                    </div>
                </div>
                
                <!-- 来电显示界面 -->
                <div id="incoming-call-screen" class="app-screen">
                    <div class="call-background incoming"></div>
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="incoming-call-content">
                        <div class="call-header">
                            <div class="call-avatar large-avatar">
                                <img id="incoming-call-avatar" src="" alt="来电头像">
                            </div>
                            <div class="call-name" id="incoming-call-name">角色名称</div>
                            <div class="call-status">来电</div>
                            <div class="call-text" id="incoming-call-text">想和你通话...</div>
                        </div>
                        
                        <div class="incoming-call-controls">
                            <button class="incoming-call-btn reject-btn" onclick="rejectCall()">
                                <div class="call-btn-icon">
                                    <i class="fas fa-phone-slash"></i>
                                </div>
                                <div class="call-btn-text">拒绝</div>
                            </button>
                            <button class="incoming-call-btn accept-btn" onclick="acceptCall()">
                                <div class="call-btn-icon">
                                    <i class="fas fa-phone"></i>
                                </div>
                                <div class="call-btn-text">接听</div>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- 字号大小设置 -->
                <div id="display-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('display-screen')">‹</button>
                        <div class="app-title">字号大小</div>
                    </div>
                    <div class="app-content">
                        <div class="font-size-preview">
                            <div class="font-size-preview-text" id="font-size-preview">
                                这是一段示例文字，用于预览字体大小效果。调节下方滑块可以改变字体大小。
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">字号大小</div>
                                    <div class="setting-desc">调节聊天消息和社交动态的字体大小</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="font-size-slider-container">
                            <div class="font-size-labels">
                                <span>小</span>
                                <span>标准</span>
                                <span>大</span>
                            </div>
                            <input type="range" class="font-size-slider" id="font-size-slider" 
                                   min="12" max="20" step="1" value="15" 
                                   onchange="changeFontSize(this.value)">
                            <div class="font-size-value">
                                当前字号：<span id="font-size-value">15px</span>
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">字距设置</div>
                                    <div class="setting-desc">调节文字之间的间距</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="font-size-slider-container">
                            <div class="font-size-labels">
                                <span>紧凑</span>
                                <span>标准</span>
                                <span>宽松</span>
                            </div>
                            <input type="range" class="font-size-slider" id="letter-spacing-slider" 
                                   min="-0.5" max="2" step="0.1" value="0" 
                                   onchange="changeLetterSpacing(this.value)">
                            <div class="font-size-value">
                                当前字距：<span id="letter-spacing-value">标准</span>
                            </div>
                        </div>
                        
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">自动缩放</div>
                                    <div class="setting-desc">根据屏幕尺寸自动调整字体大小</div>
                                </div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" id="auto-scale-toggle" onchange="toggleAutoScale()">
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- 屏幕尺寸设置 -->
                <div id="screen-size-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('screen-size-screen')">‹</button>
                        <div class="app-title">屏幕尺寸</div>
                    </div>
                    <div class="app-content">
                        <div class="size-option" onclick="changeScreenSize(320, 568, 'iPhone SE')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone SE</div>
                                <div class="size-desc">320×568 (小屏模式)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-xs"></div>
                            </div>
                        </div>
                        
                        <div class="size-option" onclick="changeScreenSize(350, 740, '适中尺寸')" id="size-350-740">
                            <div class="size-option-left">
                                <div class="size-name">适中尺寸</div>
                                <div class="size-desc">350×740 (推荐)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-s"></div>
                            </div>
                            <i class="fas fa-check check-icon"></i>
                        </div>
                        
                        <div class="size-option" onclick="changeScreenSize(375, 812, 'iPhone 12/13')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 12/13</div>
                                <div class="size-desc">375×812 (标准)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-m"></div>
                            </div>
                        </div>
                        
                        <div class="size-option" onclick="changeScreenSize(390, 844, 'iPhone 15')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 15</div>
                                <div class="size-desc">390×844 (真实尺寸)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-l"></div>
                            </div>
                        </div>
                        
                        <div class="size-option" onclick="changeScreenSize(428, 926, 'iPhone 15 Plus')">
                            <div class="size-option-left">
                                <div class="size-name">iPhone 15 Plus</div>
                                <div class="size-desc">428×926 (大屏)</div>
                            </div>
                            <div class="size-preview">
                                <div class="size-preview-rect size-preview-rect-xl"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 外观设置 -->
                <div id="appearance-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('appearance-screen')">‹</button>
                        <div class="app-title">外观设置</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">显示手机边框</div>
                                    <div class="setting-desc">显示圆角边框和阴影效果</div>
                                </div>
                            </div>
                            <label class="settings-toggle">
                                <input type="checkbox" id="phone-border-toggle" checked onchange="togglePhoneBorder()">
                                <span class="settings-slider"></span>
                            </label>
                        </div>
                        <div class="settings-item" onclick="showScreenSizeOptions()">
                            <div class="settings-item-left">
                                <div>
                                    <div class="setting-label">屏幕尺寸</div>
                                    <div class="setting-desc" id="current-screen-size">当前：350×740 (适中尺寸)</div>
                                </div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 主题设置界面 -->
                <div id="theme-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('theme-screen')">‹</button>
                        <div class="app-title">主题设置</div>
                    </div>
                    <div class="app-content">
                        <div class="theme-option" onclick="changeTheme('default')">
                            <div class="theme-preview theme-preview-simple">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content"></div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">简约风格</div>
                                <div class="theme-description">清新简洁的默认主题</div>
                            </div>
                        </div>
                        
                        <div class="theme-option" onclick="changeTheme('cute')">
                            <div class="theme-preview theme-preview-cute">
                                <div class="theme-preview-header"></div>
                                <div class="theme-preview-content"></div>
                            </div>
                            <div class="theme-info">
                                <div class="theme-name">可爱风格</div>
                                <div class="theme-description">温馨可爱的粉色主题</div>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
                
                <!-- 壁纸设置 -->
                <div id="wallpaper-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('wallpaper-screen')">‹</button>
                        <div class="app-title">壁纸</div>
                    </div>
                    <div class="app-content">
                        <div class="settings-item" onclick="showWallpaperPicker()">
                            <div class="settings-item-left">
                                <div>选择新壁纸</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="settings-item" onclick="showIconPicker()">
                            <div class="settings-item-left">
                                <div>更改应用图标</div>
                            </div>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 无线局域网设置 -->
                <div id="wifi-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="hideApp('wifi-screen')">‹</button>
                        <div class="app-title">无线局域网</div>
                    </div>
                    <div class="app-content">
                        <div class="wifi-settings">
                            <div class="settings-item">
                                <div class="settings-item-left">
                                    <div>无线局域网</div>
                                </div>
                                <label class="settings-toggle">
                                    <input type="checkbox" checked>
                                    <span class="settings-slider"></span>
                                </label>
                            </div>
                            
                            <div class="wifi-network">
                                <div class="wifi-network-left">
                                    <div class="wifi-icon">
                                        <i class="fas fa-lock"></i>
                                    </div>
                                    <div>
                                        <div>HomeWiFi</div>
                                        <div class="wifi-strength">
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                            <div class="wifi-strength-bar active"></div>
                                        </div>
                                    </div>
                                </div>
                                <i class="fas fa-check check-icon"></i>
                            </div>
                            
                            <div class="settings-item settings-item-margin" onclick="showApp('api-settings-screen')">
                                <div class="settings-item-left">
                                    <div>API设置</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- API设置界面 -->
                <div id="api-settings-screen" class="app-screen">
                    <div class="app-status-bar">
                        <div class="app-status-time"></div>
                        <div class="app-battery-container">
                            <span class="battery-text">ᰔᩚ</span>
                            <div class="app-battery-icon">
                                <div class="app-battery-level"></div>
                            </div>
                        </div>
                    </div>
                    <div class="app-header">
                        <button class="back-button" onclick="backToSettings('api-settings-screen')">‹</button>
                        <div class="app-title">API设置</div>
                    </div>
                    <div class="app-content">
                        <div class="form-container" style="color: #000000;">
                            

                            
                            <!-- 快速设置卡片 -->
                            <div class="form-group" style="margin-bottom: 30px;">
                                <label style="color: #333; margin-bottom: 15px; display: block; font-size: 16px; font-weight: 600;">🚀 快速设置</label>
                                
                                <!-- Gemini直连卡片 -->
                                <div style="margin-bottom: 12px; padding: 18px; background: linear-gradient(135deg, rgba(74, 132, 193, 0.1) 0%, rgba(74, 132, 193, 0.05) 100%); border: 2px solid rgba(74, 132, 193, 0.2); border-radius: 16px; color: #333; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);" onclick="setGeminiDirect()">
                                    <div style="display: flex; align-items: center; justify-content: space-between;">
                                        <div>
                                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: var(--theme-button-bg, #4a84c1);">🌟 Gemini 直连</div>
                                            <div style="font-size: 13px; color: #666;">自动配置Google官方API，支持最新模型</div>
                                        </div>
                                        <div style="background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: white; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: 500; box-shadow: 0 2px 8px rgba(74, 132, 193, 0.3);">点击配置</div>
                                    </div>
                            </div>
                            
                                <!-- HuggingFace反代卡片 -->
                                <div style="margin-bottom: 15px; padding: 18px; background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 193, 7, 0.05) 100%); border: 2px solid rgba(255, 193, 7, 0.2); border-radius: 16px; color: #333; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);" onclick="setHuggingFaceProxy()">
                                    <div style="display: flex; align-items: center; justify-content: space-between;">
                                        <div>
                                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: #f39c12;">🤗 HuggingFace 反代</div>
                                            <div style="font-size: 13px; color: #666;">免费使用多种大模型，支持Claude等</div>
                                        </div>
                                        <div style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: 500; box-shadow: 0 2px 8px rgba(243, 156, 18, 0.3);">点击配置</div>
                                    </div>
                            </div>
                            
                                <div style="font-size: 12px; color: #666; text-align: center; margin-top: 10px;">
                                    ⚠️ 使用前请确保有对应的API密钥
                                </div>
                            </div>
                            
                            <!-- API配置表单 - 美化版 -->
                            <div style="background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-radius: 20px; padding: 25px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);">
                                
                                <!-- API地址 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">API地址</label>
                                    <input type="text" id="api-base" placeholder="例如: https://api.openai.com 或 @https://xxx-xxx.hf.space/v1" style="width: 100%; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); box-sizing: border-box;">
                                    <div style="font-size: 12px; color: #666; margin-top: 5px;">支持标准API和HuggingFace反代（格式：@https://xxx.hf.space/v1）</div>
                            </div>
                            
                                <!-- API密钥 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">API密钥</label>
                                    <input type="password" id="api-key" placeholder="sk-... 或 Google AI Studio API Key" style="width: 100%; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); box-sizing: border-box;">
                                </div>
                                
                                <!-- 模型选择 -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">模型</label>
                                    <div style="display: flex; gap: 10px; align-items: center; width: 100%; overflow: hidden;">
                                        <select id="model-select" style="flex: 1; min-width: 0; padding: 12px 15px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08)); border-radius: 12px; font-size: 16px; background: var(--theme-form-bg, rgba(255, 255, 255, 0.9)); backdrop-filter: blur(10px); transition: all 0.3s ease; color: var(--theme-text-primary, #333); max-height: 200px; overflow-y: auto;">
                                            <!-- 模型选项将通过JS动态填充 -->
                                    </select>
                                        <button id="fetch-models-btn" onclick="fetchModels()" style="padding: 10px 16px; background: var(--theme-button-secondary-bg, rgba(255, 255, 255, 0.8)); color: var(--theme-button-secondary-color, #666); border: 2px solid var(--theme-button-secondary-border, rgba(0, 0, 0, 0.1)); border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 500; backdrop-filter: blur(10px); transition: all 0.3s ease; white-space: nowrap;">拉取模型</button>
                                </div>
                            </div>
                            
                                <!-- 温度参数 -->
                                <div style="margin-bottom: 25px;">
                                    <label style="display: block; margin-bottom: 12px; font-weight: 600; color: var(--theme-text-primary, #333); font-size: 15px;">温度参数 (<span id="temperature-value" style="color: var(--theme-button-bg, #4a84c1); font-weight: 700;">0.75</span>)</label>
                                    <div style="background: rgba(255, 255, 255, 0.8); padding: 15px; border-radius: 12px; border: 2px solid var(--theme-input-border, rgba(0, 0, 0, 0.08));">
                                        <input type="range" id="temperature-slider" min="0" max="2" step="0.05" value="0.75" oninput="document.getElementById('temperature-value').textContent = parseFloat(this.value).toFixed(2);" style="width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(to right, rgba(74, 132, 193, 0.2) 0%, rgba(74, 132, 193, 0.4) 100%); outline: none; -webkit-appearance: none; appearance: none;">
                                        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: #666;">
                                            <span>0.00 (保守)</span>
                                            <span>1.00 (平衡)</span>
                                            <span>2.00 (创新)</span>
                                        </div>
                                        <div style="font-size: 12px; color: #666; margin-top: 8px; text-align: center;">温度越低，回答越保守稳定；温度越高，回答越有创意多样</div>
                                    </div>
                            </div>
                            
                                <!-- 操作按钮 -->
                                <div style="display: flex; gap: 12px; margin-top: 25px;">
                                    <button id="test-api-connection-btn" onclick="testApiConnection()" style="flex: 1; padding: 14px 20px; background: linear-gradient(135deg, #34c759 0%, #30d158 100%); color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(52, 199, 89, 0.3); transition: all 0.3s ease;">测试连接</button>
                                    <button id="save-api-settings-btn" onclick="saveApiSettings()" style="flex: 1; padding: 14px 20px; background: var(--theme-button-bg, rgba(74, 132, 193, 0.9)); color: var(--theme-button-color, white); border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; backdrop-filter: blur(10px); box-shadow: var(--theme-button-shadow, 0 4px 15px rgba(74, 132, 193, 0.3)); transition: all 0.3s ease;">保存设置</button>
                                </div>
                            </div>

                            <!-- API配置管理 -->
                            <hr style="margin: 30px 0; border: none; border-top: 1px solid #eaeaea;">
                            <div class="api-config-manager" style="background: rgba(248, 249, 250, 0.8); border-radius: 16px; padding: 20px; margin: 15px 0; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(0,0,0,0.05);">
                                <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                    <span>💾</span> API配置管理
                                </h4>
                                <p style="font-size: 13px; color: #666; margin: 0 0 15px 0; line-height: 1.5;">保存当前配置为预设，方便快速切换不同的API服务</p>
                                
                                <div class="save-config-section" style="margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.6); border-radius: 12px; border: 1px solid rgba(0,0,0,0.05);">
                                    <div style="display: flex; gap: 10px; margin-bottom: 12px;">
                                        <input type="text" id="config-name-input" placeholder="输入配置名称 (如: OpenAI、Gemini、Claude等)" style="flex: 1; padding: 10px 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; background: rgba(255,255,255,0.9);">
                                        <button id="save-current-config-btn" onclick="saveCurrentConfig()" style="padding: 10px 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">💾 保存配置</button>
                        </div>
                                    <div style="font-size: 12px; color: #888;">当前配置将保存为: <span style="color: #333; font-weight: 500;">URL + 模型 + 温度设置</span></div>
                                </div>
                                
                                <div class="saved-configs-section">
                                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                        <label style="font-size: 14px; font-weight: 500; color: #333;">已保存的配置</label>
                                        <button id="clear-all-configs-btn" onclick="clearAllConfigs()" style="padding: 6px 12px; background: rgba(255, 107, 107, 0.1); color: #ff6b6b; border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;">🗑️ 清空全部</button>
                                    </div>
                                    <div id="saved-configs-container" style="display: grid; gap: 10px; max-height: 300px; overflow-y: auto;">
                                        <!-- 保存的配置卡片将在这里动态生成 -->
                                    </div>
                                    <div id="no-configs-message" style="text-align: center; color: #999; padding: 30px 20px; font-size: 14px; display: none;">
                                        <div style="font-size: 24px; margin-bottom: 8px;">📝</div>
                                        <div>还没有保存任何配置</div>
                                        <div style="font-size: 12px; margin-top: 4px;">在上方输入配置名称并点击"保存配置"</div>
                                    </div>
                                </div>
                            </div>



                        </div>
                    </div>
                </div>
                
                <!-- 颜色选择器模态框 -->
                <div class="modal" id="color-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title" id="color-picker-title">选择颜色</div>
                            <button class="modal-close" onclick="hideModal('color-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="color-picker" id="color-picker">
                                <div class="color-option color-red" onclick="selectColor('#FF3B30')"></div>
                                <div class="color-option color-orange" onclick="selectColor('#FF9500')"></div>
                                <div class="color-option color-yellow" onclick="selectColor('#FFCC00')"></div>
                                <div class="color-option color-green" onclick="selectColor('#34C759')"></div>
                                <div class="color-option color-light-blue" onclick="selectColor('#5AC8FA')"></div>
                                <div class="color-option color-blue" onclick="selectColor('#007AFF')"></div>
                                <div class="color-option color-purple" onclick="selectColor('#5856D6')"></div>
                                <div class="color-option color-pink" onclick="selectColor('#AF52DE')"></div>
                                <div class="color-option color-red-alt" onclick="selectColor('#FF2D55')"></div>
                            </div>
                            <div class="form-group">
                                <label class="form-label">透明度</label>
                                <input type="range" class="opacity-slider" id="opacity-slider" min="0" max="1" step="0.1" value="1">
                                <span id="opacity-value">100%</span>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('color-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="applyColorSelection()">应用</button>
                        </div>
                    </div>
                </div>
                
                <!-- 壁纸选择器模态框 -->
                <div class="modal" id="wallpaper-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择壁纸</div>
                            <button class="modal-close" onclick="hideModal('wallpaper-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="wallpaper-preview-container" id="wallpaper-preview-container">
                                <div class="wallpaper-preview-placeholder">
                                    <i class="fas fa-image"></i>
                                    <div>选择本地图片后可在此预览</div>
                                </div>
                            </div>
                            <div class="settings-item upload-custom-item" onclick="uploadCustomWallpaper()">
                                <div class="settings-item-left">
                                    <div>从相册选择</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <input type="file" id="custom-wallpaper-upload" accept="image/*" class="file-input-hidden">
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('wallpaper-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="applyWallpaperSelection()">应用</button>
                        </div>
                    </div>
                </div>
                
                <!-- 图标选择器模态框 -->
                <div class="modal" id="icon-picker-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择应用图标</div>
                            <button class="modal-close" onclick="hideModal('icon-picker-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="icon-options">
                                <div class="icon-option" onclick="selectAppIcon('chat-screen', 'fas fa-comment-dots')">
                                    <div class="icon-preview">
                                        <i class="fas fa-comment-dots"></i>
                                    </div>
                                    <span>Chat</span>
                                </div>
                                <div class="icon-option" onclick="selectAppIcon('weibo-screen', 'fab fa-weibo')">
                                    <div class="icon-preview">
                                        <i class="fab fa-weibo"></i>
                                    </div>
                                    <span>社交网络</span>
                                </div>
                                <div class="icon-option" onclick="selectAppIcon('music-screen', 'fas fa-music')">
                                    <div class="icon-preview">
                                        <i class="fas fa-music"></i>
                                    </div>
                                    <span>音乐</span>
                                </div>
                                <div class="icon-option" onclick="selectAppIcon('album-screen', 'fas fa-images')">
                                    <div class="icon-preview">
                                        <i class="fas fa-images"></i>
                                    </div>
                                    <span>相册</span>
                                </div>
                            </div>
                            <div class="settings-item upload-custom-item" onclick="uploadCustomIcon()">
                                <div class="settings-item-left">
                                    <div>从相册选择</div>
                                </div>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <input type="file" id="custom-icon-upload" accept="image/*" class="file-input-hidden">
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('icon-picker-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="applyIconSelection()">应用</button>
                        </div>
                    </div>
                </div>
                
                <!-- 照片拍摄模态框 -->

                

                
                <!-- 添加联系人模态框 -->
                <div class="modal" id="add-contact-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">添加联系人</div>
                            <button class="modal-close" onclick="hideModal('add-contact-modal')">&times;</button>
                        </div>
                        <div class="modal-body" id="contact-modal-body">
                            <!-- 联系人选项将通过JS动态生成 -->
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('add-contact-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="addSelectedContacts()">添加</button>
                        </div>
                    </div>
                </div>
                
                <!-- 聊天选项模态框 -->
                <div class="modal" id="chat-options-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择聊天类型</div>
                            <button class="modal-close" onclick="hideModal('chat-options-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="chat-option-item" onclick="showSingleChatSelector()">
                                <div class="chat-option-icon">
                                    <i class="fas fa-user icon-user-blue"></i>
                                </div>
                                <div class="chat-option-text">
                                    <div class="chat-option-title">单聊</div>
                                    <div class="chat-option-desc">与单个角色进行对话</div>
                                </div>
                            </div>
                            <div class="chat-option-item" onclick="showGroupChatSelector()">
                                <div class="chat-option-icon">
                                    <i class="fas fa-users icon-users-green"></i>
                                </div>
                                <div class="chat-option-text">
                                    <div class="chat-option-title">群聊</div>
                                    <div class="chat-option-desc">与多个角色同时聊天</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 单聊角色选择模态框 -->
                <div class="modal" id="single-chat-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">选择聊天角色</div>
                            <button class="modal-close" onclick="hideModal('single-chat-modal')">&times;</button>
                        </div>
                        <div class="modal-body" id="single-chat-body">
                            <!-- 角色列表将通过JS动态生成 -->
                        </div>
                    </div>
                </div>
                
                <!-- 群聊角色选择模态框 -->
                <div class="modal" id="group-chat-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">创建群聊</div>
                            <button class="modal-close" onclick="hideModal('group-chat-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">群聊名称</label>
                                <input type="text" class="form-input" id="group-chat-name" placeholder="例如：动态分享、工作群">
                            </div>
                            <div class="form-group">
                                <label class="form-label">选择成员 (至少2人，最多8人)</label>
                                <div id="group-chat-members">
                                    <!-- 群聊成员选择将通过JS动态生成 -->
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('group-chat-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="createGroupChat()">创建群聊</button>
                        </div>
                    </div>
                </div>
                
                <!-- 历史消息设置模态框 -->
                <div class="modal" id="history-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">历史消息设置</div>
                            <button class="modal-close" onclick="hideModal('history-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-card">
                                <div class="setting-item">
                                    <div class="setting-left">
                                        <div class="setting-label">附带历史消息数 (回合数)</div>
                                        <div class="setting-desc">AI回复时参考的历史对话回合数</div>
                                    </div>
                                    <div class="setting-right">
                                        <span class="setting-value" id="history-count-display">5回合</span>
                                    </div>
                                </div>
                                <div class="setting-range-container">
                                    <input type="range" class="theme-range" id="history-messages-count" min="0" max="100" step="1" value="5">
                                    <div class="range-labels">
                                        <span>0回合</span>
                                        <span>100回合</span>
                                    </div>
                                </div>
                                <div class="custom-input-container">
                                    <span class="input-label">自定义数值：</span>
                                    <input type="number" class="theme-input" id="custom-history-count" min="0" max="500" value="5">
                                    <span class="input-unit">回合 (最大500)</span>
                                </div>
                                <div class="setting-explanation">
                                    <div class="explanation-text">
                                        <strong>说明：</strong><br>
                                        • 一回合 = 你的一条消息 + AI的一条回复<br>
                                        • 设置为5表示AI回复时会参考最近5轮对话<br>
                                        • 注意：数值过大可能影响API响应速度
                                    </div>
                                </div>
                            </div>
                            
                            <div class="setting-card">
                                <div class="setting-item">
                                    <div class="setting-left">
                                        <div class="setting-label">跨窗口记忆回合数</div>
                                        <div class="setting-desc">从其他聊天窗口读取的背景记忆回合数</div>
                                    </div>
                                    <div class="setting-right">
                                        <span class="setting-value" id="cross-memory-display">3回合</span>
                                    </div>
                                </div>
                                <div class="setting-range-container">
                                    <input type="range" class="theme-range" id="cross-chat-memory" min="0" max="20" step="1" value="3">
                                    <div class="range-labels">
                                        <span>0回合</span>
                                        <span>20回合</span>
                                    </div>
                                </div>
                                <div class="setting-explanation">
                                    <div class="explanation-text">
                                        <strong>说明：</strong><br>
                                        • AI会读取其他聊天窗口中最新的几轮对话作为背景记忆<br>
                                        • 一回合 = 用户一条消息 + AI一条回复<br>
                                        • 帮助AI更好地理解整体对话上下文
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="theme-button theme-button-secondary" onclick="hideModal('history-settings-modal')">取消</button>
                            <button class="theme-button theme-button-primary" onclick="saveHistorySettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 记忆挂载设置模态框 -->
                <div class="modal" id="memory-mount-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">记忆挂载设置</div>
                            <button class="modal-close" onclick="hideModal('memory-mount-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="memory-mount-enabled" class="checkbox-with-margin">
                                    启用记忆挂载
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，AI会参考其他聊天窗口的对话内容作为背景记忆
                                </p>
                            </div>
                            <div class="form-group hide" id="memory-mount-details">
                                <label class="form-label">每个聊天挂载条数</label>
                                <input type="range" class="api-form-range" id="memory-mount-count" min="1" max="20" step="1" value="3">
                                <div class="flex-space-between">
                                    <span>1条</span>
                                    <span id="memory-mount-display">3条</span>
                                    <span>20条</span>
                                </div>
                            </div>
                            <div class="form-group hide" id="memory-mount-chats">
                                <label class="form-label">选择要挂载的聊天</label>
                                <div id="memory-mount-list" class="max-height-200-auto">
                                    <!-- 聊天列表将通过JS动态生成 -->
                                </div>
                                <p class="small-text margin-top-8">
                                    选择的聊天记录会作为背景信息提供给AI参考
                                </p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('memory-mount-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveMemoryMountSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 头像设置模态框 -->
                <div class="modal" id="avatar-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">双方头像设置</div>
                            <button class="modal-close" onclick="hideModal('avatar-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="avatar-setting-group">
                                <label class="form-label">我的头像 (仅在此聊天窗口生效)</label>
                                <div class="avatar-preview-container">
                                    <div class="avatar-preview" id="my-chat-avatar-preview">
                                        <i class="fas fa-user"></i>
                                    </div>
                                    <input type="file" id="my-chat-avatar-upload" accept="image/*" class="file-input-hidden">
                                    <button class="upload-button" onclick="document.getElementById('my-chat-avatar-upload').click()">上传头像</button>
                                </div>
                            </div>
                            <div class="avatar-setting-group">
                                <label class="form-label">对方头像 (仅在此聊天窗口生效)</label>
                                <div class="avatar-preview-container">
                                    <div class="avatar-preview" id="ai-chat-avatar-preview">
                                        <i class="fas fa-robot"></i>
                                    </div>
                                    <input type="file" id="ai-chat-avatar-upload" accept="image/*" class="file-input-hidden">
                                    <button class="upload-button" onclick="document.getElementById('ai-chat-avatar-upload').click()">上传头像</button>
                                    <button class="upload-button clear-avatar-btn" onclick="clearAiDynamicAvatar()">清除动态头像</button>
                                </div>
                                <p class="small-text margin-top-5">
                                    注意：如果角色在聊天中更换了头像，动态头像会覆盖此设置，点击"清除动态头像"可重置
                                </p>
                            </div>
                            <div class="form-group margin-top-20">
                                <label class="form-label">
                                    <input type="checkbox" id="hide-avatars" class="checkbox-with-margin">
                                    隐藏双方头像
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，聊天界面将不显示任何头像
                                </p>
                            </div>
                            <p class="small-text margin-top-15">
                                注意：此设置仅影响当前聊天窗口显示，不会同步修改角色卡或面具设置
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('avatar-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatAvatarSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 昵称设置模态框 -->
                <div class="modal" id="nickname-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">双方备注设置</div>
                            <button class="modal-close" onclick="hideModal('nickname-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">我的昵称 (仅在此聊天中显示)</label>
                                <input type="text" class="form-input" id="my-chat-nickname" placeholder="输入你在此聊天中的昵称">
                            </div>
                            <div class="form-group">
                                <label class="form-label">对方昵称 (仅在此聊天中显示)</label>
                                <input type="text" class="form-input" id="ai-chat-nickname" placeholder="输入对方在此聊天中的昵称">
                            </div>
                            <p class="small-text margin-top-10">
                                注意：此设置仅影响当前聊天窗口显示，不会同步修改角色卡或面具设置。角色也可能根据心情和聊天内容自主修改自己的昵称。
                            </p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('nickname-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatNicknameSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 戳一戳后缀设置模态框 -->
                <div class="modal" id="poke-suffix-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">戳一戳后缀设置</div>
                            <button class="modal-close" onclick="hideModal('poke-suffix-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">我的戳一戳后缀</label>
                                <input type="text" class="form-input" id="my-poke-suffix" placeholder="留空为无后缀（例如：的小脸蛋）">
                                <p class="tiny-text margin-top-5">显示为：你戳了戳[角色名][后缀]，留空则显示：你戳了戳[角色名]</p>
                            </div>
                            <div class="form-group">
                                <label class="form-label">对方戳一戳后缀</label>
                                <input type="text" class="form-input" id="ai-poke-suffix" placeholder="留空为无后缀（例如：的小手）">
                                <p class="tiny-text margin-top-5">显示为：[角色名]戳了戳你[后缀]，留空则显示：[角色名]戳了戳你。角色可能根据心情自主修改此后缀。</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('poke-suffix-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="savePokeSuffixSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 聊天背景设置模态框 -->
                <div class="modal" id="background-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">聊天背景设置</div>
                            <button class="modal-close" onclick="hideModal('background-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="background-preview-container">
                                <div class="background-preview" id="chat-background-preview">
                                    <div class="preview-text">背景预览</div>
                                </div>
                            </div>
                            <div class="form-group">
                                <input type="file" id="background-upload" accept="image/*" class="file-input-hidden">
                                <button class="form-button" onclick="document.getElementById('background-upload').click()">选择背景图片</button>
                                <button class="form-button form-button-secondary" onclick="removeBackground()">移除背景</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('background-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveChatBackgroundSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 🔥【新增】群成员气泡颜色设置模态框 -->
                <div class="modal" id="group-member-colors-modal" style="z-index: 10001;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">群成员气泡颜色设置</div>
                            <button class="modal-close" onclick="hideModal('group-member-colors-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="setting-explanation">
                                <div class="explanation-text">为每个群成员设置独特的气泡颜色，让群聊更加生动有趣。</div>
                            </div>
                            <div id="group-member-colors-list">
                                <!-- 动态生成群成员颜色设置项 -->
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('group-member-colors-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveGroupMemberColors()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 气泡样式设置模态框 -->
                <div class="modal" id="bubble-style-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">气泡样式设置</div>
                            <button class="modal-close" onclick="hideModal('bubble-style-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="bubble-style-section">
                                <label class="form-label">选择气泡样式</label>
                                <div class="bubble-style-grid">
                                    <div class="bubble-style-option" data-style="default">
                                        <div class="style-preview">
                                            <div class="preview-bubble sent-preview">默认样式</div>
                                            <div class="preview-bubble received-preview">经典圆角</div>
                                        </div>
                                        <div class="style-name">默认样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="glass">
                                        <div class="style-preview bubble-style-glass">
                                            <div class="preview-bubble sent-preview">毛玻璃</div>
                                            <div class="preview-bubble received-preview">半透明</div>
                                        </div>
                                        <div class="style-name">毛玻璃</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="shadow">
                                        <div class="style-preview bubble-style-shadow">
                                            <div class="preview-bubble sent-preview">经典阴影</div>
                                            <div class="preview-bubble received-preview">立体感</div>
                                        </div>
                                        <div class="style-name">经典阴影</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="tail">
                                        <div class="style-preview bubble-style-tail">
                                            <div class="preview-bubble sent-preview">带尖角</div>
                                            <div class="preview-bubble received-preview">气泡戳</div>
                                        </div>
                                        <div class="style-name">经典气泡</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="gradient">
                                        <div class="style-preview bubble-style-gradient">
                                            <div class="preview-bubble sent-preview">渐变色</div>
                                            <div class="preview-bubble received-preview">美观</div>
                                        </div>
                                        <div class="style-name">渐变样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="minimal">
                                        <div class="style-preview bubble-style-minimal">
                                            <div class="preview-bubble sent-preview">极简线条</div>
                                            <div class="preview-bubble received-preview">简约</div>
                                        </div>
                                        <div class="style-name">极简样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="neon">
                                        <div class="style-preview bubble-style-neon">
                                            <div class="preview-bubble sent-preview">霓虹发光</div>
                                            <div class="preview-bubble received-preview">科技感</div>
                                        </div>
                                        <div class="style-name">霓虹样式</div>
                                    </div>
                                    
                                    <div class="bubble-style-option" data-style="paper">
                                        <div class="style-preview bubble-style-paper">
                                            <div class="preview-bubble sent-preview">纸张卡片</div>
                                            <div class="preview-bubble received-preview">质感</div>
                                        </div>
                                        <div class="style-name">纸张样式</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="color-setting-group">
                                <label class="form-label">自定义颜色</label>
                                <div class="color-picker-container">
                                    <div class="flex-gap-15">
                                        <div class="flex-1">
                                            <label class="label-small">我的气泡</label>
                                            <input type="color" id="my-bubble-color" class="color-input" value="#007AFF">
                                        </div>
                                        <div class="flex-1">
                                            <label class="label-small">对方气泡</label>
                                            <input type="color" id="ai-bubble-color" class="color-input" value="#f0f0f0">
                                            <!-- 🔥【新增】群聊角色单独设置按钮 -->
                                            <div id="group-member-colors-btn" style="display: none; margin-top: 8px;">
                                                <button type="button" class="theme-button theme-button-secondary" style="font-size: 12px; padding: 6px 12px;" onclick="showGroupMemberColorSettings()">
                                                    为群成员单独设置
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="opacity-setting">
                                    <div class="flex-gap-15-mb-15">
                                        <div class="flex-1">
                                            <label class="label-small">我的气泡透明度：<span id="my-bubble-opacity-value">100%</span></label>
                                            <input type="range" id="my-bubble-opacity" min="0.1" max="1" step="0.1" value="1" class="width-100">
                                        </div>
                                        <div class="flex-1">
                                            <label class="label-small">对方气泡透明度：<span id="ai-bubble-opacity-value">100%</span></label>
                                            <input type="range" id="ai-bubble-opacity" min="0.1" max="1" step="0.1" value="1" class="width-100">
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="padding-setting">
                                    <label class="form-label">气泡大小调节</label>
                                    <div class="flex-gap-15-mb-10">
                                        <div class="flex-1">
                                            <label class="label-small">内边距：<span id="bubble-padding-value">中等</span></label>
                                            <input type="range" id="bubble-padding" min="4" max="16" step="2" value="12" class="width-100">
                                        </div>
                                    </div>
                                    <p class="tiny-text-gray margin-top-5">
                                        调整气泡内文字与边缘的距离，数值越大气泡越大
                                    </p>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('bubble-style-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveBubbleStyleSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 定时发布设置模态框 -->
                <div class="modal" id="schedule-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">定时发布设置</div>
                            <button class="modal-close" onclick="hideModal('schedule-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="schedule-enabled" class="checkbox-with-margin">
                                    启用定时发布
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，角色会在指定时间点自动发布社交动态
                                </p>
                            </div>
                            <div class="form-group hide" id="schedule-times-group">
                                <label class="form-label">发布时间点</label>
                                <div id="schedule-times-container">
                                    <!-- 时间点将通过JS动态添加 -->
                                </div>
                                <button type="button" class="form-button form-button-secondary" onclick="addScheduleTime()">+ 添加时间点</button>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('schedule-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveScheduleSettings()">保存</button>
                        </div>
                    </div>
                </div>
                
                <!-- 身份选择器模态框 -->
                <!-- 身份选择模态框已移除，身份在创建对话时选择 -->
                
                <!-- 世界书挂载设置模态框 -->
                <div class="modal" id="worldbook-mount-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">世界书挂载设置</div>
                            <button class="modal-close" onclick="hideModal('worldbook-mount-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="worldbook-mount-enabled" class="checkbox-with-margin">
                                    启用世界书挂载
                                </label>
                                <p class="small-text margin-top-5">
                                    开启后，AI会参考选定的世界书内容作为背景知识进行对话
                                </p>
                            </div>
                            <div class="form-group hide" id="worldbook-mount-details">
                                <label class="form-label">选择要挂载的世界书</label>
                                <div id="worldbook-mount-list" class="max-height-300-auto">
                                    <!-- 世界书列表将通过JS动态生成 -->
                                </div>
                                <p class="small-text margin-top-8">
                                    选择的世界书内容会作为背景知识提供给AI参考，帮助AI更好地理解对话上下文
                                </p>
                            </div>
                            <div class="setting-explanation">
                                <div class="explanation-text">
                                    <strong>功能说明：</strong><br>
                                    • <strong>世界书挂载：</strong>将选定的世界书内容作为AI的背景知识<br>
                                    • <strong>多选支持：</strong>可以同时挂载多个世界书，内容会合并使用<br>
                                    • <strong>智能应用：</strong>AI会根据对话内容智能引用相关的世界书知识<br>
                                    • <strong>优先级：</strong>世界书知识优先级低于角色设定和历史对话
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('worldbook-mount-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveWorldbookMountSettings()">保存</button>
                        </div>
                    </div>
                </div>

                <!-- 日记功能模态框 -->
                <div class="modal" id="diary-options-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">日记功能</div>
                            <button class="modal-close" onclick="hideModal('diary-options-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="diary-option-grid">
                                <div class="diary-option" onclick="viewTodayDiary()">
                                    <div class="diary-option-icon">
                                        <i class="fas fa-edit"></i>
                                    </div>
                                    <div class="diary-option-title">今日日记</div>
                                    <div class="diary-option-desc">查看今天的日记</div>
                                </div>
                                <div class="diary-option" onclick="viewHistoryDiary()">
                                    <div class="diary-option-icon">
                                        <i class="fas fa-history"></i>
                                    </div>
                                    <div class="diary-option-title">过往日记</div>
                                    <div class="diary-option-desc">查看历史日记</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 今日日记模态框 -->
                <div class="modal" id="today-diary-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">今日日记</div>
                            <button class="modal-close" onclick="hideModal('today-diary-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div id="today-diary-content">
                                <div class="diary-placeholder">
                                    <i class="fas fa-book-open"></i>
                                    <p>今日还没有日记，点击生成按钮让角色写一篇日记吧！</p>
                                    <p class="diary-notice">注意：每天只能生成一次日记</p>
                                </div>
                            </div>
                            <div class="diary-actions">
                                                <button class="diary-generate-btn" id="generate-today-diary-btn" onclick="generateTodayDiary()">
                    <i class="fas fa-pen"></i>
                    喊TA写日记啦
                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 过往日记模态框 -->
                <div class="modal" id="history-diary-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">过往日记</div>
                            <button class="modal-close" onclick="hideModal('history-diary-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div id="history-diary-list">
                                <div class="diary-placeholder">
                                    <i class="fas fa-book"></i>
                                    <p>还没有历史日记</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 日记详情模态框 -->
                <div class="modal" id="diary-detail-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title" id="diary-detail-title">日记详情</div>
                            <button class="modal-close" onclick="hideModal('diary-detail-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div id="diary-detail-content">
                                <!-- 日记内容将在这里显示 -->
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('diary-detail-modal')">关闭</button>
                        </div>
                    </div>
                </div>

                <!-- 时间戳设置模态框 -->
                <div class="modal" id="timestamp-settings-modal">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">时间戳设置</div>
                            <button class="modal-close" onclick="hideModal('timestamp-settings-modal')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label class="form-label">
                                    <input type="checkbox" id="timestamp-modal-enabled" class="checkbox-with-margin" checked>
                                    显示时间戳
                                </label>
                                <p class="small-text margin-top-5">
                                    在聊天消息中显示时间信息
                                </p>
                            </div>
                            
                            <div class="form-group" id="timestamp-options-group">
                                <label class="form-label">时间戳位置</label>
                                <div class="timestamp-position-options">
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="center" checked>
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">居中显示</div>
                                            <div class="option-desc">时间戳显示在聊天中间，每5分钟出现一次</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="bubble">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">气泡外侧</div>
                                            <div class="option-desc">时间戳显示在每条消息气泡的外侧</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="avatar">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">头像下方</div>
                                            <div class="option-desc">时间戳显示在头像正下方位置</div>
                                        </div>
                                    </label>
                                    
                                    <label class="radio-option">
                                        <input type="radio" name="timestamp-position" value="inside">
                                        <span class="radio-custom"></span>
                                        <div class="option-content">
                                            <div class="option-label">气泡内</div>
                                            <div class="option-desc">时间戳显示在气泡内右下角，与文字齐平</div>
                                        </div>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="setting-explanation">
                                <div class="explanation-text">
                                    <strong>位置说明：</strong><br>
                                    • <strong>居中显示：</strong>时间戳水平居中，仅在超过5分钟间隔时显示<br>
                                    • <strong>气泡外侧：</strong>每条消息都显示时间，用户消息在左下角，角色消息在右下角<br>
                                    • <strong>头像下方：</strong>时间戳显示在对应头像的正下方位置<br>
                                    • 所有时间戳均使用灰色小字显示，不影响聊天体验
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideModal('timestamp-settings-modal')">取消</button>
                            <button class="modal-button modal-primary" onclick="saveTimestampSettings()">保存</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <!-- 转账功能相关模态框 -->
    <div id="transfer-modal">
        <div class="transfer-content">
                            <div class="transfer-header">发起转账</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">转账金额</label>
                                    <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="1000000000" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">备注 (可选)</label>
                                    <input type="text" id="transfer-note" placeholder="说点什么吧..." maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">确认转账</button>
            </div>
        </div>
    </div>
    
    <div id="transfer-confirm-modal">
        <div class="transfer-confirm-content">
            <div class="transfer-confirm-title">收到一笔转账</div>
            <div class="transfer-confirm-info">
                <div class="transfer-confirm-amount">¥ 0.00</div>
                <div class="transfer-confirm-note">备注：</div>
            </div>
            <div class="transfer-confirm-actions">
                <button id="transfer-reject-btn">退回</button>
                <button id="transfer-accept-btn">确认收款</button>
                </div>
            </div>
        </div>

    <script>
        // 初始化Dexie数据库
        const db = new Dexie('PhoneChatDB');
        window.activeGlobalWorldbooks = []; // 用于存储当前激活的全局世界书ID
        
        // 版本1：原始表结构
        db.version(1).stores({
            characters: '&id, name',
            contacts: '&id, characterId', 
            chatMessages: '&id, characterId, timestamp',
            apiSettings: '&id',
            customEmojis: '&id, description',
            wallpapers: '&id, type',
            worldbooks: '&id, name',
            groupChats: '&id, name',
            personas: '&id, name',
            globalSettings: '&id',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId'
        });
        
        // 版本2：添加动态相关表
        db.version(2).stores({
            characters: '&id, name',
            contacts: '&id, characterId', 
            chatMessages: '&id, characterId, timestamp',
            apiSettings: '&id',
            customEmojis: '&id, description',
            wallpapers: '&id, type',
            worldbooks: '&id, name',
            groupChats: '&id, name',
            personas: '&id, name',
            globalSettings: '&id',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId',
            // 动态相关表
            moments: '&id, authorId, timestamp',
            momentLikes: '[momentId+authorId], momentId, authorId',
            momentComments: '&id, momentId, authorId, timestamp'
        });

        // 版本3：添加最近使用表情包表
        db.version(5).stores({
            characters: '&id, name, groupId',
            contacts: '++id, characterId', 
            chatMessages: '&id, characterId, timestamp',
            apiSettings: '&id',
            customEmojis: '&id, description',
            wallpapers: '&id, type',
            worldbooks: '&id, name, isGlobal',
            characterGroups: '&id, name, order',
            groupChats: '&id, name',
            personas: '&id, name',
            globalSettings: '&id',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId',
            moments: '&id, authorId, timestamp',
            momentLikes: '[momentId+authorId], momentId, authorId',
            momentComments: '&id, momentId, authorId, timestamp',
            recentEmojis: '&id, lastUsed'
        });

        // 版本6：添加拉黑系统和角色状态
        db.version(6).stores({
            characters: '&id, name, groupId',
            contacts: '++id, characterId', 
            chatMessages: '&id, characterId, timestamp',
            apiSettings: '&id',
            customEmojis: '&id, description',
            wallpapers: '&id, type',
            worldbooks: '&id, name, isGlobal',
            characterGroups: '&id, name, order',
            groupChats: '&id, name',
            personas: '&id, name',
            globalSettings: '&id',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId',
            moments: '&id, authorId, timestamp',
            momentLikes: '[momentId+authorId], momentId, authorId',
            momentComments: '&id, momentId, authorId, timestamp',
            recentEmojis: '&id, lastUsed',
            // 🔥【新增】拉黑系统相关表
            blacklist: '&id, blockerId, blockedId, timestamp, cooldownMinutes, reason',
            friendRequests: '&id, fromId, toId, timestamp, status, type, message',
            characterStatus: '&id, characterId, status, activity, location, lastUpdate'
        });

        // 版本7：添加日记功能
        db.version(7).stores({
            characters: '&id, name, groupId',
            contacts: '++id, characterId', 
            chatMessages: '&id, characterId, timestamp',
            apiSettings: '&id',
            customEmojis: '&id, description',
            wallpapers: '&id, type',
            worldbooks: '&id, name, isGlobal',
            characterGroups: '&id, name, order',
            groupChats: '&id, name',
            personas: '&id, name',
            globalSettings: '&id',
            appIcons: '&id, appId',
            chatSettings: '&id, chatId',
            moments: '&id, authorId, timestamp',
            momentLikes: '[momentId+authorId], momentId, authorId',
            momentComments: '&id, momentId, authorId, timestamp',
            recentEmojis: '&id, lastUsed',
            blacklist: '&id, blockerId, blockedId, timestamp, cooldownMinutes, reason',
            friendRequests: '&id, fromId, toId, timestamp, status, type, message',
            characterStatus: '&id, characterId, status, activity, location, lastUpdate',
            // 🔥【新增】日记系统相关表
            diaries: '&id, characterId, date, content, timestamp'
        });


        // 全局变量
        let characters = [];
        let contacts = [];
        let currentChatCharacter = null;
        let chatMessages = {};
        let selectedMessageId = null;
        let personas = []; // 用户面具列表
        let currentPersona = null; // 当前使用的面具
        let editingPersona = null; // 正在编辑的面具
        let isMultiSelectMode = false; // 多选模式状态
        let selectedCharacters = []; // 选中的角色ID列表
        let currentEditingCharacterId = null; // 当前正在编辑的角色ID
        let groupChats = []; // 群聊列表
        let selectedGroupMembers = []; // 群聊成员选择
        let currentWorldbookTab = 'global';
        let currentCharacterCategory = null; // 跟踪当前选择的角色分类
        
        // 角色分组相关变量
        let characterGroups = []; // 角色分组列表
        let isGroupManageMode = false; // 分组管理模式
        let selectedGroupId = null; // 当前选中的分组ID
        
        // 自定义表情包相关变量
        let customEmojis = []; // 用户上传的表情包
        let recentEmojis = []; // 最近使用的表情包
        let currentEmojiTab = 'recent'; // 当前表情包标签页
        
        // 消息多选删除相关变量
        let isMessageSelectionMode = false; // 消息选择模式
        let selectedMessages = new Set(); // 选中的消息ID集合
        
        // 消息列表多选相关变量
        let isMessageListMultiSelectMode = false; // 消息列表多选模式状态
        let selectedConversations = []; // 选中的对话框ID列表
        
        // 动态评论对话轮次追踪
        let commentConversationRounds = new Map(); // 格式: "momentId-characterId" => 轮次数
        
        // 🔥【新增】拉黑系统相关变量已在后面声明
        
        let apiSettings = {
            type: 'openai',
            base: 'https://api.openai.com/v1',
            endpoint: '/chat/completions',
            key: '',
            model: 'gpt-3.5-turbo',
            temperature: 0.70
        };
        
        // 注意：记忆设置现在已改为每个聊天窗口独立的设置，存储在各自的聊天设置中
        
        let chatSettings = {
            themeColor: '#007AFF',
            theirBubbleColor: '#f0f0f0',
            myBubbleColor: '#007AFF',
            bubbleOpacity: 1,
            timestampEnabled: true,
            timestampPosition: 'center'
        };
        

        let selectedAppIcon = null;
        let selectedWallpaper = null;
        let colorPickerContext = null;
        let customIconImage = null;
        
        // 加载全局世界书设置
        async function loadGlobalWorldbookSettings() {
            try {
                const globalSettings = await db.globalSettings.get('main');
                if (globalSettings && globalSettings.activeGlobalWorldbooks) {
                    // 确保使用window.activeGlobalWorldbooks以在全局范围内可用
                    window.activeGlobalWorldbooks = globalSettings.activeGlobalWorldbooks;
                } else {
                    window.activeGlobalWorldbooks = [];
                    // 如果没有找到设置，创建一个初始设置
                    await db.globalSettings.put({
                        id: 'main',
                        activeGlobalWorldbooks: []
                    });
                }
            } catch (error) {
                console.error('加载全局世界书设置失败:', error);
                window.activeGlobalWorldbooks = [];
            }
        }

        // 初始化应用
        document.addEventListener('DOMContentLoaded', async function() {
            updateTime();
            
            try {
            
            // 并行加载所有数据
            await Promise.all([
                loadCharacterGroups(), // 先加载分组
                loadCharacters(),
                loadContacts(), 
                loadChatMessages(),
    
                loadChatSettings(),
                loadApiSettings(),
                loadCustomEmojis(),
                loadGlobalWorldbookSettings() // 确保加载全局世界书设置
            ]);
            
            // 加载外观设置
            loadPhoneBorderSetting();
            loadScreenSize();
            loadFontSizeSettings();
            
            // 加载动态图片设置
            await loadMomentsImages();
            
            // 加载其他设置（包括需要数据库的壁纸设置）
            await loadWallpaper();
            await loadAppIcons();
            loadSavedTheme();
            await loadWorldbooks();
            loadMusicData();
            await loadPersonas();
            await loadGroupChats();
            
            // 渲染界面 - 添加数据验证
            try {
                if (characters && contacts && chatMessages) {
            renderMessageList();
            renderContactList();
            renderCharacterList();
            renderPersonaList();
                } else {
                    console.warn('数据未完全加载，推迟界面渲染');
                    // 延迟重试渲染
                    setTimeout(() => {
                        renderMessageList();
                        renderContactList();
                        renderCharacterList();
                        renderPersonaList();
                    }, 500);
                }
            } catch (renderError) {
                console.error('界面渲染失败:', renderError);
                // 尝试重新初始化空数据
                if (!chatMessages) chatMessages = {};
                if (!contacts) contacts = [];
                if (!characters) characters = [];
                renderMessageList();
                renderContactList();
                renderCharacterList();
            }
            
            // 初始化时设置正确的按钮显示状态 - 延迟执行确保DOM加载完成
            setTimeout(() => {
                switchChatTab('message-list');
                // 确保app标题有chat-mode类和正确内容
                const appTitle = document.querySelector('#chat-screen .app-title');
                if (appTitle) {
                    appTitle.classList.add('chat-mode');
                    appTitle.textContent = '💬';
                }
                
                // 初始化UI事件不依赖于currentChatCharacter
                initChatSettingsUIEvents();
                
                // 如果已经有聊天角色，才初始化设置和世界书
                if (currentChatCharacter) {
                initializeChatSettings(); // 初始化聊天设置界面
                updateWorldbookMountDisplay(); // 更新世界书挂载显示
                } else {
                    // 应用初始化完成，等待选择聊天角色
                }
            }, 100);
            
            // 温度滑块显示
            const temperatureSlider = document.getElementById('temperature-slider');
            if (temperatureSlider) {
                temperatureSlider.addEventListener('input', function() {
                document.getElementById('temperature-value').textContent = parseFloat(this.value).toFixed(2);
            });
            }
            
            // 初始化API设置界面
            initializeApiSettings();
            
            // 透明度滑块显示
            document.getElementById('opacity-slider').addEventListener('input', function() {
                document.getElementById('opacity-value').textContent = Math.round(this.value * 100) + '%';
            });
            
            // 按Enter键发送消息
            document.getElementById('api-chat-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // 防止换行
                    sendApiMessage();
                }
            });

            // 🔥【新增】@成员功能 - 输入监听
            document.getElementById('api-chat-input').addEventListener('input', handleMentionInput);
            document.getElementById('api-chat-input').addEventListener('keydown', handleMentionKeydown);
            
            // 点击其他地方隐藏@下拉框
            document.addEventListener('click', function(e) {
                const input = document.getElementById('api-chat-input');
                const dropdown = document.getElementById('mention-dropdown');
                if (dropdown && input && !input.contains(e.target) && !dropdown.contains(e.target)) {
                    hideMentionDropdown();
                }
            });
            

            
            // 初始化头像上传功能
            initializeAvatarUpload();
            
            // 初始化表情包上传功能
            initializeEmojiUpload();
            
            // 确保工具面板初始隐藏
            const toolsPanel = document.getElementById('tools-panel');
            if (toolsPanel) {
                toolsPanel.style.display = 'none';
            }
            
            // 初始化消息选择模式状态
            isMessageSelectionMode = false;
            selectedMessages.clear();
            
            // 图片上传
            document.getElementById('image-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];
                    
                    // 检查文件类型，GIF格式不被Gemini API支持
                    if (file.type === 'image/gif') {
                        alert('抱歉，Gemini API 不支持 GIF 格式的图片。\n\n请选择其他格式的图片，如：\n• JPEG\n• PNG\n• WEBP');
                        // 清空文件选择器
                        e.target.value = '';
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        // 🔥【修复】直接发送图片消息，就像正常的图片发送一样
                        sendImageMessage(event.target.result);
                    };
                    reader.readAsDataURL(file);
                }
                
                // 清空文件选择器，允许重复选择同一文件
                e.target.value = '';
            });
            
            // 自定义壁纸上传
            document.getElementById('custom-wallpaper-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        selectedWallpaper = event.target.result;
                        
                        // 更新预览容器
                        const previewContainer = document.getElementById('wallpaper-preview-container');
                        if (previewContainer) {
                            previewContainer.innerHTML = `<img src="${selectedWallpaper}" class="wallpaper-preview-image" alt="壁纸预览">`;
                        }
                        
                        // 不在这里立即应用到主界面，等用户点击应用时再应用
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
            
            // 自定义图标上传
            document.getElementById('custom-icon-upload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        customIconImage = event.target.result;
                        // 更新预览
                        const previews = document.querySelectorAll('.icon-preview');
                        previews.forEach(preview => {
                            preview.style.backgroundImage = `url(${customIconImage})`;
                            preview.innerHTML = ''; // 移除图标
                        });
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
            
            setInterval(updateTime, 1000);
            initBatteryManager();
            
            // 🔥【新增】初始化全局动态发布系统
            setTimeout(async () => {
                try {
                    await initGlobalMomentsSystem();
                    console.log('✅ 全局动态发布系统初始化完成');
                } catch (error) {
                    console.error('❌ 全局动态发布系统初始化失败:', error);
                }
            }, 3000); // 延迟3秒确保数据完全加载
            
            } catch (error) {
                console.error('应用初始化失败:', error);
                // 如果是数据库错误，尝试重置
                if (error.name === 'DataError' || error.name === 'InvalidStateError' || error.name === 'DexieError') {
                    console.log('检测到数据库错误，尝试重置数据库...');
                    if (confirm('应用初始化失败，是否重置数据库？\n注意：这将清除所有本地数据。')) {
                        await resetDatabase();
                    }
                } else {
                    alert('应用初始化失败，请刷新页面重试。');
                }
            }
        });
        
        // 显示/隐藏应用
        function showApp(appId) {
            if (event) event.preventDefault();
            
            // 隐藏所有app界面
            const allApps = document.querySelectorAll('.app-screen');
            allApps.forEach(app => {
                app.style.display = 'none';
            });
            
            // 隐藏主屏幕组件
            const clockContainer = document.getElementById('clock-container');
            const appGrid = document.getElementById('app-grid');
            if (clockContainer) clockContainer.style.display = 'none';
            if (appGrid) appGrid.style.display = 'none';
            
            // 显示目标界面
            document.getElementById(appId).style.display = 'flex';
            
            // 如果是聊天界面，刷新消息列表
            if (appId === 'chat-screen') {
                renderMessageList();
            }
            
            // 如果是API设置界面，初始化设置
            if (appId === 'api-settings-screen') {
                // 延迟一点时间确保DOM已渲染
                setTimeout(() => {
                    initializeApiSettings();
                }, 100);
            }
        }
        

        
        // 隐藏角色创建表单，返回到chat界面的通讯录
        function hideCharacterForm() {
            // 在隐藏表单时清空表单数据
            clearCharacterForm();
            
            hideApp('character-form-screen');
            showApp('chat-screen');
            switchChatTab('contact-list');
            // 手动触发标签切换的样式
            const chatTabs = document.querySelectorAll('.chat-tab');
            chatTabs.forEach(tab => {
                if (tab && tab.classList) {
                    tab.classList.remove('active');
                }
            });
            // 安全地添加active类到第二个标签（通讯录）
            if (chatTabs.length > 1 && chatTabs[1] && chatTabs[1].classList) {
                chatTabs[1].classList.add('active');
            }
        }
        
        function hideApp(appId) {
            document.getElementById(appId).style.display = 'none';
            
            // 检查是否所有应用都已隐藏，如果是，显示主屏幕组件
            const allApps = document.querySelectorAll('.app-screen');
            const hasVisibleApp = Array.from(allApps).some(app => 
                app.style.display === 'flex' || app.style.display === 'block'
            );
            
            if (!hasVisibleApp) {
                // 显示主屏幕组件
                const clockContainer = document.getElementById('clock-container');
                const appGrid = document.getElementById('app-grid');
                if (clockContainer) clockContainer.style.display = 'block';
                if (appGrid) appGrid.style.display = 'flex';
            }
        }
        
        // 显示/隐藏模态框
        function showModal(modalId) {
            document.getElementById(modalId).style.display = 'flex';
            
            // 如果是添加联系人模态框，渲染可选联系人
            if (modalId === 'add-contact-modal') {
                renderContactModal();
            }
        }
        
        function hideModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // ==================== 日记功能 ====================
        
        // 显示日记选项
        function showDiaryOptions() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色进行聊天', 'error');
                return;
            }
            showModal('diary-options-modal');
        }

        // 查看今日日记
        async function viewTodayDiary() {
            hideModal('diary-options-modal');
            showModal('today-diary-modal');
            
            const today = new Date().toDateString();
            const todayDiary = await getTodayDiary(currentChatCharacter.id, today);
            
            const contentDiv = document.getElementById('today-diary-content');
            const generateBtn = document.getElementById('generate-today-diary-btn');
            
            if (todayDiary) {
                // 显示已有的今日日记
                contentDiv.innerHTML = `
                    <div class="diary-content">
                        <div class="diary-date">${formatDiaryDate(todayDiary.date)}</div>
                        <div class="diary-text">${todayDiary.content}</div>
                    </div>
                `;
                generateBtn.style.display = 'none';
            } else {
                // 显示占位符和生成按钮
                contentDiv.innerHTML = `
                    <div class="diary-placeholder">
                        <i class="fas fa-book-open"></i>
                        <p>今日还没有日记，喊TA写一篇日记吧！</p>
                        <p class="diary-notice">注意：每天只能生成一次日记</p>
                    </div>
                `;
                generateBtn.style.display = 'block';
            }
        }

        // 查看过往日记
        async function viewHistoryDiary() {
            hideModal('diary-options-modal');
            showModal('history-diary-modal');
            
            const historyList = document.getElementById('history-diary-list');
            const diaries = await getCharacterDiaries(currentChatCharacter.id);
            
            if (diaries.length === 0) {
                historyList.innerHTML = `
                    <div class="diary-placeholder">
                        <i class="fas fa-book"></i>
                        <p>还没有历史日记</p>
                    </div>
                `;
            } else {
                historyList.innerHTML = diaries.map(diary => `
                    <div class="diary-history-item" onclick="viewDiaryDetail('${diary.id}')">
                        <div class="diary-history-date">${formatDiaryDate(diary.date)}</div>
                        <div class="diary-history-preview">${diary.content.substring(0, 100)}...</div>
                    </div>
                `).join('');
            }
        }

        // 生成今日日记
        async function generateTodayDiary() {
            const generateBtn = document.getElementById('generate-today-diary-btn');
            const contentDiv = document.getElementById('today-diary-content');
            
            // 检查今天是否已经生成过日记
            const today = new Date().toDateString();
            const existingDiary = await getTodayDiary(currentChatCharacter.id, today);
            
            if (existingDiary) {
                showToast('今天已经生成过日记了', 'error');
                return;
            }
            
            // 显示加载状态
            generateBtn.disabled = true;
            contentDiv.innerHTML = `
                <div class="diary-loading">
                    <i class="fas fa-spinner"></i>
                    <p>正在生成日记...</p>
                </div>
            `;
            
            try {
                // 使用与角色主动发消息相同的上下文系统
                const userDisplayName = localStorage.getItem('userDisplayName') || 'user';
                
                // 获取聊天设置，使用相同的记忆机制
                const chatSettings = await getAsyncChatSettings(currentChatCharacter.id);
                
                // 获取角色人设
                const persona = chatSettings?.aiPersona || currentChatCharacter.bio || `你是${currentChatCharacter.name}。`;
                
                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 获取聊天上下文 - 使用设置的记忆轮数
                let chatContext = '';
                const characterMessages = chatMessages[currentChatCharacter.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\n最近的聊天记录（供参考）：\n' + 
                        recentHistory.map(msg => {
                            if (msg.sender === 'sent') return `用户：${msg.content}`;
                            return `${currentChatCharacter.name}：${msg.content}`;
                        }).join('\n');
                }
                
                // 获取挂载的聊天记忆 - 跨窗口记忆
                let mountedMemoryContent = '';
                try {
                    mountedMemoryContent = await getMountedMemories(currentChatCharacter.id, chatSettings);
                } catch (error) {
                    console.error('获取挂载记忆失败:', error);
                }
                
                // 获取最新的5条动态及其评论 - 与发动态功能相同
                let momentsContext = '';
                try {
                    const recentMoments = await getVisibleMomentsForCharacter(currentChatCharacter.id, 5);
                    if (recentMoments.length > 0) {
                        momentsContext = '\n\n【最新动态记忆】以下是最近的动态内容，你可以在日记中自然地提及：\n';
                        recentMoments.forEach((moment, index) => {
                            const authorName = moment.authorId === 'user' ? '用户' : moment.nickname;
                            momentsContext += `${index + 1}. ${authorName}: ${moment.text}\n`;
                            
                            // 添加评论内容
                            if (moment.comments && moment.comments.length > 0) {
                                momentsContext += `   评论：\n`;
                                moment.comments.slice(0, 3).forEach(comment => {
                                    const commentAuthor = comment.characterId === 'user' ? '用户' : 
                                        (comment.nickname || '未知');
                                    momentsContext += `   - ${commentAuthor}: ${comment.text}\n`;
                                });
                            }
                        });
                    }
                } catch (error) {
                    console.error('获取动态记忆失败:', error);
                }
                
                // 构建完整的日记生成prompt
                const prompt = `当${userDisplayName}进行【查看日记】时，你需要根据${currentChatCharacter.name}的人设口吻和当前剧情与记忆，用日志的格式发送一篇${currentChatCharacter.name}的私人日记，包括日期、对${userDisplayName}的真实感情等，自行拓展。

## 角色设定：
${persona}${worldBookContent}${chatContext}${mountedMemoryContent}${momentsContext}

## 日记要求：
1. 完全以${currentChatCharacter.name}的第一人称视角写日记
2. 体现角色的性格特点和说话风格
3. 基于上述所有记忆和上下文信息，写出真实的内心感受
4. 用日记的格式，包含日期
5. 可以提及最近的聊天、动态、评论等内容
6. 表达对${userDisplayName}的真实感情和想法
7. 不要出现任何对话格式或AI回复
8. 字数控制在200-400字之间

请开始写日记：`;
                
                // 调用API生成日记
                const response = await generateDiaryContent(prompt);
                
                if (response) {
                    // 保存日记到数据库
                    const diary = {
                        id: Date.now().toString(),
                        characterId: currentChatCharacter.id,
                        date: today,
                        content: response,
                        timestamp: new Date().toISOString()
                    };
                    
                    await saveDiary(diary);
                    
                    // 显示生成的日记
                    contentDiv.innerHTML = `
                        <div class="diary-content">
                            <div class="diary-date">${formatDiaryDate(today)}</div>
                            <div class="diary-text">${response}</div>
                        </div>
                    `;
                    generateBtn.style.display = 'none';
                    
                    showToast('日记生成成功！', 'success');
                } else {
                    throw new Error('生成日记失败');
                }
            } catch (error) {
                console.error('生成日记失败:', error);
                let errorMessage = '生成日记失败，请稍后重试';
                
                // 针对不同错误类型给出具体提示
                if (error.message.includes('500')) {
                    errorMessage = 'API服务器错误，请检查API设置或稍后重试';
                } else if (error.message.includes('401')) {
                    errorMessage = 'API密钥无效，请检查API设置';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage = '网络连接失败，请检查网络或API地址';
                }
                
                contentDiv.innerHTML = `
                    <div class="diary-error">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>${errorMessage}</p>
                    </div>
                `;
                generateBtn.disabled = false;
                showToast(errorMessage, 'error');
            }
        }

        // 查看日记详情
        async function viewDiaryDetail(diaryId) {
            hideModal('history-diary-modal');
            
            const diary = await getDiaryById(diaryId);
            if (!diary) {
                showToast('日记不存在', 'error');
                return;
            }
            
            const titleElement = document.getElementById('diary-detail-title');
            const contentElement = document.getElementById('diary-detail-content');
            
            titleElement.textContent = `${currentChatCharacter.name}的日记`;
            contentElement.innerHTML = `
                <div class="diary-content">
                    <div class="diary-date">${formatDiaryDate(diary.date)}</div>
                    <div class="diary-text">${diary.content}</div>
                </div>
            `;
            
            showModal('diary-detail-modal');
        }

        // 获取今日日记
        async function getTodayDiary(characterId, date) {
            try {
                const diary = await db.diaries.where({characterId, date}).first();
                return diary;
            } catch (error) {
                console.error('获取今日日记失败:', error);
                return null;
            }
        }

        // 获取角色的所有日记
        async function getCharacterDiaries(characterId) {
            try {
                // 修复Dexie查询语法
                const diaries = await db.diaries
                    .where('characterId')
                    .equals(characterId)
                    .toArray();
                
                // 手动按时间戳排序（最新的在前）
                return diaries.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            } catch (error) {
                console.error('获取角色日记失败:', error);
                return [];
            }
        }

        // 根据ID获取日记
        async function getDiaryById(diaryId) {
            try {
                const diary = await db.diaries.get(diaryId);
                return diary;
            } catch (error) {
                console.error('获取日记详情失败:', error);
                return null;
            }
        }

        // 保存日记
        async function saveDiary(diary) {
            try {
                await db.diaries.put(diary);
            } catch (error) {
                console.error('保存日记失败:', error);
                throw error;
            }
        }

        // 生成日记内容
        async function generateDiaryContent(prompt) {
            try {
                const requestBody = {
                    model: apiSettings.model,
                    messages: [
                        {
                            role: "user",
                            content: prompt
                        }
                    ],
                    temperature: apiSettings.temperature
                    // 移除max_tokens参数，Gemini API不支持
                };

                console.log('发送日记生成请求:', requestBody);

                const response = await fetch(apiSettings.base + apiSettings.endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                console.log('日记生成响应:', data);

                if (data.choices && data.choices[0] && data.choices[0].message) {
                    return data.choices[0].message.content.trim();
                } else {
                    throw new Error('无效的API响应格式');
                }
            } catch (error) {
                console.error('API调用失败:', error);
                throw error;
            }
        }

        // 格式化日记日期
        function formatDiaryDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('zh-CN', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                weekday: 'long'
            });
        }



        // 显示提示信息
        function showToast(message, type = 'info') {
            // 创建toast元素
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            
            // 添加样式
            Object.assign(toast.style, {
                position: 'fixed',
                top: '20px',
                left: '50%',
                transform: 'translateX(-50%)',
                background: type === 'error' ? '#ff4444' : type === 'success' ? '#00aa00' : '#007bff',
                color: 'white',
                padding: '12px 20px',
                borderRadius: '8px',
                zIndex: '10001',
                fontSize: '14px',
                boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                opacity: '0',
                transition: 'opacity 0.3s ease'
            });
            
            document.body.appendChild(toast);
            
            // 显示动画
            setTimeout(() => toast.style.opacity = '1', 100);
            
            // 自动消失
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => document.body.removeChild(toast), 300);
            }, 3000);
        }

        // ==================== 日记功能结束 ====================
        
        // 切换照片文字显示
        function togglePhotoText(container, description) {
            const overlay = container.querySelector('.photo-text-overlay');
            const sparkles = container.querySelector('.sparkle-container');
            const badge = container.querySelector('.photo-badge');
            
            if (overlay.style.display === 'none') {
                // 显示文字，隐藏星星和标志
                overlay.style.display = 'flex';
                sparkles.style.opacity = '0';
                badge.style.opacity = '0.3';
            } else {
                // 隐藏文字，显示星星和标志
                overlay.style.display = 'none';
                sparkles.style.opacity = '1';
                badge.style.opacity = '1';
            }
        }

        // 显示用户照片描述
        function showUserPhotoDescription(description) {
            const modalHtml = `
                <div id="photo-description-modal" class="modal" style="display: flex; z-index: 10000; background: rgba(0, 0, 0, 0.8);">
                    <div class="magical-photo-modal">
                        <div class="photo-modal-bg"></div>
                        <div class="photo-modal-content">
                            <div class="photo-modal-header">
                                <i class="fas fa-camera photo-modal-icon"></i>
                                <div class="photo-modal-title">照片内容</div>
                            </div>
                            <div class="photo-modal-body">
                                <div class="photo-description-text">${description}</div>
                            </div>
                            <div class="photo-modal-footer">
                                <button class="photo-modal-btn" id="photo-description-close">确定</button>
                            </div>
                        </div>
                        <div class="modal-sparkles">
                            <div class="modal-sparkle modal-sparkle-1">✨</div>
                            <div class="modal-sparkle modal-sparkle-2">⭐</div>
                            <div class="modal-sparkle modal-sparkle-3">✨</div>
                            <div class="modal-sparkle modal-sparkle-4">⭐</div>
                            <div class="modal-sparkle modal-sparkle-5">💫</div>
                            <div class="modal-sparkle modal-sparkle-6">✨</div>
                            <div class="modal-sparkle modal-sparkle-7">⭐</div>
                            <div class="modal-sparkle modal-sparkle-8">💫</div>
                        </div>
                    </div>
                </div>
            `;
            
            // 添加到页面
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            const modal = document.getElementById('photo-description-modal');
            const closeBtn = document.getElementById('photo-description-close');
            
            // 关闭按钮事件
            closeBtn.onclick = () => {
                modal.remove();
            };
            
            // 点击背景关闭
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }

        // 自定义输入提示框
        function showCustomPrompt(title, placeholder, initialValue = '', type = 'text') {
            return new Promise(resolve => {
                // 创建模态框HTML
                const modalHtml = `
                    <div id="custom-prompt-modal" class="modal" style="display: flex; z-index: 10000;">
                        <div class="modal-content" style="max-width: 400px;">
                            <div class="modal-header">
                                <div class="modal-title">${title}</div>
                            </div>
                            <div class="modal-body">
                                <input type="${type}" id="custom-prompt-input" class="form-input" 
                                       placeholder="${placeholder}" value="${initialValue}"
                                       style="width: 100%; margin-top: 10px;">
                            </div>
                            <div class="modal-footer">
                                <button class="modal-button modal-secondary" id="custom-prompt-cancel">取消</button>
                                <button class="modal-button modal-primary" id="custom-prompt-confirm">确定</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // 添加到页面
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                
                const modal = document.getElementById('custom-prompt-modal');
                const input = document.getElementById('custom-prompt-input');
                const confirmBtn = document.getElementById('custom-prompt-confirm');
                const cancelBtn = document.getElementById('custom-prompt-cancel');
                
                // 确定按钮事件
                confirmBtn.onclick = () => {
                    const value = input.value;
                    modal.remove();
                    resolve(value);
                };
                
                // 取消按钮事件
                cancelBtn.onclick = () => {
                    modal.remove();
                    resolve(null);
                };
                
                // 回车键确认
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        confirmBtn.click();
                    }
                };
                
                // 聚焦输入框
                setTimeout(() => input.focus(), 100);
            });
        }
        
        // 切换聊天标签
        function switchChatTab(tabId) {
            // 移除所有标签的active类
            document.querySelectorAll('.chat-tab').forEach(tab => {
                if (tab && tab.classList) {
                    tab.classList.remove('active');
                }
            });
            
            // 添加当前标签的active类
            if (event && event.currentTarget && event.currentTarget.classList) {
                event.currentTarget.classList.add('active');
            } else {
                // 如果没有event对象，根据tabId设置active
                if (tabId === 'message-list') {
                    const messageTab = document.getElementById('message-tab');
                    if (messageTab && messageTab.classList) {
                        messageTab.classList.add('active');
                    }
                } else if (tabId === 'contact-list') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 1 && tabs[1] && tabs[1].classList) {
                        tabs[1].classList.add('active');
                    }
                } else if (tabId === 'moments-page') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 2 && tabs[2] && tabs[2].classList) {
                        tabs[2].classList.add('active');
                    }
                } else if (tabId === 'profile-page') {
                    const tabs = document.querySelectorAll('.chat-tab');
                    if (tabs.length > 3 && tabs[3] && tabs[3].classList) {
                        tabs[3].classList.add('active');
                    }
                }
            }
            
            // 隐藏所有内容
            const messageListEl = document.getElementById('message-list');
            const contactListEl = document.getElementById('contact-list');
            const profilePageEl = document.getElementById('profile-page');
            const momentsPageEl = document.getElementById('moments-page');
            const targetEl = document.getElementById(tabId);
            
            if (messageListEl) messageListEl.style.display = 'none';
            if (contactListEl) contactListEl.style.display = 'none';
            if (profilePageEl) profilePageEl.style.display = 'none';
            if (momentsPageEl) momentsPageEl.style.display = 'none';
            
            // 显示选中的内容
            if (targetEl) targetEl.style.display = 'block';
            
            // 控制app标题的渐变效果和内容
            const appTitle = document.querySelector('#chat-screen .app-title');
            if (appTitle) {
                if (tabId === 'message-list') {
                    appTitle.classList.add('chat-mode');
                    appTitle.textContent = '💬';
                } else if (tabId === 'contact-list') {
                    appTitle.classList.remove('chat-mode');
                    appTitle.textContent = '角色';
                } else if (tabId === 'moments-page') {
                    appTitle.classList.remove('chat-mode');
                                            appTitle.textContent = '动态';
                    // 🔥【新增】切换到动态页面时加载用户设置
                    loadMomentsImages();
                } else if (tabId === 'profile-page') {
                    appTitle.classList.remove('chat-mode');
                    appTitle.textContent = '我';
                }
            }
            
            // 控制按钮显示
            const addContactBtn = document.getElementById('add-contact-btn');
            const addChatBtn = document.getElementById('add-chat-btn');
            const groupManageBtn = document.getElementById('group-manage-btn');
            
            if (addContactBtn && addChatBtn && groupManageBtn) {
                if (tabId === 'contact-list') {
                    addContactBtn.style.display = 'flex';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = isGroupManageMode ? 'none' : 'flex';
                    // 修改加号按钮的点击事件为创建角色
                    addContactBtn.onclick = () => showCharacterForm();
                } else if (tabId === 'message-list') {
                    addContactBtn.style.display = 'none';
                    addChatBtn.style.display = 'flex';
                    groupManageBtn.style.display = 'none';
                } else if (tabId === 'moments-page') {
                                            // 动态页面显示发布按钮
                    addContactBtn.style.display = 'flex';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = 'none';
                    // 修改加号按钮的点击事件为发布动态
                    addContactBtn.onclick = () => showPublishMoment();
                } else {
                    addContactBtn.style.display = 'none';
                    addChatBtn.style.display = 'none';
                    groupManageBtn.style.display = 'none';
                }
            }
            
            // 如果是动态页面，检查是否需要加载动态内容
            if (tabId === 'moments-page') {
                // 只在动态列表为空时加载，避免重复显示
                const momentsList = document.getElementById('moments-list');
                if (momentsList && momentsList.children.length === 0) {
                loadMoments();
                }
                                        // 移除动态页面的padding，实现全屏效果
                const chatContent = document.getElementById('chat-content');
                if (chatContent) {
                    chatContent.style.padding = '0';
                }
            } else {
                // 其他页面恢复正常padding
                const chatContent = document.getElementById('chat-content');
                if (chatContent) {
                    chatContent.style.padding = '15px';
                }
                
                // 停止时间更新器（节省资源）
                stopTimeUpdater();
            }
        }
        
        // 更新时间
        function updateTime() {
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const timeString = `${hours}:${minutes}`;
            
            // 更新状态栏时间
            const statusTime = document.getElementById('status-bar-time');
            if (statusTime) {
                statusTime.textContent = timeString;
            }
            
            // 更新应用内状态栏时间
            const appStatusTimes = document.querySelectorAll('.app-status-time');
            appStatusTimes.forEach(element => {
                element.textContent = timeString;
            });
            
            // 更新主时钟
            const mainTime = document.getElementById('main-time');
            if (mainTime) {
                mainTime.textContent = timeString;
            }
            
            // 更新日期
            const mainDate = document.getElementById('main-date');
            if (mainDate) {
                const date = now.toLocaleDateString('zh-CN', { 
                    month: 'long', 
                    day: 'numeric',
                    weekday: 'long'
                });
                mainDate.textContent = date;
            }
        }
        
        // 加载角色分组数据
        async function loadCharacterGroups() {
            try {
                const savedGroups = await db.characterGroups.orderBy('order').toArray();
                
                if (savedGroups.length === 0) {
                    // 如果没有分组，创建默认分组
                    const defaultGroups = [
                        { id: 'my_friends', name: '我的好友', order: 999, isDefault: true, canInteract: false },
                        { id: 'special_care', name: '特别关心', order: 1, isDefault: false, canInteract: true },
                        { id: 'close_friends', name: '亲密朋友', order: 2, isDefault: false, canInteract: true },
                        { id: 'family', name: '家人', order: 3, isDefault: false, canInteract: true },
                        { id: 'classmates', name: '同学', order: 4, isDefault: false, canInteract: true },
                        { id: 'colleagues', name: '同事', order: 5, isDefault: false, canInteract: true }
                    ];
                    
                    await db.characterGroups.bulkAdd(defaultGroups);
                    characterGroups = defaultGroups;
                } else {
                    characterGroups = savedGroups;
                }
            } catch (error) {
                console.error('加载角色分组失败:', error);
                // 创建基本的默认分组
                characterGroups = [
                    { id: 'my_friends', name: '我的好友', order: 999, isDefault: true, canInteract: false }
                ];
            }
        }

        // 保存角色分组数据
        async function saveCharacterGroups() {
            try {
                await db.characterGroups.clear();
                await db.characterGroups.bulkAdd(characterGroups);
            } catch (error) {
                console.error('保存角色分组失败:', error);
            }
        }

        // 加载角色数据 - 使用IndexedDB（包含数据迁移）
        async function loadCharacters() {
            try {
                // 先检查IndexedDB中是否有数据
                const savedCharacters = await db.characters.toArray();
                
                if (savedCharacters.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('characters');
                    if (localStorageData) {
                        const localCharacters = JSON.parse(localStorageData);
                        
                        if (localCharacters.length > 0) {
                            // 为旧角色数据添加默认分组
                            localCharacters.forEach(character => {
                                if (!character.groupId) {
                                    character.groupId = 'my_friends'; // 默认分组
                                }
                            });
                            
                            // 迁移数据到IndexedDB
                            await db.characters.bulkAdd(localCharacters);
                            characters = localCharacters;
                            // 可选：清除localStorage中的旧数据
                            // localStorage.removeItem('characters');
                        } else {
                            characters = [];
                        }
                    } else {
                        characters = [];
                    }
                } else {
                    // 确保所有角色都有分组ID
                    savedCharacters.forEach(character => {
                        if (!character.groupId) {
                            character.groupId = 'my_friends';
                        }
                    });
                    characters = savedCharacters;
                }
            } catch (error) {
                console.error('加载角色数据失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('characters');
                if (localStorageData) {
                    characters = JSON.parse(localStorageData);
                    // 为角色添加默认分组
                    characters.forEach(character => {
                        if (!character.groupId) {
                            character.groupId = 'my_friends';
                        }
                    });

                } else {
                    characters = [];
                }
            }
        }
        
        // 保存角色数据 - 使用IndexedDB
        async function saveCharacters() {
            try {

                
                // 检查重复ID
                const uniqueIds = new Set();
                const uniqueCharacters = [];
                
                for (const character of characters) {
                    if (!character.id) {
                        console.warn('发现没有ID的角色，跳过保存:', character);
                        continue;
                    }
                    
                    if (!uniqueIds.has(character.id)) {
                        uniqueIds.add(character.id);
                        uniqueCharacters.push(character);
                    } else {
                        console.warn(`发现重复ID的角色 (${character.id})，跳过重复项:`, character);
                    }
                }
                
                // 清空现有数据
                await db.characters.clear();
                
                // 批量插入新数据 - 使用bulkPut而不是bulkAdd来避免键冲突
                if (uniqueCharacters.length > 0) {
                    await db.characters.bulkPut(uniqueCharacters);
                }
                

            } catch (error) {
                console.error('保存角色时发生错误:', error);
                alert('保存角色时发生错误: ' + error.message);
                throw error;
            }
        }
        
        // 显示存储使用情况
        function showStorageUsage() {
            const usage = [];
            
            // 计算各种数据的大小
            const characters = localStorage.getItem('characters') || '[]';
            const chatMessages = localStorage.getItem('chatMessages') || '{}';
            const customEmojis = localStorage.getItem('customEmojis') || '[]';
            
            usage.push(`角色数据: ${(characters.length / 1024).toFixed(1)} KB`);
            usage.push(`聊天记录: ${(chatMessages.length / 1024).toFixed(1)} KB`);
            usage.push(`表情包: ${(customEmojis.length / 1024).toFixed(1)} KB`);
            
            const total = characters.length + chatMessages.length + customEmojis.length;
            usage.push(`总计: ${(total / 1024).toFixed(1)} KB`);
            

            alert('存储使用情况:\n' + usage.join('\n'));
        }
        
        // 加载联系人数据 - 使用IndexedDB（包含数据迁移）
        async function loadContacts() {
            try {
                const savedContacts = await db.contacts.toArray();
        // 关键修复：过滤掉所有无效的联系人数据，确保列表干净
        contacts = savedContacts
            .map(contact => contact.characterId) // 提取ID
            .filter(id => id !== undefined && id !== null); // 只保留有效的ID

        // 自动清理重复的联系人ID，增强数据库稳定性
        const uniqueContacts = [...new Set(contacts)];
        if (uniqueContacts.length < contacts.length) {
            console.warn('发现了重复的联系人ID，已自动清理。');
            contacts = uniqueContacts;
            // 清理后，立即用干净的数据覆盖数据库
            await saveContacts();
        }


            } catch (error) {
                console.error('加载联系人失败:', error);
        contacts = []; // 如果出错，确保联系人列表为空，防止程序崩溃
            }
        }
        
        // 保存联系人数据 - 使用IndexedDB
        async function saveContacts() {
            try {
        // 过滤掉任何可能存在的无效ID
        const validContacts = contacts.filter(id => id); 
        // 将联系人ID列表转换为数据库需要的对象数组格式
        const contactArray = validContacts.map(id => ({ characterId: id }));

        await db.transaction('rw', db.contacts, async () => {
            // 先清空旧表，再批量写入新数据
                await db.contacts.clear();
                if (contactArray.length > 0) {
                    await db.contacts.bulkAdd(contactArray);
                }
        });
            } catch (error) {
                console.error('保存联系人失败:', error);
            }
        }
        
        // 加载聊天消息 - 使用IndexedDB（包含数据迁移）
        async function loadChatMessages() {
            try {
                const savedMessages = await db.chatMessages.toArray();
                chatMessages = {};
                
                if (savedMessages.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('chatMessages');
                    if (localStorageData) {

                        const localMessages = JSON.parse(localStorageData);
                        
                        // 将对象格式转换为数组格式存储到IndexedDB
                        const messageArray = [];
                        for (const [characterId, messages] of Object.entries(localMessages)) {
                            for (const message of messages) {
                                messageArray.push({
                                    id: `${characterId}_${message.id || message.timestamp}`,
                                    characterId: characterId,
                                    timestamp: message.timestamp,
                                    messageData: message
                                });
                            }
                        }
                        
                        if (messageArray.length > 0) {
                            await db.chatMessages.bulkAdd(messageArray);
                        }
                        
                        chatMessages = localMessages;

                    }
                } else {
                    // 将数组格式转换回对象格式
                    for (const msgRecord of savedMessages) {
                        const characterId = msgRecord.characterId;
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        // 🔥【新增】检查消息数据是否有效，过滤空值
                        if (msgRecord.messageData && typeof msgRecord.messageData === 'object') {
                        chatMessages[characterId].push(msgRecord.messageData);
                        }
                    }
                    
                    // 按时间戳排序并清理空值
                    for (const characterId in chatMessages) {
                        // 🔥【新增】过滤掉null、undefined或无效的消息
                        chatMessages[characterId] = chatMessages[characterId]
                            .filter(msg => msg && typeof msg === 'object' && msg.timestamp)
                            .sort((a, b) => a.timestamp - b.timestamp);
                    }
                    

                }
            } catch (error) {
                console.error('加载聊天消息失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('chatMessages');
                if (localStorageData) {
                    chatMessages = JSON.parse(localStorageData);
                } else {
                    chatMessages = {};
                }
            }
        }
        
        // 防抖保存计时器
        let saveMessagesTimer = null;
        let isSaving = false; // 防止并发保存
        
        // 防抖版本的保存函数
        function saveChatMessages() {
            // 清除之前的计时器
            if (saveMessagesTimer) {
                clearTimeout(saveMessagesTimer);
            }
            
            // 设置新的计时器，500ms后执行保存
            saveMessagesTimer = setTimeout(async () => {
                if (isSaving) {
                    return;
                }
                await saveChatMessagesImmediate();
            }, 500);
        }
        
        // 立即保存聊天消息 - 使用IndexedDB
        async function saveChatMessagesImmediate() {
            if (isSaving) {
                return;
            }
            
            isSaving = true;
            
            try {

                
                // 将chatMessages对象转换为数组格式存储
                const messageArray = [];
                let globalSequentialId = 0; // 全局顺序ID确保唯一性
                const usedIds = new Set(); // 用于检测ID重复
                
                for (const [characterId, messages] of Object.entries(chatMessages)) {
                    for (let i = 0; i < messages.length; i++) {
                        const message = messages[i];
                        
                        // 生成唯一的主键
                        let uniqueId = `${characterId}_${globalSequentialId++}`;
                        
                        // 确保ID绝对唯一
                        while (usedIds.has(uniqueId)) {
                            uniqueId = `${characterId}_${globalSequentialId++}`;
                        }
                        usedIds.add(uniqueId);
                        
                        messageArray.push({
                            id: uniqueId,
                            characterId: characterId,
                            timestamp: message.timestamp,
                            messageOrder: i,
                            originalMessageId: message.id, // 保留原始消息ID作为数据
                            messageData: message
                        });
                    }
                }
                
                // 清空现有消息
                await db.chatMessages.clear();
                
                // 批量插入新消息
                if (messageArray.length > 0) {
                    await db.chatMessages.bulkAdd(messageArray);
                }
                

            } catch (error) {
                console.error('保存聊天消息失败:', error);
                
                // 如果批量保存失败，使用简化的重试机制
                try {

                    await db.chatMessages.clear();
                    
                    // 只保存最近的1000条消息，避免过大的数据集
                    const messageArray = [];
                    let globalSequentialId = 0;
                    let totalMessages = 0;
                    
                    // 先计算总消息数
                    for (const messages of Object.values(chatMessages)) {
                        totalMessages += messages.length;
                    }
                    
                    const maxMessages = 1000;
                    const skipCount = Math.max(0, totalMessages - maxMessages);
                    let currentSkip = 0;
                    
                    for (const [characterId, messages] of Object.entries(chatMessages)) {
                        for (let i = 0; i < messages.length; i++) {
                            if (currentSkip < skipCount) {
                                currentSkip++;
                                continue;
                            }
                            
                            const message = messages[i];
                            messageArray.push({
                                id: `${characterId}_${globalSequentialId++}`,
                                characterId: characterId,
                                timestamp: message.timestamp,
                                messageOrder: i,
                                originalMessageId: message.id,
                                messageData: message
                            });
                        }
                    }
                    
                    if (messageArray.length > 0) {
                        await db.chatMessages.bulkAdd(messageArray);
                    }
                    

                } catch (fallbackError) {
                    console.error('简化保存也失败:', fallbackError);
                }
            } finally {
                isSaving = false;
            }
        }
        

        
        // 加载聊天设置 - 使用IndexedDB（包含数据迁移）
        async function loadChatSettings() {
            try {
                // 先从IndexedDB加载
                const savedChatSettings = await db.chatSettings.toArray();
                
                if (savedChatSettings.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('chatSettings');
                    if (localStorageData) {

                        const localSettings = JSON.parse(localStorageData);
                        
                        // 转换为数组格式存储到IndexedDB
                        const settingsArray = Object.keys(localSettings).map(chatId => ({
                            id: chatId,
                            chatId: chatId,
                            settings: localSettings[chatId]
                        }));
                        
                        if (settingsArray.length > 0) {
                            await db.chatSettings.bulkAdd(settingsArray);
                            console.log('聊天设置数据迁移完成:', settingsArray);
                        }
                        
                        chatSettings = localSettings;
                    } else {
                        chatSettings = {};
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    console.log('从IndexedDB加载聊天设置数据:', savedChatSettings);
                    chatSettings = {};
                    savedChatSettings.forEach(item => {
                        chatSettings[item.chatId] = item.settings;
                    });
                }
            } catch (error) {
                console.error('加载聊天设置失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('chatSettings');
                if (localStorageData) {
                    chatSettings = JSON.parse(localStorageData);
                    console.log('从localStorage备份加载聊天设置:', chatSettings);
                } else {
                    chatSettings = {};
                }
            }
        }
        
        // 保存聊天设置 - 使用IndexedDB避免localStorage容量限制
        async function saveChatSettings() {
            try {
                // 将chatSettings对象转换为数组格式存储到IndexedDB
                const chatSettingsArray = Object.keys(chatSettings).map(chatId => ({
                    id: chatId,
                    chatId: chatId,
                    settings: chatSettings[chatId]
                }));
                
                // 清空现有数据并存储新数据
                await db.chatSettings.clear();
                if (chatSettingsArray.length > 0) {
                    await db.chatSettings.bulkAdd(chatSettingsArray);
                }
                
                console.log('聊天设置已保存到IndexedDB');
            } catch (error) {
                console.error('保存聊天设置到IndexedDB失败，回退到localStorage:', error);
                
                // 如果IndexedDB失败，尝试压缩数据后存储到localStorage
                try {
                    // 创建一个精简版的设置，移除可能很大的图片数据
                    const compressedSettings = {};
                    Object.keys(chatSettings).forEach(chatId => {
                        compressedSettings[chatId] = { ...chatSettings[chatId] };
                        
                        // 不再自动移除头像，因为IndexedDB有足够的存储空间
                        // 如果真的需要压缩，用户可以手动选择
                        console.log(`聊天${chatId}设置大小:`, JSON.stringify(compressedSettings[chatId]).length);
                    });
                    
                    localStorage.setItem('chatSettings', JSON.stringify(compressedSettings));
                    console.log('已使用压缩版聊天设置保存到localStorage');
                } catch (localStorageError) {
                    console.error('localStorage也无法保存，存储空间可能已满:', localStorageError);
                    
                    // 显示用户友好的错误提示
                    alert('存储空间不足！\n\n可能的解决方案：\n1. 清理浏览器缓存\n2. 删除一些不必要的聊天记录\n3. 减少使用大尺寸的头像图片\n\n当前设置可能无法保存。');
                    throw localStorageError;
                }
            }
        }
        
        // === 后台互动系统 ===
        let backgroundTimers = {};

        // 初始化后台互动系统
        function initBackgroundInteractionSystem() {
            if (!currentChatCharacter) return;
            
            clearAllBackgroundTimers();
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.backgroundInteractionEnabled) return;
            
            const characterId = currentChatCharacter.id;
            
            // 设置主动聊天定时器
            if (chatSettings.backgroundChatEnabled) {
                const chatInterval = getBackgroundInterval(chatSettings.backgroundChatFrequency || 'low');
                backgroundTimers[characterId + '_chat'] = setInterval(() => {
                    triggerBackgroundChat(characterId);
                }, chatInterval);
                

            }
            
            // 设置主动发动态定时器
            if (chatSettings.backgroundMomentsEnabled) {
                const momentsInterval = getBackgroundMomentsInterval(chatSettings.backgroundMomentsFrequency || 'low');
                backgroundTimers[characterId + '_moments'] = setInterval(() => {
                    triggerBackgroundMoments(characterId);
                }, momentsInterval);
                
                // 移除了主动发动态日志
            }
        }

        // 清除所有后台定时器
        function clearAllBackgroundTimers() {
            Object.values(backgroundTimers).forEach(timer => {
                if (timer) clearInterval(timer);
            });
            backgroundTimers = {};
        }

        // 全局定时发布系统
        let globalMomentsTimers = {};
        let globalMomentsCheckInterval = null;

        // 初始化全局动态发布系统
        async function initGlobalMomentsSystem() {
            console.log('🚀 初始化全局动态发布系统');
            
            // 清除现有的定时器
            clearGlobalMomentsTimers();
            
            // 为所有角色设置后台发布定时器
            let activeCount = 0;
            if (characters && characters.length > 0) {
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);
                    
                    // 检查是否启用了后台发动态
                    if (chatSettings.backgroundMomentsEnabled) {
                        const frequency = chatSettings.backgroundMomentsFrequency || 'low';
                        const interval = getBackgroundMomentsInterval(frequency);
                        
                        globalMomentsTimers[character.id] = setInterval(async () => {
                            console.log(`⏰ 定时器触发：${character.name} 准备发布动态`);
                            await triggerBackgroundMoments(character.id);
                        }, interval);
                        
                        activeCount++;
                        console.log(`✅ 为角色 ${character.name} 设置了后台发动态定时器，间隔: ${Math.round(interval/1000/60)}分钟`);
                    }
                    
                    // 检查是否有定时发布时间点
                    if (chatSettings.scheduledMomentsEnabled && chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes.length > 0) {
                        console.log(`⏰ 角色 ${character.name} 启用了定时发布，时间点:`, chatSettings.scheduledMomentsTimes);
                    }
                }
            }
            
            // 启动定时检查器（每分钟检查一次是否到了发布时间）
            if (!globalMomentsCheckInterval) {
                globalMomentsCheckInterval = setInterval(async () => {
                    await checkScheduledMomentsTime();
                }, 60000); // 每分钟检查一次
                
                console.log('⏰ 启动了定时发布时间检查器');
            }
            
            console.log(`🎉 全局动态发布系统初始化完成，激活了 ${activeCount} 个角色的后台发布`);
        }

        // 检查定时发布时间
        async function checkScheduledMomentsTime() {
            const now = new Date();
            const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
            
            if (characters && characters.length > 0) {
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);
                    
                    if (chatSettings.scheduledMomentsEnabled && 
                        chatSettings.scheduledMomentsTimes && 
                        chatSettings.scheduledMomentsTimes.includes(currentTime)) {
                        
                        console.log(`⏰ 定时发布时间到：${character.name} 在 ${currentTime} 发布动态`);
                        await triggerBackgroundMoments(character.id, true); // 跳过冷却时间
                    }
                }
            }
        }

        // 清除全局动态定时器
        function clearGlobalMomentsTimers() {
            Object.values(globalMomentsTimers).forEach(timer => {
                if (timer) clearInterval(timer);
            });
            globalMomentsTimers = {};
            
            if (globalMomentsCheckInterval) {
                clearInterval(globalMomentsCheckInterval);
                globalMomentsCheckInterval = null;
            }
        }

        // 获取后台聊天间隔时间
        function getBackgroundInterval(frequency) {
            switch (frequency) {
                case 'low':
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000; // 1-2小时
                case 'medium':
                    return Math.random() * 30 * 60 * 1000 + 30 * 60 * 1000; // 30-60分钟
                case 'high':
                    return Math.random() * 20 * 60 * 1000 + 10 * 60 * 1000; // 10-30分钟
                default:
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000; // 默认1-2小时
            }
        }

        // 获取后台动态间隔时间
        function getBackgroundMomentsInterval(frequency) {
            switch (frequency) {
                case 'low':
                    return Math.random() * 4 * 60 * 60 * 1000 + 4 * 60 * 60 * 1000; // 4-8小时
                case 'medium':
                    return Math.random() * 2 * 60 * 60 * 1000 + 2 * 60 * 60 * 1000; // 2-4小时
                case 'high':
                    return Math.random() * 60 * 60 * 1000 + 60 * 60 * 1000; // 1-2小时
                default:
                    return Math.random() * 4 * 60 * 60 * 1000 + 4 * 60 * 60 * 1000; // 默认4-8小时
            }
        }

        // 触发后台聊天
        async function triggerBackgroundChat(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // 检查用户是否至少10分钟没有回复
                const messages = chatMessages[characterId] || [];
                const lastUserMessage = messages.slice().reverse().find(msg => msg.sender === 'user');
                
                if (lastUserMessage) {
                    const timeSinceLastUserMessage = Date.now() - lastUserMessage.timestamp;
                    const tenMinutes = 10 * 60 * 1000; // 10分钟
                    if (timeSinceLastUserMessage < tenMinutes) {
                        console.log(`${character.name} 跳过主动聊天：用户最近${Math.round(timeSinceLastUserMessage / 60000)}分钟前有回复`);
                        return; // 用户最近有活动，不发送自动消息
                    }
                }
                
                const chatSettings = await getChatSettings(characterId);
                
                // 获取最近的聊天历史
                const maxMemory = chatSettings.historyCount || 5;
                const recentMessages = messages.slice(-maxMemory);
                
                // 获取最近的动态内容
                const recentMoments = await getRecentMoments(5);
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\n最近的动态内容：\n' + 
                        recentMoments.map(moment => `${moment.nickname}: ${moment.text}`).join('\n');
                }
                
                // 构建聊天历史上下文
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\n最近的聊天记录：\n' + 
                        recentMessages.map(msg => {
                            if (msg.sender === 'user') return `用户：${msg.content}`;
                            if (msg.sender === 'ai') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }
                async function getWorldbookContextForCharacter(characterId) {
            try {
                // 获取与角色相关的世界书内容
                const worldbookContent = await getRelevantWorldbookContent(characterId);
                
                if (worldbookContent && worldbookContent.trim()) {
                    return `\n## 世界设定与背景信息\n${worldbookContent}\n`;
                }
                
                return '';
            } catch (error) {
                console.error('获取世界书上下文失败:', error);
                return '';
            }
        }
        async function getCrossWindowMemoryForCharacter(characterId, count = 3) {
            try {
                // 这里可以根据实际的跨窗口记忆系统来实现
                // 暂时返回空字符串，等待实际的记忆系统实现
                return '';
            } catch (error) {
                console.error('获取跨窗口记忆失败:', error);
                return '';
            }
        }
        async function getRelevantWorldbookContent(characterId) {
            try {
                // 这里需要根据实际的世界书系统来获取内容
                // 可以根据角色ID或标签匹配相关的世界书条目
                // 暂时返回空字符串
                return '';
            } catch (error) {
                console.error('获取相关世界书内容失败:', error);
                return '';
            }
        }
                const worldbookContext = await getWorldbookContextForCharacter(characterId);
                const crossWindowMemory = await getCrossWindowMemoryForCharacter(characterId, chatSettings.crossWindowMemoryCount || 3);
                // 生成主动聊天内容
                const prompt = `你是${character.name}，你的人设如下：${character.bio}。
${worldbookContext}
现在你要主动给用户发送一条消息。这条消息应该是：
1. 符合你的人设和性格
2. 自然、有趣、有互动性
3. 可以是问候、分享、询问等
4. 不要过于正式，要像朋友间的日常聊天
5. 如果有聊天历史，要基于历史内容进行自然的延续或回应
6. 可以适当提及最近的动态内容，让对话更自然${chatContext}${momentsContext}${crossWindowMemory}

请生成一条主动聊天的消息：`;

                const content = await generateAIResponse(prompt, character);
                if (content && content.trim()) {
                    // 添加到聊天记录
                    const message = {
                        id: Date.now().toString(),
                        sender: 'ai',
                        content: content.trim(),
                        timestamp: Date.now()
                    };
                    
                    if (!chatMessages[characterId]) {
                        chatMessages[characterId] = [];
                    }
                    
                    chatMessages[characterId].push(message);
                    saveChatMessages();
                    
                    // 如果当前正在和这个角色聊天，立即显示消息
                    if (currentChatCharacter && currentChatCharacter.id === characterId) {
                        renderChatMessages(characterId);
                    }
                    
                    // 更新消息列表
                    renderMessageList();
                    
                    // 移除了主动发送消息日志
                }
            } catch (error) {
                console.error('后台聊天失败:', error);
            }
        }

        // 触发后台发动态（测试版本，跳过冷却时间）
        async function triggerBackgroundMomentsTest(characterId) {
            // 移除了测试发布日志
            // 直接调用正常发布函数，但跳过冷却时间检查
            await triggerBackgroundMoments(characterId, true);
        }

        // 触发后台发动态
        async function triggerBackgroundMoments(characterId, skipCooldown = false) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // 检查冷却时间（避免短时间内重复发布）
                if (!skipCooldown) {
                    const lastMomentTime = character.lastMomentTime || 0;
                    const cooldownTime = 30 * 60 * 1000; // 30分钟冷却时间
                    if (Date.now() - lastMomentTime < cooldownTime) {
                        // 移除了冷却时间日志
                        return;
                    }
                } else {
                    // 移除了测试发布日志
                }
                
                // 🔥【修复】获取当前角色的设置而不是全局当前角色设置  
                const chatSettings = await getChatSettings(characterId);
                
                // 获取最近的聊天记录
                const messages = chatMessages[characterId] || [];
                const maxMemory = chatSettings.historyCount || 5;
                const recentMessages = messages.slice(-maxMemory);
                
                // 获取最近的动态内容
                const recentMoments = await getRecentMoments(5);
                
                // 构建上下文
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '\n\n最近的聊天记录：\n' + 
                        recentMessages.map(msg => {
                            if (msg.sender === 'user') return `用户：${msg.content}`;
                            if (msg.sender === 'ai') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n');
                }
                
                let momentsContext = '';
                if (recentMoments.length > 0) {
                    momentsContext = '\n\n最近的动态内容：\n' + 
                        recentMoments.map(moment => `${moment.nickname}: ${moment.text}`).join('\n');
                }
                
                // 生成动态内容
                const prompt = `你是${character.name}，你的人设如下：${character.bio}。

现在你要发布一条动态。这条动态应该是：
1. 符合你的人设和性格
2. 生活化、有趣、有个性
3. 50-200字左右
4. 可以是心情、感悟、日常、分享等
5. 可以结合最近的聊天或动态内容作为灵感
6. 要有你独特的风格，不能和其他角色混淆
7. 支持换行显示，可以适当分段让内容更易读
8. 可以选择性地配图，如果想要配图，请直接换行，然后用斜体格式写：*[配图：详细的图片描述]*

## 配图规则（遵循）：
- 不需要每条动态都配图，只有当内容真的适合配图时才添加配图描述
- 图片描述要生动、具体，让人能通过文字想象出画面
- 以第三人称视角描述，例如：*[配图：照片里一只橘猫正懒洋洋地趴在窗台上晒太阳，阳光把它金色的毛照得发亮，背景是蔚蓝的天空和几朵白云。]*
- 图片描述要符合你的性格和当前情境

${chatContext}${momentsContext}

请生成一条符合你人设的动态内容：`;

                const response = await generateAIResponse(prompt, character);
                if (response && response.trim()) {
                    // 🔥【修复】使用parseAiResponse解析AI回复的JSON格式
                    const parsedMessages = parseAiResponse(response);
                    let content = '';
                    
                    if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
                        // 如果有多条消息，合并为一条动态
                        content = parsedMessages.map(msg => {
                            if (typeof msg === 'string') {
                                return msg.trim();
                            } else if (typeof msg === 'object' && msg.content) {
                                return msg.content.trim();
                            }
                            return '';
                        }).filter(text => text).join('\n\n');
                    } else if (typeof response === 'string') {
                        // 备用：如果解析失败，使用原始文本
                        content = response.trim();
                    }
                    
                    if (content) {
                        // 获取头像，确保安全
                        const avatar = getCharacterAvatar(character);
                        // 移除了发布动态头像日志
                        
                        // 发布动态
                        const moment = {
                            id: Date.now(),  // 使用数字ID而不是字符串
                            authorId: characterId,
                            nickname: character.name,
                            avatar: avatar, // 角色头像
                            text: content,
                            time: formatTime(new Date()),
                            timestamp: Date.now(),
                            characterId: characterId
                        };
                    
                                                                    // 保存到数据库
                        await db.moments.add(moment);
                        
                        // 🔥【新增】为角色发布动态创建推送通知
                        createPushNotification(character, `发布了新动态：${content.length > 15 ? content.substring(0, 15) + '...' : content}`, 500);
                        
                        // 记录发布时间
                        character.lastMomentTime = Date.now();
                        saveCharacters();
                        
                        // 强制刷新动态显示（无论当前在哪个页面）
                        setTimeout(() => {
                            loadMoments();
                        }, 100);
                        
                        // 触发同分组角色的自发互动（保持概率设置）
                        setTimeout(() => {
                            triggerAIInteractions(moment.id, 'like');
                        }, 2000 + Math.random() * 3000); // 2-5秒后开始点赞
                        
                        setTimeout(() => {
                            triggerAIInteractions(moment.id, 'comment');
                        }, 5000 + Math.random() * 5000); // 5-10秒后开始评论
                        
                        // 移除了发布动态日志
                    }
                }
            } catch (error) {
                console.error('后台发动态失败:', error);
            }
        }

        // 获取最近的动态
        async function getRecentMoments(count = 5) {
            try {
                // 从数据库获取最新的动态数据
                const momentsData = await db.moments.orderBy('timestamp').reverse().limit(count).toArray();
                return momentsData || [];
            } catch (error) {
                console.error('获取最近动态失败:', error);
                return [];
            }
        }

        // 🔥【新增】获取角色可见的动态（用于聊天记忆集成）
        async function getVisibleMomentsForCharacter(characterId, count = 5) {
            try {
                // 获取所有最新动态
                const allMoments = await db.moments.orderBy('timestamp').reverse().limit(count * 2).toArray();
                
                // 筛选角色可见的动态：
                // 1. 用户发的动态（所有角色都能看到）
                // 2. 角色自己发的动态
                // 3. 同一个好友分组的其他角色发的动态
                
                const visibleMoments = [];
                const character = characters.find(c => c.id === characterId);
                
                for (const moment of allMoments) {
                    if (visibleMoments.length >= count) break;
                    
                    // 用户发的动态，所有角色都能看到
                    if (moment.authorId === 'user') {
                        visibleMoments.push(moment);
                        continue;
                    }
                    
                    // 角色自己发的动态
                    if (moment.authorId === characterId) {
                        visibleMoments.push(moment);
                        continue;
                    }
                    
                    // 检查是否是同一个好友分组的角色发的动态
                    if (character && moment.characterId) {
                        const momentAuthor = characters.find(c => c.id === moment.characterId);
                        if (momentAuthor && areCharactersInSameGroup(character, momentAuthor)) {
                            visibleMoments.push(moment);
                            continue;
                        }
                    }
                }
                
                return visibleMoments;
            } catch (error) {
                console.error('获取角色可见动态失败:', error);
                return [];
            }
        }

        // 🔥【新增】检查两个角色是否在同一个好友分组
        function areCharactersInSameGroup(char1, char2) {
            // 如果没有分组系统，默认所有角色都在同一组（都是好友）
            // 这里可以根据实际的分组逻辑进行调整
            return contacts.includes(char1.id) && contacts.includes(char2.id);
        }

        // 生成AI响应的包装函数，用于后台互动
        async function generateAIResponse(prompt, character) {
            try {
                // 使用现有的 callChatAPI 函数
                const response = await callChatAPI(prompt, character);
                return response;
            } catch (error) {
                console.error('AI响应生成失败:', error);
                return null;
            }
        }

        // 验证头像URL是否有效
        function isValidAvatarUrl(url) {
            if (!url || typeof url !== 'string') return false;
            
            // 检查base64格式
            if (url.startsWith('data:image/')) {
                // 更宽松的base64验证，只检查基本结构
                const parts = url.split(',');
                if (parts.length !== 2) {
                    console.warn('base64头像URL格式错误（缺少逗号分隔）:', url.substring(0, 50) + '...');
                    return false;
                }
                
                const header = parts[0];
                const data = parts[1];
                
                // 检查header是否包含必要信息
                if (!header.includes('data:image/') || !header.includes('base64')) {
                    console.warn('base64头像URL头部格式错误:', header);
                    return false;
                }
                
                // 检查base64数据是否为空或过长
                if (!data || data.length < 50) {
                    console.warn('base64头像数据为空或过短:', data.length);
                    return false;
                }
                
                if (data.length > 2000000) { // 2MB限制，更宽松
                    console.warn('base64头像数据过大:', data.length, '建议压缩后重新上传以提高性能');
                    // 不再直接拒绝，只是警告
                }
                
                // 简单检查base64字符是否合法
                const base64Chars = /^[A-Za-z0-9+/]*={0,2}$/;
                if (!base64Chars.test(data)) {
                    console.warn('base64头像数据包含非法字符');
                    return false;
                }
                
                return true;
            }
            
            // 检查HTTP(S) URL格式
            if (url.startsWith('http://') || url.startsWith('https://')) {
                try {
                    new URL(url);
                    return true;
                } catch (error) {
                    console.warn('无效的HTTP头像URL:', url);
                    return false;
                }
            }
            
            // 如果不是data:image或http(s)开头，考虑可能是其他有效格式
            console.warn('未知的头像URL格式:', url.substring(0, 50) + '...');
            return false;
        }

        // 获取角色的头像（用于动态发布）
        function getCharacterAvatar(character) {
            // 使用同步版本的设置获取，避免Promise问题
            const chatSettings = getChatSettingsSync(character.id);
            
            // 优先级1：如果角色有聊天窗口的动态头像设置，使用那个
            if (chatSettings.aiDynamicAvatar && chatSettings.aiDynamicAvatar.trim()) {
                const avatar = chatSettings.aiDynamicAvatar;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`角色${character.name}的动态头像无效，尝试使用其他头像`);
                }
            }
            
            // 优先级2：如果角色有聊天窗口的头像设置，使用那个
            if (chatSettings.aiChatAvatar && chatSettings.aiChatAvatar.trim()) {
                const avatar = chatSettings.aiChatAvatar;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`角色${character.name}的聊天头像无效，尝试使用角色卡头像`);
                }
            }
            
            // 优先级3：使用角色卡里的头像
            if (character.avatarUrl && character.avatarUrl.trim()) {
                const avatar = character.avatarUrl;
                if (isValidAvatarUrl(avatar)) {
                    return avatar;
                } else {
                    console.warn(`角色${character.name}的角色卡头像无效，大小或格式问题`);
                }
            }
            
            console.log(`角色${character.name}没有可用的头像`);
            return null;
        }

        // 获取指定角色的聊天设置 - 使用IndexedDB
        async function getChatSettings(characterId) {
            try {
                const chatSettingsRecord = await db.chatSettings.get(characterId);
                if (chatSettingsRecord) {
                    return chatSettingsRecord.settings;
                }
                
                // 如果IndexedDB中没有，尝试从localStorage迁移
                const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
                if (savedSettings) {
                    console.log(`迁移角色 ${characterId} 的聊天设置到IndexedDB`);
                    const settings = JSON.parse(savedSettings);
                    
                    // 保存到IndexedDB
                    await db.chatSettings.put({
                        id: characterId,
                        chatId: characterId,
                        settings: settings
                    });
                    
                    return settings;
                }
                
                return {};
            } catch (error) {
                console.error('获取聊天设置失败:', error);
                // 回退到localStorage
                const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
                return savedSettings ? JSON.parse(savedSettings) : {};
            }
        }
        
        // 同步版本的getChatSettings（用于不支持async的地方）
        function getChatSettingsSync(characterId) {
            const savedSettings = localStorage.getItem(`chatSettings_${characterId}`);
            return savedSettings ? JSON.parse(savedSettings) : {};
        }

        // 格式化动态文字，支持分行和配图描述
        function formatMomentText(text) {
            if (!text) return '';
            
            // 替换换行符为<br>标签，支持分行显示
            let formattedText = text.replace(/\n/g, '<br>');
            
            // 处理配图描述：匹配*[配图：描述]*格式
            formattedText = formattedText.replace(/\*\[配图：([^\]]+)\]\*/g, function(match, description) {
                return `<span style="font-style: italic; color: #999; font-size: 13px; line-height: 1.4;">[配图：${description}]</span>`;
            });
            
            return formattedText;
        }

        // 调试角色动态头像
        function debugMomentAvatar(momentId) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) {
                console.log('找不到动态元素');
                return;
            }
            
            // 从IndexedDB获取动态数据
            db.moments.get(parseInt(momentId)).then(moment => {
                console.log('=== 动态头像调试 ===');
                console.log('动态ID:', momentId);
                console.log('角色ID:', moment.characterId);
                console.log('保存的头像:', moment.avatar ? moment.avatar.substring(0, 50) + '...' : 'null');
                
                if (moment.characterId && moment.characterId !== 'user') {
                    const character = characters.find(c => c.id === moment.characterId);
                    if (character) {
                        console.log('找到角色:', character.name);
                        console.log('角色卡头像:', character.avatarUrl ? character.avatarUrl.substring(0, 50) + '...' : 'null');
                    } else {
                        console.log('找不到角色数据');
                    }
                }
                
                const avatarImg = momentElement.querySelector('.moment-avatar img');
                if (avatarImg) {
                    console.log('当前显示的头像URL:', avatarImg.src ? avatarImg.src.substring(0, 50) + '...' : 'null');
                }
            });
        }
        
        // 简单的头像数据修复
        async function fixAvatarData() {
            console.log('开始修复头像数据...');
            let fixedCount = 0;
            
            try {
                // 清理角色设置中的截断头像
                for (const character of characters) {
                    const chatSettings = await getChatSettings(character.id);
                    let needSave = false;
                    
                    if (chatSettings.aiDynamicAvatar) {
                        const avatar = chatSettings.aiDynamicAvatar;
                        if (avatar.startsWith('data:image/') && !avatar.includes('=') && avatar.split(',').length === 2) {
                            console.log(`清理${character.name}的动态头像设置`);
                            delete chatSettings.aiDynamicAvatar;
                            needSave = true;
                            fixedCount++;
                        }
                    }
                    
                    if (chatSettings.aiChatAvatar) {
                        const avatar = chatSettings.aiChatAvatar;
                        if (avatar.startsWith('data:image/') && !avatar.includes('=') && avatar.split(',').length === 2) {
                            console.log(`清理${character.name}的聊天头像设置`);
                            delete chatSettings.aiChatAvatar;
                            needSave = true;
                            fixedCount++;
                        }
                    }
                    
                    if (needSave) {
                        // 保存到IndexedDB而不是localStorage
                        await db.chatSettings.put({
                            id: character.id,
                            chatId: character.id,
                            settings: chatSettings
                        });
                    }
                }
                
                // 清理动态数据库中的截断头像
                const allMoments = await db.moments.toArray();
                let momentFixedCount = 0;
                
                for (const moment of allMoments) {
                    if (moment.avatar && moment.avatar.startsWith('data:image/')) {
                        // 检查是否是截断的头像（以VNEKhsVJik结尾的是截断的）
                        if (moment.avatar.endsWith('VNEKhsVJik') || moment.avatar.endsWith('VNEKhsVJik:1') || 
                            (!moment.avatar.includes('=') && moment.avatar.split(',').length === 2)) {
                            console.log(`清理动态 ${moment.id} 的截断头像`);
                            await db.moments.update(moment.id, { avatar: null });
                            momentFixedCount++;
                        }
                    }
                }
                
                const totalFixed = fixedCount + momentFixedCount;
                console.log(`修复完成: 清理了${fixedCount}个设置头像, ${momentFixedCount}个动态头像`);
                
                alert(`修复完成！\n清理了 ${fixedCount} 个设置中的截断头像\n清理了 ${momentFixedCount} 个动态中的截断头像\n\n请重新为角色设置头像`);
                
                if (totalFixed > 0) {
                    loadMoments();
                }
            } catch (error) {
                console.error('修复失败:', error);
                alert('修复失败: ' + error.message);
            }
        }

        // 页面卸载时清理后台定时器
        window.addEventListener('beforeunload', function() {
            clearAllBackgroundTimers();
            clearGlobalMomentsTimers();
        });
        
        // 🔥【调试功能】测试动态系统是否正常工作
        function debugMomentsSystem() {
            console.log('=== 动态系统调试信息 ===');
            console.log('角色数量:', characters ? characters.length : 0);
            console.log('全局定时器:', Object.keys(globalMomentsTimers));
            console.log('定时检查器状态:', globalMomentsCheckInterval ? '运行中' : '未运行');
            
            if (characters && characters.length > 0) {
                console.log('各角色设置:');
                characters.forEach(async (character, index) => {
                    const settings = await getChatSettings(character.id);
                    console.log(`${index + 1}. ${character.name}:`, {
                        backgroundMomentsEnabled: settings.backgroundMomentsEnabled,
                        backgroundMomentsFrequency: settings.backgroundMomentsFrequency,
                        scheduledMomentsEnabled: settings.scheduledMomentsEnabled,
                        scheduledMomentsTimes: settings.scheduledMomentsTimes
                    });
                });
            }
            
            console.log('=========================');
        }
        
        // 暴露调试函数到全局
        window.debugMomentsSystem = debugMomentsSystem;


        // 加载壁纸 - 使用IndexedDB（包含数据迁移）
        async function loadWallpaper() {
            try {
                // 先从IndexedDB加载
                const savedWallpaper = await db.wallpapers.get('main');
            
            if (savedWallpaper) {
                    selectedWallpaper = savedWallpaper.data;
                
                    if (savedWallpaper.type === 'image' && savedWallpaper.data.startsWith('data:image')) {
                    // 加载上传的图片
                        document.querySelector('.wallpaper').style.backgroundImage = `url(${savedWallpaper.data})`;
                    } else if (savedWallpaper.type === 'gradient' || savedWallpaper.data.startsWith('linear-gradient')) {
                    // 加载渐变背景
                        document.querySelector('.wallpaper').style.backgroundImage = savedWallpaper.data;
                } else {
                    // 加载纯色背景
                        document.querySelector('.wallpaper').style.backgroundColor = savedWallpaper.data;
                    document.querySelector('.wallpaper').style.backgroundImage = 'none';
                }
                
                document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                } else {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localWallpaper = localStorage.getItem('wallpaper');
                    const wallpaperType = localStorage.getItem('wallpaperType');
                    
                    if (localWallpaper) {
                        console.log('检测到localStorage中的壁纸数据，开始迁移...');
                        selectedWallpaper = localWallpaper;
                        
                        // 迁移到IndexedDB
                        await db.wallpapers.add({
                            id: 'main',
                            type: wallpaperType || 'gradient',
                            data: localWallpaper
                        });
                        
                        if (wallpaperType === 'image' && localWallpaper.startsWith('data:image')) {
                            document.querySelector('.wallpaper').style.backgroundImage = `url(${localWallpaper})`;
                        } else if (wallpaperType === 'gradient' || localWallpaper.startsWith('linear-gradient')) {
                            document.querySelector('.wallpaper').style.backgroundImage = localWallpaper;
                        } else {
                            document.querySelector('.wallpaper').style.backgroundColor = localWallpaper;
                            document.querySelector('.wallpaper').style.backgroundImage = 'none';
                        }
                        
                        document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                        document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                        
                        console.log('壁纸数据迁移完成');
                    }
                }
            } catch (error) {
                console.error('加载壁纸失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localWallpaper = localStorage.getItem('wallpaper');
                const wallpaperType = localStorage.getItem('wallpaperType');
                
                if (localWallpaper) {
                    selectedWallpaper = localWallpaper;
                    
                    if (wallpaperType === 'image' && localWallpaper.startsWith('data:image')) {
                        document.querySelector('.wallpaper').style.backgroundImage = `url(${localWallpaper})`;
                    } else if (wallpaperType === 'gradient' || localWallpaper.startsWith('linear-gradient')) {
                        document.querySelector('.wallpaper').style.backgroundImage = localWallpaper;
                    } else {
                        document.querySelector('.wallpaper').style.backgroundColor = localWallpaper;
                        document.querySelector('.wallpaper').style.backgroundImage = 'none';
                    }
                    
                    document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                    document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                }
            }
        }
        
        // 加载应用图标 - 使用IndexedDB（包含数据迁移）
        async function loadAppIcons() {
            try {
                // 先从IndexedDB加载
                const savedIcons = await db.appIcons.toArray();
                
                if (savedIcons.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('appIcons');
                    if (localStorageData) {
                        console.log('检测到localStorage中的应用图标数据，开始迁移...');
                        const localIcons = JSON.parse(localStorageData);
                        
                        // 转换为数组格式存储到IndexedDB
                        const iconArray = Object.keys(localIcons).map(appId => ({
                            id: appId,
                            appId: appId,
                            iconClass: localIcons[appId]
                        }));
                        
                        if (iconArray.length > 0) {
                            await db.appIcons.bulkAdd(iconArray);
                            console.log('应用图标数据迁移完成:', iconArray);
                        }
                        
                        // 应用图标
                        Object.keys(localIcons).forEach(appId => {
                            const iconElement = document.querySelector(`.app[onclick="showApp('${appId}')"] .app-icon i`);
                            if (iconElement) {
                                iconElement.className = localIcons[appId];
                            }
                        });
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    console.log('从IndexedDB加载应用图标数据:', savedIcons);
                    savedIcons.forEach(iconData => {
                        const iconElement = document.querySelector(`.app[onclick="showApp('${iconData.appId}')"] .app-icon i`);
                        if (iconElement) {
                            iconElement.className = iconData.iconClass;
                        }
                    });
                }
            } catch (error) {
                console.error('加载应用图标失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('appIcons');
                if (localStorageData) {
                    const icons = JSON.parse(localStorageData);
                Object.keys(icons).forEach(appId => {
                    const iconElement = document.querySelector(`.app[onclick="showApp('${appId}')"] .app-icon i`);
                    if (iconElement) {
                        iconElement.className = icons[appId];
                    }
                });
                }
            }
        }
        
        // 加载API设置 - 使用IndexedDB
        async function loadApiSettings() {
            try {
                // 先从IndexedDB尝试加载
                const savedSettings = await db.apiSettings.get('main');
            if (savedSettings) {
                    apiSettings = savedSettings.settings;
                } else {
                    // 尝试从localStorage迁移
                    const localSettings = localStorage.getItem('apiSettings');
                    if (localSettings) {
                        console.log('迁移API设置到IndexedDB');
                        apiSettings = JSON.parse(localSettings);
                        
                        // 保存到IndexedDB
                        await db.apiSettings.put({
                            id: 'main',
                            settings: apiSettings
                        });
                    } else {
                        // 使用默认设置
                        apiSettings = {
                            type: 'gemini',
                            base: 'https://generativelanguage.googleapis.com/v1beta',
                            endpoint: '/chat/completions',
                            key: '',
                            model: 'gemini-2.0-flash-exp',
                            temperature: 0.70
                        };
                    }
                }
                
                // 旧版本API设置表单更新代码已清理 - 现在使用新版本的API设置系统
            } catch (error) {
                console.error('加载API设置失败:', error);
                // 旧版本默认设置代码已清理
            }
        }
        
        // 保存应用图标 - 使用IndexedDB
        async function saveAppIcons() {
            try {
                console.log('保存应用图标数据到IndexedDB...');
                
                const defaultIcons = {
                    'chat-screen': 'fas fa-comment-dots',
                    'forum-screen': 'fas fa-comments',
                    'music-screen': 'fas fa-music',
                    'game-screen': 'fas fa-gamepad',
                    'characters-screen': 'fas fa-user-friends',
                    'shop-screen': 'fas fa-shopping-bag',
                    'settings-screen': 'fas fa-cog'
                };
                
                if (selectedAppIcon) {
                    defaultIcons[selectedAppIcon.appId] = selectedAppIcon.iconClass;
                }
                
                // 转换为数组格式
                const iconArray = Object.keys(defaultIcons).map(appId => ({
                    id: appId,
                    appId: appId,
                    iconClass: defaultIcons[appId]
                }));
                
                // 清空现有数据并插入新数据
                await db.appIcons.clear();
                await db.appIcons.bulkAdd(iconArray);
                
                console.log('应用图标数据保存成功');
                
                // 刷新图标显示
                await loadAppIcons();
            } catch (error) {
                console.error('保存应用图标时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            const icons = {
                'chat-screen': 'fas fa-comment-dots',
                'weibo-screen': 'fab fa-weibo',
                'music-screen': 'fas fa-music',
                'album-screen': 'fas fa-images',
                'characters-screen': 'fas fa-user-friends',
                'shop-screen': 'fas fa-shopping-bag',
                'settings-screen': 'fas fa-cog'
            };
            
            if (selectedAppIcon) {
                icons[selectedAppIcon.appId] = selectedAppIcon.iconClass;
            }
            
            localStorage.setItem('appIcons', JSON.stringify(icons));
            loadAppIcons();
            }
        }
        
        // 渲染消息列表
        function renderMessageList() {
            const messageList = document.getElementById('message-list');
            messageList.innerHTML = '';
            
            // 添加多选模式的头部
            if (isMessageListMultiSelectMode) {
                const headerDiv = document.createElement('div');
                headerDiv.className = 'multiselect-header';
                headerDiv.innerHTML = `
                    <span>已选择 ${selectedConversations.length} 个对话</span>
                    <div>
                        <button onclick="deleteSelectedConversations()" class="delete-btn-red">删除</button>
                        <button onclick="exitMessageListMultiSelectMode()" class="cancel-btn-blue">取消</button>
                    </div>
                `;
                messageList.appendChild(headerDiv);
            }
            
            // 渲染单人聊天
            contacts.forEach(contactId => {
                const character = characters.find(c => c.id === contactId);
                if (character) {
                    // 🔥【修复】获取该聊天的昵称设置
                    const savedSettings = localStorage.getItem(`chatSettings_${character.id}`);
                    const chatSettings = savedSettings ? JSON.parse(savedSettings) : {};
                    const displayName = chatSettings.aiChatNickname || character.name;
                    
                    const messages = chatMessages[character.id] || [];
                let lastMessageRaw = '暂无消息';
                
                if (messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];
                    
                    // 🔥【修复】检查消息是否有效，防止undefined错误
                    if (!lastMsg) {
                        lastMessageRaw = '暂无消息';
                    } else if (lastMsg.type === 'user_photo') {
                        lastMessageRaw = '[照片]';
                    } else if (lastMsg.type === 'ai_image') {
                        lastMessageRaw = '[图片]';
                    } else if (lastMsg.type === 'voice_message') {
                        lastMessageRaw = '[语音]';
                    } else if (lastMsg.type === 'transfer') {
                        lastMessageRaw = '[转账]';
                    } else if (lastMsg.type === 'recalled_message') {
                        lastMessageRaw = '[撤回了一条消息]';
                    } else if (lastMsg.type === 'location') {
                        lastMessageRaw = '[位置]';
                    } else if (lastMsg.type === 'call_message') {
                        lastMessageRaw = '[通话消息]';
                    } else if (lastMsg.sender === 'system') {
                        lastMessageRaw = lastMsg.content || '[系统消息]';
                    } else if (lastMsg.isEmoji) {
                        lastMessageRaw = '[表情]';
                    } else {
                        lastMessageRaw = lastMsg.content || '';
                    }
                }
                
                const lastMessage = truncateText(String(lastMessageRaw || '暂无消息'), 30);
                    const lastTime = messages.length > 0 ? formatTime(messages[messages.length - 1].timestamp) : '刚刚';
                    
                    const messageItem = document.createElement('div');
                    messageItem.className = `message-item ${isMessageListMultiSelectMode && selectedConversations.includes(character.id) ? 'selected' : ''}`;
                    messageItem.dataset.conversationId = character.id; // 添加对话ID
                    
                    // 根据模式设置不同的点击事件
                    if (isMessageListMultiSelectMode) {
                        messageItem.onclick = () => toggleConversationSelection(character.id);
                    } else {
                        // 使用变量来控制点击行为
                        let isLongPress = false;
                        
                        messageItem.onclick = (e) => {
                            if (!isLongPress) {
                                startChat(character);
                            }
                            isLongPress = false; // 重置标志
                        };
                        
                        // 添加长按事件（支持移动端和桌面端）
                        let pressTimer;
                        
                        // 移动端触摸事件
                        messageItem.addEventListener('touchstart', (e) => {
                            e.stopPropagation(); // 阻止事件冒泡
                            pressTimer = setTimeout(() => {
                                console.log('触摸长按触发，角色ID:', character.id);
                                isLongPress = true; // 设置长按标志
                                enterMessageListMultiSelectMode(character.id);
                                e.preventDefault();
                            }, 800); // 800ms长按
                        });
                        
                        messageItem.addEventListener('touchend', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        messageItem.addEventListener('touchmove', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        // 桌面端鼠标事件
                        messageItem.addEventListener('mousedown', (e) => {
                            if (e.button === 0) { // 左键
                                e.stopPropagation(); // 阻止事件冒泡
                                pressTimer = setTimeout(() => {
                                    console.log('鼠标长按触发，角色ID:', character.id);
                                    isLongPress = true; // 设置长按标志
                                    enterMessageListMultiSelectMode(character.id);
                                    e.preventDefault();
                                }, 800); // 800ms长按
                            }
                        });
                        
                        messageItem.addEventListener('mouseup', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        messageItem.addEventListener('mouseleave', (e) => {
                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }
                        });
                        
                        // 右键点击进入多选模式（桌面端）
                        messageItem.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            enterMessageListMultiSelectMode(character.id);
                        });
                    }
                    
                    messageItem.innerHTML = `
                        ${isMessageListMultiSelectMode ? `
                            <div class="selection-checkbox ${selectedConversations.includes(character.id) ? 'selected' : ''}">
                                ${selectedConversations.includes(character.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                            </div>
                        ` : ''}
                        <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : displayName.charAt(0)}
                        </div>
                        <div class="message-content">
                            <div class="message-name">${displayName}</div>
                            <div class="message-preview">${lastMessage}</div>
                        </div>
                        <div class="message-time">${lastTime}</div>
                    `;
                    
                    messageList.appendChild(messageItem);
                }
            });
            
            // 渲染群聊
            groupChats.forEach(group => {
                const messages = chatMessages[group.id] || [];
                let lastMessageRaw = '暂无消息';
                
                if (messages.length > 0) {
                    const lastMsg = messages[messages.length - 1];
                    
                    // 🔥【修复】检查消息是否有效，防止undefined错误
                    if (!lastMsg) {
                        lastMessageRaw = '暂无消息';
                    } else if (lastMsg.type === 'user_photo') {
                        lastMessageRaw = '[照片]';
                    } else if (lastMsg.type === 'ai_image') {
                        lastMessageRaw = '[图片]';
                    } else if (lastMsg.type === 'voice_message') {
                        lastMessageRaw = '[语音]';
                    } else if (lastMsg.type === 'transfer') {
                        lastMessageRaw = '[转账]';
                    } else if (lastMsg.type === 'recalled_message') {
                        lastMessageRaw = '[撤回了一条消息]';
                    } else if (lastMsg.type === 'location') {
                        lastMessageRaw = '[位置]';
                    } else if (lastMsg.type === 'call_message') {
                        lastMessageRaw = '[通话消息]';
                    } else if (lastMsg.sender === 'system') {
                        lastMessageRaw = lastMsg.content || '[系统消息]';
                    } else if (lastMsg.isEmoji) {
                        lastMessageRaw = '[表情]';
                    } else {
                        lastMessageRaw = lastMsg.content || '';
                    }
                }
                
                const lastMessage = truncateText(String(lastMessageRaw || '暂无消息'), 30);
                const lastTime = messages.length > 0 ? formatTime(messages[messages.length - 1].timestamp) : '刚刚';
                
                const messageItem = document.createElement('div');
                messageItem.className = `message-item ${isMessageListMultiSelectMode && selectedConversations.includes(group.id) ? 'selected' : ''}`;
                messageItem.dataset.conversationId = group.id; // 添加对话ID
                
                // 根据模式设置不同的点击事件
                if (isMessageListMultiSelectMode) {
                    messageItem.onclick = () => toggleConversationSelection(group.id);
                } else {
                messageItem.onclick = () => startChat(group);
                    
                    // 添加长按事件（支持移动端和桌面端）
                    let pressTimer;
                    
                    // 移动端触摸事件
                    messageItem.addEventListener('touchstart', (e) => {
                        e.stopPropagation(); // 阻止事件冒泡
                        pressTimer = setTimeout(() => {
                            console.log('触摸长按触发，群聊ID:', group.id);
                            enterMessageListMultiSelectMode(group.id);
                            e.preventDefault();
                        }, 800); // 800ms长按
                    });
                    
                    messageItem.addEventListener('touchend', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    messageItem.addEventListener('touchmove', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    // 桌面端鼠标事件
                    messageItem.addEventListener('mousedown', (e) => {
                        if (e.button === 0) { // 左键
                            e.stopPropagation(); // 阻止事件冒泡
                            pressTimer = setTimeout(() => {
                                console.log('鼠标长按触发，群聊ID:', group.id);
                                enterMessageListMultiSelectMode(group.id);
                                e.preventDefault();
                            }, 800); // 800ms长按
                        }
                    });
                    
                    messageItem.addEventListener('mouseup', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    messageItem.addEventListener('mouseleave', (e) => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    });
                    
                    // 右键点击进入多选模式（桌面端）
                    messageItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        enterMessageListMultiSelectMode(group.id);
                    });
                }
                
                messageItem.innerHTML = `
                    ${isMessageListMultiSelectMode ? `
                        <div class="selection-checkbox ${selectedConversations.includes(group.id) ? 'selected' : ''}">
                            ${selectedConversations.includes(group.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                        </div>
                    ` : ''}
                    <div class="message-avatar" style="${group.avatarUrl ? `background-image: url(${group.avatarUrl}); background-size: cover; background-position: center;` : 'background-color: #4CAF50;'}">
                        ${group.avatarUrl ? '' : '群'}
                    </div>
                    <div class="message-content">
                                                        <div class="message-name">${group.name} <span class="group-member-count">(${group.members ? group.members.length + 1 : 1}人)</span></div>
                        <div class="message-preview">${lastMessage}</div>
                    </div>
                    <div class="message-time">${lastTime}</div>
                `;
                
                messageList.appendChild(messageItem);
            });
        }
        
        // 渲染联系人列表（角色页面）- 按分组显示
        function renderContactList() {
            const contactList = document.querySelector('#contact-list .contact-section');
            if (!contactList) return;
            
            // 清空所有内容
            contactList.innerHTML = '';
            

            
            // 添加多选模式的头部
            if (isMultiSelectMode) {
                const headerDiv = document.createElement('div');
                headerDiv.className = 'multiselect-header';
                headerDiv.innerHTML = `
                    <div class="multiselect-info">
                        <i class="fas fa-check-circle multiselect-icon"></i>
                        <span class="multiselect-text">已选择 ${selectedCharacters.length} 个角色</span>
                    </div>
                    <div class="multiselect-actions">
                        <button onclick="showMoveToGroupModal()" class="multiselect-btn move-btn" title="移动到分组">
                            <i class="fas fa-folder"></i>
                            <span>移动</span>
                        </button>
                        <button onclick="deleteSelectedCharacters()" class="multiselect-btn delete-btn" title="删除选中角色">
                            <i class="fas fa-trash"></i>
                            <span>删除</span>
                        </button>
                        <button onclick="exitMultiSelectMode()" class="multiselect-btn cancel-btn" title="取消多选">
                            <i class="fas fa-times"></i>
                            <span>取消</span>
                        </button>
                    </div>
                `;
                contactList.appendChild(headerDiv);
            }
            
            // 分组管理模式的头部
            if (isGroupManageMode) {
                const manageHeaderDiv = document.createElement('div');
                manageHeaderDiv.className = 'group-manage-header';
                manageHeaderDiv.innerHTML = `
                    <div class="group-manage-info">
                        <i class="fas fa-cogs group-manage-icon"></i>
                        <span class="group-manage-text">分组管理模式</span>
                    </div>
                    <div class="group-manage-actions">
                        <button onclick="showCreateGroupModal()" class="multiselect-btn create-btn" title="新建分组">
                            <i class="fas fa-plus"></i>
                            <span>新建</span>
                        </button>
                        <button onclick="exitGroupManageMode()" class="multiselect-btn done-btn" title="完成管理">
                            <i class="fas fa-check"></i>
                            <span>完成</span>
                        </button>
                    </div>
                `;
                contactList.appendChild(manageHeaderDiv);
            }
            
            // 按分组渲染角色
            const sortedGroups = characterGroups.sort((a, b) => a.order - b.order);
            
            sortedGroups.forEach(group => {
                const groupCharacters = characters.filter(char => char.groupId === group.id);
                
                // 如果该分组没有角色且不是分组管理模式，跳过显示
                if (groupCharacters.length === 0 && !isGroupManageMode) return;
                
                // 创建分组标题
                const groupHeader = document.createElement('div');
                groupHeader.className = `group-header ${group.isDefault ? 'default-group' : 'custom-group'}`;
                
                let interactionIcon = '';
                if (group.canInteract && !group.isDefault) {
                    interactionIcon = '<i class="fas fa-comments group-interaction-icon" title="该分组角色可以在动态中互动"></i>';
                }
                
                if (isGroupManageMode) {
                    groupHeader.innerHTML = `
                        <div class="group-title-area">
                            <span class="group-title">${group.name} (${groupCharacters.length})</span>
                            ${interactionIcon}
                            <span class="group-count"></span>
                        </div>
                        <div class="group-manage-actions">
                            ${!group.isDefault ? `
                                <button onclick="editGroup('${group.id}')" class="edit-group-btn" title="编辑分组">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button onclick="deleteGroup('${group.id}')" class="delete-group-btn" title="删除分组">
                                    <i class="fas fa-trash"></i>
                                </button>
                            ` : ''}
                        </div>
                    `;
                } else {
                    const isCollapsed = localStorage.getItem(`group_collapsed_${group.id}`) === 'true';
                    groupHeader.innerHTML = `
                        <div class="group-title-area" onclick="toggleGroupCollapse('${group.id}')">
                            <i class="fas fa-chevron-${isCollapsed ? 'right' : 'down'} group-chevron"></i>
                            <span class="group-title">${group.name}</span>
                            ${interactionIcon}
                            <span class="group-count">${groupCharacters.length}/${groupCharacters.length}</span>
                        </div>
                    `;
                }
                
                contactList.appendChild(groupHeader);
                
                // 创建角色容器
                const charactersContainer = document.createElement('div');
                charactersContainer.className = 'group-characters';
                charactersContainer.id = `group-characters-${group.id}`;
                
                // 检查是否折叠
                const isCollapsed = localStorage.getItem(`group_collapsed_${group.id}`) === 'true';
                if (isCollapsed && !isGroupManageMode) {
                    charactersContainer.style.display = 'none';
                }
                
                // 渲染分组中的角色
                groupCharacters.forEach(character => {
                    const savedSettings = localStorage.getItem(`chatSettings_${character.id}`);
                    const chatSettings = savedSettings ? JSON.parse(savedSettings) : {};
                    const displayName = chatSettings.aiChatNickname || character.name;
                    
                    const contactItem = document.createElement('div');
                    contactItem.className = `contact-item ${isMultiSelectMode && selectedCharacters.includes(character.id) ? 'selected' : ''}`;
                    contactItem.dataset.characterId = character.id;
                    
                    // 根据模式设置不同的点击事件
                    if (isMultiSelectMode) {
                        contactItem.onclick = () => toggleCharacterSelection(character.id);
                    } else {
                        contactItem.onclick = () => editCharacterFromContactList(character.id);
                        
                        // 添加长按事件（支持触摸和鼠标）
                        let pressTimer;
                        
                        const startLongPress = (e) => {
                            pressTimer = setTimeout(() => {
                                // 长按直接弹出移动角色模态框
                                showMoveCharacterModal(character.id);
                                e.preventDefault();
                            }, 800);
                        };
                        
                        const cancelLongPress = () => {
                            clearTimeout(pressTimer);
                        };
                        
                        // 触摸事件
                        contactItem.addEventListener('touchstart', startLongPress);
                        contactItem.addEventListener('touchend', cancelLongPress);
                        contactItem.addEventListener('touchmove', cancelLongPress);
                        
                        // 鼠标事件（作为备选）
                        contactItem.addEventListener('mousedown', startLongPress);
                        contactItem.addEventListener('mouseup', cancelLongPress);
                        contactItem.addEventListener('mouseleave', cancelLongPress);
                        
                        // 右键点击
                        contactItem.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            // 右键直接弹出移动角色模态框
                            showMoveCharacterModal(character.id);
                        });
                    }
                    
                    contactItem.innerHTML = `
                        ${isMultiSelectMode ? `
                            <div class="selection-checkbox ${selectedCharacters.includes(character.id) ? 'selected' : ''}">
                                ${selectedCharacters.includes(character.id) ? '<i class="fas fa-check check-icon-white"></i>' : ''}
                            </div>
                        ` : ''}
                        <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : displayName.charAt(0)}
                        </div>
                        <div class="contact-info">
                            <div class="message-name">${displayName}</div>
                            <div class="character-preview">${truncateText(character.bio || '暂无人设描述', 25)}</div>
                        </div>
                        ${isGroupManageMode ? `
                            <div class="move-character-btn" onclick="showMoveCharacterModal('${character.id}')" title="移动到其他分组">
                                <i class="fas fa-arrows-alt"></i>
                            </div>
                        ` : ''}
                    `;
                    
                    charactersContainer.appendChild(contactItem);
                });
                
                // 如果分组没有角色，显示提示
                if (groupCharacters.length === 0 && isGroupManageMode) {
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = 'empty-group-message';
                    emptyDiv.textContent = '该分组暂无角色';
                    charactersContainer.appendChild(emptyDiv);
                }
                
                contactList.appendChild(charactersContainer);
            });
            
            // 如果完全没有角色，显示提示
            if (characters.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'empty-message';
                emptyDiv.textContent = '还没有角色，点击右上角+号创建角色吧！';
                contactList.appendChild(emptyDiv);
            }
        }

        // === 分组管理相关函数 ===
        function enterGroupManageMode() {
            isGroupManageMode = true;
            renderContactList();
            
            // 隐藏管理分组按钮
            const groupManageBtn = document.getElementById('group-manage-btn');
            if (groupManageBtn) {
                groupManageBtn.style.display = 'none';
            }
        }

        function exitGroupManageMode() {
            isGroupManageMode = false;
            renderContactList();
            
            // 显示管理分组按钮
            const groupManageBtn = document.getElementById('group-manage-btn');
            if (groupManageBtn) {
                groupManageBtn.style.display = 'flex';
            }
        }

        function toggleGroupCollapse(groupId) {
            const container = document.getElementById(`group-characters-${groupId}`);
            if (!container) return;
            
            const isCollapsed = container.style.display === 'none';
            container.style.display = isCollapsed ? 'block' : 'none';
            
            // 保存折叠状态
            localStorage.setItem(`group_collapsed_${groupId}`, !isCollapsed);
            
            // 更新箭头方向
            const chevron = document.querySelector(`[onclick="toggleGroupCollapse('${groupId}')"] .group-chevron`);
            if (chevron) {
                chevron.className = `fas fa-chevron-${isCollapsed ? 'down' : 'right'} group-chevron`;
            }
        }

        function showCreateGroupModal() {
            const modalHtml = `
                <div id="create-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">新建分组</div>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>分组名称</label>
                                <input type="text" id="new-group-name" class="form-input" placeholder="请输入分组名称" maxlength="10">
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="new-group-interaction" class="form-checkbox"> 
                                    允许该分组角色在动态中互动
                                </label>
                                <p class="form-help-text">开启后，该分组的角色可以在动态页面相互点赞、评论</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideCreateGroupModal()">取消</button>
                            <button class="modal-button modal-primary" onclick="createNewGroup()">创建</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // 聚焦输入框
            setTimeout(() => {
                document.getElementById('new-group-name').focus();
            }, 100);
        }

        function hideCreateGroupModal() {
            const modal = document.getElementById('create-group-modal');
            if (modal) modal.remove();
        }

        async function createNewGroup() {
            const nameInput = document.getElementById('new-group-name');
            const interactionCheckbox = document.getElementById('new-group-interaction');
            
            const name = nameInput.value.trim();
            if (!name) {
                alert('请输入分组名称');
                nameInput.focus();
                return;
            }
            
            // 检查重名
            if (characterGroups.find(g => g.name === name)) {
                alert('分组名称已存在');
                nameInput.focus();
                return;
            }
            
            const newGroup = {
                id: 'group_' + Date.now(),
                name: name,
                order: characterGroups.length + 1,
                isDefault: false,
                canInteract: interactionCheckbox.checked
            };
            
            characterGroups.push(newGroup);
            await saveCharacterGroups();
            
            hideCreateGroupModal();
            renderContactList();
            showToast('分组创建成功', 'success');
        }

        function editGroup(groupId) {
            const group = characterGroups.find(g => g.id === groupId);
            if (!group || group.isDefault) return;
            
            const modalHtml = `
                <div id="edit-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">编辑分组</div>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>分组名称</label>
                                <input type="text" id="edit-group-name" class="form-input" value="${group.name}" maxlength="10">
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="edit-group-interaction" class="form-checkbox" ${group.canInteract ? 'checked' : ''}> 
                                    允许该分组角色在动态中互动
                                </label>
                                <p class="form-help-text">开启后，该分组的角色可以在动态页面相互点赞、评论</p>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideEditGroupModal()">取消</button>
                            <button class="modal-button modal-primary" onclick="updateGroup('${groupId}')">保存</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // 聚焦输入框
            setTimeout(() => {
                document.getElementById('edit-group-name').focus();
            }, 100);
        }

        function hideEditGroupModal() {
            const modal = document.getElementById('edit-group-modal');
            if (modal) modal.remove();
        }

        async function updateGroup(groupId) {
            const nameInput = document.getElementById('edit-group-name');
            const interactionCheckbox = document.getElementById('edit-group-interaction');
            
            const name = nameInput.value.trim();
            if (!name) {
                alert('请输入分组名称');
                nameInput.focus();
                return;
            }
            
            // 检查重名（排除自己）
            if (characterGroups.find(g => g.name === name && g.id !== groupId)) {
                alert('分组名称已存在');
                nameInput.focus();
                return;
            }
            
            const groupIndex = characterGroups.findIndex(g => g.id === groupId);
            if (groupIndex !== -1) {
                characterGroups[groupIndex].name = name;
                characterGroups[groupIndex].canInteract = interactionCheckbox.checked;
                
                await saveCharacterGroups();
                
                hideEditGroupModal();
                renderContactList();
                showToast('分组更新成功', 'success');
            }
        }

        async function deleteGroup(groupId) {
            const group = characterGroups.find(g => g.id === groupId);
            if (!group || group.isDefault) return;
            
            const groupCharacters = characters.filter(char => char.groupId === groupId);
            
            let confirmMsg = `确定要删除分组"${group.name}"吗？`;
            if (groupCharacters.length > 0) {
                confirmMsg += `\n\n该分组下有 ${groupCharacters.length} 个角色，将被移动到"我的好友"分组。`;
            }
            
            if (!confirm(confirmMsg)) return;
            
            // 将该分组的角色移动到默认分组
            groupCharacters.forEach(character => {
                character.groupId = 'my_friends';
            });
            
            // 删除分组
            const groupIndex = characterGroups.findIndex(g => g.id === groupId);
            if (groupIndex !== -1) {
                characterGroups.splice(groupIndex, 1);
            }
            
            await Promise.all([
                saveCharacterGroups(),
                saveCharacters()
            ]);
            
            renderContactList();
            showToast('分组删除成功', 'success');
        }

        function showMoveCharacterModal(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            const availableGroups = characterGroups.filter(g => g.id !== character.groupId);
            
            const modalHtml = `
                <div id="move-character-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">移动角色：${character.name}</div>
                        </div>
                        <div class="modal-body">
                            <div class="group-list">
                                ${availableGroups.map(group => `
                                    <div class="group-option" onclick="moveCharacterToGroup('${characterId}', '${group.id}')">
                                        <span class="group-name">${group.name}</span>
                                        <i class="fas fa-chevron-right"></i>
                                    </div>
                                `).join('')}
                            </div>
                            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                                <div class="group-option" onclick="hideMoveCharacterModal(); enterMultiSelectMode('${characterId}');" style="color: #007AFF;">
                                    <span class="group-name">
                                        <i class="fas fa-check-square" style="margin-right: 6px;"></i>
                                        进入多选模式
                                    </span>
                                    <i class="fas fa-chevron-right"></i>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideMoveCharacterModal()">取消</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function hideMoveCharacterModal() {
            const modal = document.getElementById('move-character-modal');
            if (modal) modal.remove();
        }

        async function moveCharacterToGroup(characterId, targetGroupId) {
            const characterIndex = characters.findIndex(c => c.id === characterId);
            if (characterIndex !== -1) {
                const oldGroupId = characters[characterIndex].groupId;
                characters[characterIndex].groupId = targetGroupId;
                
                await saveCharacters();
                hideMoveCharacterModal();
                renderContactList();
                
                const targetGroup = characterGroups.find(g => g.id === targetGroupId);
                showToast(`已移动到"${targetGroup.name}"分组`, 'success');
            }
        }

        function showMoveToGroupModal() {
            if (selectedCharacters.length === 0) {
                alert('请先选择要移动的角色');
                return;
            }
            
            const modalHtml = `
                <div id="move-to-group-modal" class="modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">移动 ${selectedCharacters.length} 个角色到分组</div>
                        </div>
                        <div class="modal-body">
                            <div class="group-list">
                                ${characterGroups.map(group => `
                                    <div class="group-option" onclick="moveSelectedCharactersToGroup('${group.id}')">
                                        <span class="group-name">${group.name}</span>
                                        <i class="fas fa-chevron-right"></i>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button modal-secondary" onclick="hideMoveToGroupModal()">取消</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function hideMoveToGroupModal() {
            const modal = document.getElementById('move-to-group-modal');
            if (modal) modal.remove();
        }

        async function moveSelectedCharactersToGroup(targetGroupId) {
            selectedCharacters.forEach(characterId => {
                const characterIndex = characters.findIndex(c => c.id === characterId);
                if (characterIndex !== -1) {
                    characters[characterIndex].groupId = targetGroupId;
                }
            });
            
            await saveCharacters();
            hideMoveToGroupModal();
            exitMultiSelectMode(); // 退出多选模式
            
            const targetGroup = characterGroups.find(g => g.id === targetGroupId);
            showToast(`已移动 ${selectedCharacters.length} 个角色到"${targetGroup.name}"分组`, 'success');
        }
        
        // 渲染角色列表
        function renderCharacterList() {
            const characterList = document.getElementById('character-list');
            // 检查元素是否存在，如果不存在就跳过（因为我们已经删除了人物应用）
            if (!characterList) {
                console.log('character-list元素不存在，跳过渲染');
                return;
            }
            
            characterList.innerHTML = '';
            
            characters.forEach(character => {
                const characterItem = document.createElement('div');
                characterItem.className = 'character-item';
                characterItem.onclick = () => editCharacter(character.id);
                
                characterItem.innerHTML = `
                    <div class="character-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${character.avatarUrl ? '' : character.name.charAt(0)}
                    </div>
                    <div class="character-info">
                        <div class="character-name">${character.name}</div>
                        <div class="character-bio">${truncateText(character.bio, 50)}</div>
                    </div>
                `;
                
                characterList.appendChild(characterItem);
            });
        }
        
        // 渲染联系人模态框
        function renderContactModal() {
            const modalBody = document.getElementById('contact-modal-body');
            modalBody.innerHTML = '';
            
            characters.forEach(character => {
                // 只显示未添加为联系人的角色
                if (!contacts.includes(character.id)) {
                    const contactOption = document.createElement('div');
                    contactOption.className = 'contact-item';
                    
                    const checkboxId = `contact-${character.id}`;
                    
                    contactOption.innerHTML = `
                        <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="character-info character-info-flex">
                            <div class="character-name">${character.name}</div>
                            <div class="character-bio">${truncateText(character.bio, 40)}</div>
                        </div>
                        <input type="checkbox" id="${checkboxId}" class="contact-checkbox" value="${character.id}">
                    `;
                    
                    modalBody.appendChild(contactOption);
                }
            });
            
            if (modalBody.children.length === 0) {
                modalBody.innerHTML = '<p>没有可添加的角色，请先创建新角色。</p>';
            }
        }
        
        // 当前显示的消息数量限制
        let currentMessageOffset = 0;
        const MESSAGE_LIMIT = 50;
        
        // 渲染聊天消息
        function renderChatMessages(characterId, loadMore = false) {
            const messagesContainer = document.getElementById('api-chat-messages');
            const allMessages = chatMessages[characterId] || [];
            const chatSettings = getCurrentChatSettings();
            
            if (!loadMore) {
                // 重新渲染时清空容器并重置偏移量
                messagesContainer.innerHTML = '';
                currentMessageOffset = Math.max(0, allMessages.length - MESSAGE_LIMIT);
            }
            
            // 应用聊天背景
            applyChatBackground();
            
            // 应用气泡样式
            applyBubbleStyle();
            
            // 如果没有消息，显示空状态提示
            if (allMessages.length === 0) {
                const displayName = chatSettings.aiChatNickname || currentChatCharacter.name;
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-chat-state';
                emptyState.innerHTML = `
                    <div>开始和 ${displayName} 聊天吧</div>
                `;
                messagesContainer.appendChild(emptyState);
                return;
            }
            
            // 如果不是加载更多，且有更多历史消息，显示"查看历史消息"按钮
            if (!loadMore && currentMessageOffset > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'load-more-messages';
                loadMoreBtn.innerHTML = `
                    <div class="load-more-content">
                        <i class="fas fa-chevron-up"></i>
                        <span>查看历史消息 (${currentMessageOffset}条)</span>
                    </div>
                `;
                loadMoreBtn.onclick = () => loadMoreMessages(characterId);
                messagesContainer.appendChild(loadMoreBtn);
            }
            
            // 获取要显示的消息
            const messagesToShow = loadMore ? 
                allMessages.slice(Math.max(0, currentMessageOffset - MESSAGE_LIMIT), currentMessageOffset) :
                allMessages.slice(currentMessageOffset);
            
            // 获取时间戳设置
            const timestampEnabled = chatSettings.timestampEnabled !== false; // 默认为true
            const timestampPosition = chatSettings.timestampPosition || 'center';
            
            let lastTimestamp = 0;
            
            messagesToShow.forEach((message, index) => {
                // 处理系统消息（如戳一戳、头像更换、撤回等）
                if (message.sender === 'system') {
                    if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                    messagesContainer.appendChild(systemContainer);
                    } else if (message.type === 'recalled_message') {
                        // 🔥【新增】处理撤回消息的显示
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id; // 🔥【修复】添加消息ID以支持选择
                        
                        const recallElement = document.createElement('div');
                        recallElement.className = 'recalled-message';
                        
                        // 解析撤回消息内容（格式：xxx 撤回了一条消息\n原文：xxx）
                        const lines = message.content.split('\n');
                        const mainText = lines[0]; // 主要提示文字
                        const originalText = lines[1]; // 原文部分
                        
                        recallElement.textContent = mainText;
                        
                        // 如果有原文，添加原文显示
                        if (originalText && originalText.startsWith('原文：')) {
                            const originalDiv = document.createElement('div');
                            originalDiv.className = 'original-text';
                            originalDiv.textContent = originalText;
                            recallElement.appendChild(originalDiv);
                        }
                        
                        centerContainer.appendChild(recallElement);
                        messagesContainer.appendChild(centerContainer);
                        
                        // 🔥【修复】为撤回消息添加选择功能
                        addMessageLongPressListener(centerContainer, message.id);
                    } else if (message.type === 'call_record') {
                        // 处理通话记录消息
                        const centerContainer = document.createElement('div');
                        centerContainer.className = 'message-wrapper system';
                        centerContainer.dataset.messageId = message.id;
                        
                        const callRecordElement = document.createElement('div');
                        callRecordElement.className = 'call-record-message';
                        
                        // 根据通话状态设置不同的图标和样式
                        const callIcon = document.createElement('i');
                        
                        if (message.callType === 'outgoing') {
                            callIcon.className = 'fas fa-phone-alt';
                        } else if (message.callType === 'incoming') {
                            if (message.callStatus === 'rejected') {
                                callIcon.className = 'fas fa-phone-slash';
                                callRecordElement.classList.add('missed');
                            } else {
                                callIcon.className = 'fas fa-phone';
                            }
                        } else if (message.callType === 'ended') {
                            callIcon.className = 'fas fa-phone';
                            callRecordElement.classList.add('completed');
                        }
                        
                        callRecordElement.appendChild(callIcon);
                        
                        const callTextElement = document.createElement('span');
                        callTextElement.textContent = message.content;
                        callRecordElement.appendChild(callTextElement);
                        
                        // 如果有通话时长，则显示（仅在callType为ended时显示）
                        if (message.duration && message.callType === 'ended') {
                            const durationElement = document.createElement('span');
                            durationElement.className = 'call-record-duration';
                            durationElement.textContent = message.duration;
                            callRecordElement.appendChild(durationElement);
                        }
                        
                        centerContainer.appendChild(callRecordElement);
                        messagesContainer.appendChild(centerContainer);
                    } else if (message.type === 'call_message') {
                        // 🔥【新增】处理通话消息 - 显示为简单的文本消息
                        const centerContainer = document.createElement('div');
                        centerContainer.className = 'message-wrapper system';
                        centerContainer.dataset.messageId = message.id;
                        
                        const callMessageElement = document.createElement('div');
                        callMessageElement.className = 'system-message';
                        callMessageElement.style.fontStyle = 'italic';
                        callMessageElement.style.color = '#888';
                        callMessageElement.textContent = `📞 通话: ${message.content}`;
                        
                        centerContainer.appendChild(callMessageElement);
                        messagesContainer.appendChild(centerContainer);
                    } else {
                        // 🔥【修复】其他系统消息（如头像更换）- 使用居中容器
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        
                        const systemContainer = document.createElement('div');
                        systemContainer.className = 'system-message';
                        systemContainer.textContent = message.content;
                        
                        centerContainer.appendChild(systemContainer);
                        messagesContainer.appendChild(centerContainer);
                    }
                    return;
                }
                
                // 添加居中时间戳（如果启用且位置为居中）
                if (timestampEnabled && timestampPosition === 'center') {
                    const currentTime = new Date(message.timestamp);
                    const timeDiff = currentTime - lastTimestamp;
                    
                    // 如果距离上条消息超过5分钟，显示时间戳
                    if (index === 0 || timeDiff > 5 * 60 * 1000) {
                        const timestampDiv = document.createElement('div');
                        timestampDiv.className = 'timestamp timestamp-center';
                        timestampDiv.textContent = formatTimestamp(message.timestamp);
                        messagesContainer.appendChild(timestampDiv);
                        lastTimestamp = currentTime;
                    }
                }
                
                const messageContainer = document.createElement('div');
                // 检查是否是纯表情包消息
                const isEmojiOnly = message.isEmoji && !message.content;
                messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
                messageContainer.dataset.messageId = message.id; // 添加消息ID数据属性
                
                if (message.sender === 'received') {
                    // ==== 群聊支持 ====
                    let character = characters.find(c => c.id === characterId);
                    let isGroup = false;
                    let group = null;
                    if (!character) {
                        group = groupChats.find(g => g.id === characterId);
                        if (group) {
                            isGroup = true;
                        }
                    }
                    
                    let displayAvatar = '';
                    let displayName = '';
                    let color = '#4CAF50';
                    
                    if (isGroup && group) {
                        // 群聊：根据消息的senderId或name查找成员
                        let member = null;
                        if (message.senderId) {
                            member = group.members.find(m => m.id === message.senderId);
                        } else if (message.name) {
                            member = group.members.find(m => m.name === message.name);
                        }
                        displayAvatar = member?.avatarUrl || '';
                        displayName = member?.name || '群成员';
                        color = member?.color || '#4CAF50';
                    } else if (character) {
                        // 单聊
                        displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                        displayName = chatSettings.aiChatNickname || character.name;
                        color = character.color || '#4CAF50';
                    
                    // 🔥【调试】记录头像选择过程
                    if (chatSettings.aiDynamicAvatar) {
                        console.log(`使用动态头像: ${chatSettings.aiDynamicAvatar.substring(0, 30)}...`);
                    } else if (chatSettings.aiChatAvatar) {
                        console.log(`使用聊天设置头像: ${chatSettings.aiChatAvatar.substring(0, 30)}...`);
                    } else {
                        console.log(`使用角色卡头像: ${character.avatarUrl ? character.avatarUrl.substring(0, 30) + '...' : '无头像'}`);
                    }
                    } else {
                        // 兜底，防止报错
                        displayAvatar = '';
                        displayName = '未知';
                        color = '#4CAF50';
                    }
                    
                    // 🔥【新增】获取气泡样式 - 群聊中使用成员专属颜色
                    let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                    
                    // 如果是群聊且有成员专属颜色设置，使用成员专属颜色
                    if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                        const memberColor = chatSettings.memberBubbleColors[message.senderId];
                        if (memberColor) {
                            bubbleColor = memberColor;
                        }
                    }
                    
                    const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                    const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                    const bubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                    
                    // 🔥 处理特殊消息类型
                    let messageContent = '';
                    
                    if (message.type === 'user_photo') {
                        // 角色发送的"伪照片" - 使用与用户相同的结构
                        messageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">✨</div>
                                        <div class="sparkle sparkle-2">⭐</div>
                                        <div class="sparkle sparkle-3">✨</div>
                                        <div class="sparkle sparkle-4">⭐</div>
                                        <div class="sparkle sparkle-5">💫</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${(message.photoDescription || message.content)}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // 角色发送的位置消息 - 使用与用户相同的结构
                        messageContent = `
                            <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                <div class="location-card-header">${message.locationName}</div>
                                <div class="location-card-map">
                                    <div class="map-background"></div>
                                    <div class="map-roads">
                                        <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                        <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                        <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                    </div>
                                    <div class="map-buildings">
                                        <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                        <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                        <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                        <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                        <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                        <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                    </div>
                                    <div class="map-marker">
                                        <div class="marker-pin">📍</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'voice_message') {
                        // 过滤掉括号中的描述性内容，保留实际说话内容
                        const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                        const voiceDuration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                        
                        // AI语音消息 - 使用和用户语音消息一样的结构
                        messageContent = `
                            <div class="voice-message-container received">
                                <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${voiceDuration}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                    </div>
                                </div>
                                <div class="voice-text-content">${cleanVoiceContent}</div>
                            </div>
                        `;
                    } else if (message.type === 'ai_image') {
                        // AI生成的图片
                        messageContent = `
                            <div class="ai-image-container">
                                <img src="${message.image}" class="message-image" onclick="showImage('${message.image}')" alt="AI生成的图片">
                                <div class="image-description">${message.imageDescription || ''}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 转账消息
                        const isUser = message.role === 'user';
                        const heartIcon = isUser ? '💕' : '💖';
                        const titleText = isUser ? '你发起的转账' : '收到转账';
                        let cardClass = '';
                        let statusHtml = '';
                        let clickHandler = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                            cardClass = 'rejected';
                        } else if (!isUser) {
                            // AI发来的转账且未处理，添加点击处理
                            clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                        }
                        
                        messageContent = `
                            <div class="transfer-message-container received">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}>
                                    <div class="transfer-title">${heartIcon} ${titleText}</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else {
                        // 普通文本消息
                        const chatMode = chatSettings.chatMode || 'online';
                        let processedContent = message.content;
                        
                        if (chatMode === 'offline') {
                            processedContent = processOfflineContent(message.content);
                        }
                        
                        messageContent = processedContent;
                    }
                    
                    let avatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        avatarHtml = `
                            <div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="戳一戳"` : `title="${displayName}"`}>
                                ${displayAvatar ? '' : displayName.charAt(0)}
                                ${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    let bubbleHtml = '';
                    if (message.type === 'voice_message' || message.type === 'transfer' || message.type === 'user_photo' || message.type === 'location') {
                        // 语音消息、转账消息、照片和位置消息不需要额外的气泡包裹
                        bubbleHtml = messageContent;
                    } else {
                        // 普通消息用气泡包裹
                        bubbleHtml = `
                                                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                ${messageContent}
                                ${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                                ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                    `;
                    }
                    
      // 🔥【修复】群聊昵称显示 - 特别处理语音消息和转账消息
      if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;
    
    if (message.type === 'voice_message' || message.type === 'transfer') {
        // 🔥【修复】对于语音消息和转账消息，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                    messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                } else {
                    // 获取我的显示头像和气泡样式
let myDisplayAvatar = chatSettings.myChatAvatar; // 优先使用聊天专属设置里的头像
let myDisplayName = chatSettings.myChatNickname; // 优先使用聊天专属设置里的昵称
                    
// 如果专属设置里没有，则进行二次查找（作为保险措施）
if ((!myDisplayAvatar || !myDisplayName) && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    if (selectedPersona) {
        // 如果头像为空，则使用身份头像
        if (!myDisplayAvatar) myDisplayAvatar = selectedPersona.avatarUrl;
        // 如果昵称为空，则使用身份昵称
        if (!myDisplayName) myDisplayName = selectedPersona.name;
                        }
                    }
                    
                    const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                    const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                    const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                    const myBubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                    
                    // 处理用户的特殊消息类型
                    let myMessageContent = '';
                    if (message.type === 'user_photo') {
                        // 用户发送的"照片"（文字描述）
                        myMessageContent = `
                            <div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')">
                                <div class="dreamy-photo">
                                    <div class="photo-misty-bg"></div>
                                    <div class="photo-badge">
                                        <i class="fas fa-image"></i>
                                    </div>
                                    <div class="sparkle-container">
                                        <div class="sparkle sparkle-1">✨</div>
                                        <div class="sparkle sparkle-2">⭐</div>
                                        <div class="sparkle sparkle-3">✨</div>
                                        <div class="sparkle sparkle-4">⭐</div>
                                        <div class="sparkle sparkle-5">💫</div>
                                    </div>
                                    <div class="photo-text-overlay" style="display: none;">
                                        <div class="photo-description">${(message.photoDescription || message.content)}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'voice') {
                        // 用户发送的语音消息
                        myMessageContent = `
                            <div class="voice-message-container sent">
                                <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                    </div>
                                    ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                    ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                </div>
                                <div class="voice-text-content">${message.content}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 用户转账消息 - 在renderChatMessages中处理
                        let cardClass = '';
                        let statusHtml = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">对方已收款</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">对方已退回</div>`;
                            cardClass = 'rejected';
                        }
                        
                        myMessageContent = `
                            <div class="transfer-message-container sent">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                    <div class="transfer-title">💕 你发起的转账</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // 用户发送的位置消息
                        myMessageContent = `
                            <div class="location-message-container sent">
                                <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                    <div class="location-card-header">${message.locationName}</div>
                                    <div class="location-card-map">
                                        <div class="map-background"></div>
                                        <div class="map-roads">
                                            <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                            <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                            <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                        </div>
                                        <div class="map-buildings">
                                            <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                            <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                            <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                            <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                            <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                            <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                        </div>
                                        <div class="map-marker">
                                            <div class="marker-pin">📍</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // 🔥【修复】处理多模态消息或普通文本消息
                        if (Array.isArray(message.content)) {
                            // 新的多模态格式
                            const textPart = message.content.find(p => p.type === 'text');
                            const imagePart = message.content.find(p => p.type === 'image_url');
                            
                            myMessageContent = textPart?.text || '';
                            
                            // 如果有图片，添加图片显示
                            if (imagePart?.image_url?.url) {
                                if (myMessageContent) {
                                    myMessageContent += '<br>';
                                }
                                myMessageContent += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                            }
                        } else {
                            // 普通文本消息或旧格式
                        myMessageContent = message.content;
                        }
                    }
                    
                    let myBubbleHtml = '';
                    
                    if (message.type === 'user_photo' || message.type === 'voice' || message.type === 'transfer' || message.type === 'location') {
                        // 用户照片、语音消息、转账消息和位置消息不需要额外气泡包裹（已经有自己的容器）
                        myBubbleHtml = myMessageContent;
                    } else {
                        // 普通消息用气泡包裹
                        myBubbleHtml = `
                            <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                ${myMessageContent}
                                ${message.image && !message.type && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                                ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    let myAvatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        myAvatarHtml = `
                            <div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">
                                ${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}
                                ${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}
                            </div>
                        `;
                    }
                    
                    messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                }
                
                // 添加滑入动画效果 - 参考完成.html的弹性动画
                messageContainer.style.opacity = '0';
                messageContainer.style.transform = 'translateY(20px)';
                messageContainer.style.transition = 'opacity 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
                
                messagesContainer.appendChild(messageContainer);
                
                // 触发滑入动画
                requestAnimationFrame(() => {
                    messageContainer.style.opacity = '1';
                    messageContainer.style.transform = 'translateY(0)';
                });
                
                // 添加长按监听器用于多选删除
                addMessageLongPressListener(messageContainer, message.id);
                
                // 添加右键菜单功能
                const bubble = messageContainer.querySelector('.message-bubble');
                if (bubble) {
                    // 鼠标右键点击
                    bubble.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showMessageMenu(message.id, e);
                    });
                    
                    // 点击图片预览
                    bubble.onclick = (e) => {
                        if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                            showImage(e.target.src);
                        }
                    };
                }
            });
            
            // 添加正在输入提示元素到消息底部（初始隐藏）
            const typingIndicator = document.createElement('div');
            typingIndicator.id = 'typing-indicator';
            typingIndicator.className = 'typing-indicator';
            typingIndicator.innerHTML = `${chatSettings.aiChatNickname || currentChatCharacter.name}正在输入中<span class="dots"></span>`;
            messagesContainer.appendChild(typingIndicator);
            
            // 如果不是加载更多，自动滚动到底部
            if (!loadMore) {
                setTimeout(() => {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }, 100);
            }
            
            // 🔥【修复】位置消息气泡包装问题 - 修复已渲染的位置消息
            setTimeout(() => {
                const locationMessages = messagesContainer.querySelectorAll('.message-container.sent');
                locationMessages.forEach(container => {
                    const locationCard = container.querySelector('.location-card');
                    if (locationCard && container.querySelector('.message-bubble')) {
                        // 如果位置卡片被包裹在气泡中，提取出来
                        const bubble = container.querySelector('.message-bubble');
                        const avatar = container.querySelector('.message-avatar');
                        if (bubble && locationCard.closest('.message-bubble')) {
                            const locationContainer = locationCard.closest('.location-message-container');
                            if (locationContainer) {
                                container.innerHTML = locationContainer.outerHTML + (avatar ? avatar.outerHTML : '');
                            }
                        }
                    }
                });
                
                // 🔥【新增】渲染角色状态显示 - 在消息渲染完成后更新状态
                if (currentChatCharacter) {
                    const headerContainer = document.querySelector('#api-chat-screen .header');
                    if (headerContainer) {
                        renderCharacterStatus(currentChatCharacter.id, headerContainer);
                    }
                }
            }, 50);
        }
        
        // 加载更多历史消息
        function loadMoreMessages(characterId) {
            const messagesContainer = document.getElementById('api-chat-messages');
            const allMessages = chatMessages[characterId] || [];
            const chatSettings = getCurrentChatSettings();
            
            // 保存滚动位置
            const scrollHeight = messagesContainer.scrollHeight;
            const scrollTop = messagesContainer.scrollTop;
            
            // 计算要加载的历史消息范围
            const newOffset = Math.max(0, currentMessageOffset - MESSAGE_LIMIT);
            const historicalMessages = allMessages.slice(newOffset, currentMessageOffset);
            
            // 移除现有的"查看历史消息"按钮
            const existingLoadMoreBtn = messagesContainer.querySelector('.load-more-messages');
            if (existingLoadMoreBtn) {
                existingLoadMoreBtn.remove();
            }
            
            // 如果还有更多历史消息，在顶部添加新的"查看历史消息"按钮
            if (newOffset > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'load-more-messages';
                loadMoreBtn.innerHTML = `
                    <div class="load-more-content">
                        <i class="fas fa-chevron-up"></i>
                        <span>查看历史消息 (${newOffset}条)</span>
                    </div>
                `;
                loadMoreBtn.onclick = () => loadMoreMessages(characterId);
                messagesContainer.insertBefore(loadMoreBtn, messagesContainer.firstChild);
            }
            
            // 在现有消息前面插入历史消息
            const timestampEnabled = chatSettings.timestampEnabled !== false;
            const timestampPosition = chatSettings.timestampPosition || 'center';
            let lastTimestamp = 0;
            
            // 从后往前插入，保持时间顺序
            for (let i = historicalMessages.length - 1; i >= 0; i--) {
                const message = historicalMessages[i];
                
                // 处理系统消息（如戳一戳、头像更换、撤回等）
                if (message.sender === 'system') {
                    let containerToInsert;
                    
                    if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                        containerToInsert = systemContainer;
                    } else if (message.type === 'recalled_message') {
                        // 🔥【新增】处理撤回消息的显示
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        centerContainer.dataset.messageId = message.id; // 🔥【修复】添加消息ID以支持选择
                        
                        const recallElement = document.createElement('div');
                        recallElement.className = 'recalled-message';
                        
                        // 解析撤回消息内容（格式：xxx 撤回了一条消息\n原文：xxx）
                        const lines = message.content.split('\n');
                        const mainText = lines[0]; // 主要提示文字
                        const originalText = lines[1]; // 原文部分
                        
                        recallElement.textContent = mainText;
                        
                        // 如果有原文，添加原文显示
                        if (originalText && originalText.startsWith('原文：')) {
                            const originalDiv = document.createElement('div');
                            originalDiv.className = 'original-text';
                            originalDiv.textContent = originalText;
                            recallElement.appendChild(originalDiv);
                        }
                        
                        centerContainer.appendChild(recallElement);
                        containerToInsert = centerContainer;
                    } else {
                        // 🔥【修复】其他系统消息（如头像更换）- 使用居中容器
                        const centerContainer = document.createElement('div');
                        centerContainer.style.display = 'flex';
                        centerContainer.style.justifyContent = 'center';
                        centerContainer.style.margin = '4px 0';
                        
                        const systemContainer = document.createElement('div');
                        systemContainer.className = 'system-message';
                        systemContainer.textContent = message.content;
                        
                        centerContainer.appendChild(systemContainer);
                        containerToInsert = centerContainer;
                    }
                    
                    // 插入到按钮后面（如果有按钮的话）
                    const insertAfter = messagesContainer.querySelector('.load-more-messages');
                    if (insertAfter) {
                        insertAfter.parentNode.insertBefore(containerToInsert, insertAfter.nextSibling);
                    } else {
                        messagesContainer.insertBefore(containerToInsert, messagesContainer.firstChild);
                    }
                    
                    // 🔥【修复】为撤回消息添加选择功能
                    if (message.type === 'recalled_message') {
                        addMessageLongPressListener(containerToInsert, message.id);
                    }
                    
                    continue;
                }
                
                const messageContainer = document.createElement('div');
                // 检查是否是纯表情包消息
                const isEmojiOnly = message.isEmoji && !message.content;
                messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
                messageContainer.dataset.messageId = message.id;
                
                if (message.sender === 'received') {
                    // ==== 群聊支持 ====
                    let character = characters.find(c => c.id === characterId);
                    let isGroup = false;
                    let group = null;
                    if (!character) {
                        group = groupChats.find(g => g.id === characterId);
                        if (group) {
                            isGroup = true;
                        }
                    }
                    
                    let displayAvatar = '';
                    let displayName = '';
                    let color = '#4CAF50';
                    
                    if (isGroup && group) {
                        // 群聊：根据消息的senderId或name查找成员
                        let member = null;
                        if (message.senderId) {
                            member = group.members.find(m => m.id === message.senderId);
                        } else if (message.name) {
                            member = group.members.find(m => m.name === message.name);
                        }
                        displayAvatar = member?.avatarUrl || '';
                        displayName = member?.name || '群成员';
                        color = member?.color || '#4CAF50';
                    } else if (character) {
                        // 单聊
                        displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                        displayName = chatSettings.aiChatNickname || character.name;
                        color = character.color || '#4CAF50';
                    } else {
                        // 兜底，防止报错
                        displayAvatar = '';
                        displayName = '未知';
                        color = '#4CAF50';
                    }
                    // 🔥【新增】获取气泡样式 - 群聊中使用成员专属颜色
                    let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                    
                    // 如果是群聊且有成员专属颜色设置，使用成员专属颜色
                    if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                        const memberColor = chatSettings.memberBubbleColors[message.senderId];
                        if (memberColor) {
                            bubbleColor = memberColor;
                        }
                    }
                    
                    const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                    const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                    const bubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                    
                    let messageContent = '';
                    if (message.type === 'voice_message') {
                        // 过滤掉括号中的描述性内容，保留实际说话内容
                        const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                        const voiceDuration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                        
                        messageContent = `
                            <div class="voice-message-container received">
                                <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${voiceDuration}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                    </div>
                                </div>
                                <div class="voice-text-content">${cleanVoiceContent}</div>
                            </div>
                        `;
                    } else if (message.type === 'ai_image') {
                        messageContent = `<div class="ai-image-container"><img src="${message.image}" class="message-image" onclick="showImage('${message.image}')" alt="AI生成的图片"><div class="image-description">${message.imageDescription || ''}</div></div>`;
                    } else if (message.type === 'transfer') {
                        // 转账消息
                        const isUser = message.role === 'user';
                        const heartIcon = isUser ? '💕' : '💖';
                        const titleText = isUser ? '你发起的转账' : '收到转账';
                        let cardClass = '';
                        let statusHtml = '';
                        let clickHandler = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                            cardClass = 'rejected';
                        } else if (!isUser) {
                            // AI发来的转账且未处理，添加点击处理
                            clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                        }
                        
                        messageContent = `<div class="transfer-message-container received"><div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div><div class="transfer-note">${message.note || '转账'}</div>${statusHtml}</div></div>`;
                    } else {
                        const chatMode = chatSettings.chatMode || 'online';
                        let baseContent = chatMode === 'offline' ? processOfflineContent(message.content) : message.content;
                        
                        // 如果有引用消息，在内容前添加引用显示
                        if (message.replyTo) {
                            messageContent = generateReplyHTML(message.replyTo) + baseContent;
                        } else {
                            messageContent = baseContent;
                        }
                    }
                    
                    let avatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        avatarHtml = `<div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="戳一戳"` : `title="${displayName}"`}>${displayAvatar ? '' : displayName.charAt(0)}${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    let bubbleHtml = '';
                    if (message.type === 'voice_message' || message.type === 'transfer') {
                        // 语音消息和转账消息不需要额外的气泡包裹
                        bubbleHtml = messageContent;
                    } else {
                        // 普通消息用气泡包裹
                        bubbleHtml = `<div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">${messageContent}${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ''}${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                   // 🔥【修复】群聊昵称显示 （loadMoreMessages版本）- 特别处理语音消息和转账消息
                   if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;
    
    if (message.type === 'voice_message' || message.type === 'transfer') {
        // 🔥【修复】对于语音消息和转账消息，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                    messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                } else {
                    let myDisplayAvatar = chatSettings.myChatAvatar;
                    if (!myDisplayAvatar && chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona && selectedPersona.avatarUrl) {
                            myDisplayAvatar = selectedPersona.avatarUrl;
                        }
                    }
                    
                    const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                    const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                    const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                    const myBubblePadding = chatSettings.bubblePadding || '12';
                    
                    // 将透明度应用到背景色而不是整个元素
                    const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                    
                    // 处理用户的特殊消息类型
                    let myMessageContent = '';
                    if (message.type === 'user_photo') {
                        // 用户发送的"照片"（文字描述）
                        myMessageContent = `<div class="dreamy-photo-container" onclick="togglePhotoText(this, '${(message.photoDescription || message.content).replace(/'/g, '\\\'').replace(/"/g, '&quot;')}')"><div class="dreamy-photo"><div class="photo-misty-bg"></div><div class="photo-badge"><i class="fas fa-image"></i></div><div class="sparkle-container"><div class="sparkle sparkle-1">✨</div><div class="sparkle sparkle-2">⭐</div><div class="sparkle sparkle-3">✨</div><div class="sparkle sparkle-4">⭐</div><div class="sparkle sparkle-5">💫</div></div><div class="photo-text-overlay" style="display: none;"><div class="photo-description">${(message.photoDescription || message.content)}</div></div></div></div>`;
                    } else if (message.type === 'voice') {
                        // 用户发送的语音消息
                        myMessageContent = `
                            <div class="voice-message-container sent">
                                <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                    <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                        <div class="voice-wave">
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                            <div class="wave-bar"></div>
                                        </div>
                                        <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                    </div>
                                    ${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                    ${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}
                                </div>
                                <div class="voice-text-content">${message.content}</div>
                            </div>
                        `;
                    } else if (message.type === 'transfer') {
                        // 用户转账消息 - 在loadMoreMessages中处理
                        let cardClass = '';
                        let statusHtml = '';
                        
                        if (message.status === 'accepted') {
                            statusHtml = `<div class="transfer-status">对方已收款</div>`;
                            cardClass = 'accepted';
                        } else if (message.status === 'rejected') {
                            statusHtml = `<div class="transfer-status">对方已退回</div>`;
                            cardClass = 'rejected';
                        }
                        
                        myMessageContent = `
                            <div class="transfer-message-container sent">
                                <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                    <div class="transfer-title">💕 你发起的转账</div>
                                    <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                    <div class="transfer-note">${message.note || '转账'}</div>
                                    ${statusHtml}
                                </div>
                            </div>
                        `;
                    } else if (message.type === 'location') {
                        // 用户发送的位置消息 - 在loadMoreMessages中处理
                        myMessageContent = `
                            <div class="location-message-container sent">
                                <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                                    <div class="location-card-header">${message.locationName}</div>
                                    <div class="location-card-map">
                                        <div class="map-background"></div>
                                        <div class="map-roads">
                                            <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                                            <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                                            <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                                        </div>
                                        <div class="map-buildings">
                                            <div class="building" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                                            <div class="building" style="top: 25%; left: 60%; width: 14px; height: 12px;"></div>
                                            <div class="building green" style="top: 50%; left: 15%; width: 8px; height: 8px;"></div>
                                            <div class="building" style="top: 70%; left: 70%; width: 10px; height: 8px;"></div>
                                            <div class="building green" style="top: 10%; left: 75%; width: 6px; height: 6px;"></div>
                                            <div class="building green" style="top: 75%; left: 25%; width: 7px; height: 7px;"></div>
                                        </div>
                                        <div class="map-marker">
                                            <div class="marker-pin">📍</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // 🔥【修复】处理多模态消息或普通文本消息 (loadMoreMessages版本)
                        if (Array.isArray(message.content)) {
                            // 新的多模态格式
                            const textPart = message.content.find(p => p.type === 'text');
                            const imagePart = message.content.find(p => p.type === 'image_url');
                            
                            let baseContent = textPart?.text || '';
                            
                            // 如果有引用消息，在内容前添加引用显示
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }
                            
                            // 如果有图片，添加图片显示
                            if (imagePart?.image_url?.url) {
                                if (myMessageContent) {
                                    myMessageContent += '<br>';
                                }
                                myMessageContent += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                            }
                        } else {
                            // 普通文本消息或旧格式 (loadMoreMessages版本)
                            let baseContent = message.content;
                            
                            // 如果有引用消息，在内容前添加引用显示
                            if (message.replyTo) {
                                myMessageContent = generateReplyHTML(message.replyTo) + baseContent;
                            } else {
                                myMessageContent = baseContent;
                            }
                        }
                    }
                    
                    let myBubbleHtml = '';
                    
                    if (message.type === 'user_photo' || message.type === 'voice' || message.type === 'transfer' || message.type === 'location') {
                        // 用户照片、语音消息、转账消息和位置消息不需要额外气泡包裹（已经有自己的容器）
                        myBubbleHtml = myMessageContent;
                    } else {
                        // 普通消息用气泡包裹
                        myBubbleHtml = `<div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">${myMessageContent}${message.image && !message.type && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ''}${timestampEnabled && timestampPosition === 'bubble' ? `<div class="timestamp timestamp-bubble">${formatTimeOnly(message.timestamp)}</div>` : ''}${timestampEnabled && timestampPosition === 'inside' ? `<div class="timestamp timestamp-inside">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    let myAvatarHtml = '';
                    if (!chatSettings.hideAvatars) {
                        myAvatarHtml = `<div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}${timestampEnabled && timestampPosition === 'avatar' ? `<div class="timestamp timestamp-avatar">${formatTimeOnly(message.timestamp)}</div>` : ''}</div>`;
                    }
                    
                    messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                }
                
                // 添加长按监听器和右键菜单
                addMessageLongPressListener(messageContainer, message.id);
                const bubble = messageContainer.querySelector('.message-bubble');
                if (bubble) {
                    bubble.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showMessageMenu(message.id, e);
                    });
                    
                    bubble.onclick = (e) => {
                        if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                            showImage(e.target.src);
                        }
                    };
                }
                
                // 插入消息到正确位置
                const insertAfter = messagesContainer.querySelector('.load-more-messages');
                if (insertAfter) {
                    insertAfter.parentNode.insertBefore(messageContainer, insertAfter.nextSibling);
                } else {
                    messagesContainer.insertBefore(messageContainer, messagesContainer.firstChild);
                }
            }
            
            // 更新偏移量
            currentMessageOffset = newOffset;
            
            // 保持滚动位置
            setTimeout(() => {
                const newScrollHeight = messagesContainer.scrollHeight;
                messagesContainer.scrollTop = scrollTop + (newScrollHeight - scrollHeight);
            }, 50);
        }
        
        
        // 显示角色表单
        function showCharacterForm(characterId = null) {
            currentEditingCharacterId = characterId; // 保存当前编辑的角色ID
            document.getElementById('character-form-title').textContent = characterId ? '编辑人物' : '新建人物';
            
            // 清空表单
            document.getElementById('character-name').value = '';
            document.getElementById('character-bio').value = '';
            document.getElementById('avatar-upload').value = '';
            
            const avatarPreview = document.getElementById('avatar-preview');
            const avatarPreviewText = document.getElementById('avatar-preview-text');
            
            // 重置头像预览
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            avatarPreviewText.style.display = 'block';
            avatarPreviewText.textContent = 'A';
            
            // 清除临时存储的头像数据
            window.selectedAvatarData = null;
            
            // 如果是编辑模式，填充现有数据
            if (characterId) {
                const character = characters.find(c => c.id === characterId);
                if (character) {
                    document.getElementById('character-name').value = character.name;
                    document.getElementById('character-bio').value = character.bio;
                    
                    if (character.avatarUrl) {
                        avatarPreview.classList.add('has-image');
                        avatarPreview.style.setProperty('background', `url(${character.avatarUrl})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        avatarPreviewText.style.display = 'none';
                        // 为编辑模式保存现有头像数据
                        window.selectedAvatarData = character.avatarUrl;
                    } else {
                        avatarPreviewText.textContent = character.name.charAt(0);
                    }
                }
            }
            
            // 设置表单的保存函数和删除按钮显示
            const deleteBtn = document.getElementById('character-delete-btn');
            const importBtn = document.getElementById('import-character-btn');
            const exportBtn = document.getElementById('export-character-btn');
            console.log('设置保存按钮，characterId:', characterId);
            if (characterId) {
                document.querySelector('#character-form-screen .form-submit').onclick = async () => await saveCharacter(characterId);
                // 编辑模式显示删除按钮，隐藏导入按钮，显示导出按钮
                if (deleteBtn) deleteBtn.style.display = 'block';
                if (importBtn) importBtn.style.display = 'none';
                if (exportBtn) exportBtn.style.display = 'flex';
                console.log('设置为编辑模式，角色ID:', characterId);
            } else {
                document.querySelector('#character-form-screen .form-submit').onclick = async () => await saveCharacter();
                // 新建模式隐藏删除按钮，显示导入按钮，隐藏导出按钮
                if (deleteBtn) deleteBtn.style.display = 'none';
                if (importBtn) importBtn.style.display = 'flex';
                if (exportBtn) exportBtn.style.display = 'none';
                console.log('设置为创建模式，无角色ID');
            }
            
            showApp('character-form-screen');
            
            // 确保头像上传功能可用 - 重新绑定事件监听器（以防万一）
            setTimeout(() => {
                initializeAvatarUpload();
            }, 100);
        }
        
        // 保存角色
        async function saveCharacter(characterId = null) {
            try {
                console.log('=== 开始保存角色 ===');
                const name = document.getElementById('character-name').value.trim();
                const bio = document.getElementById('character-bio').value.trim();
                const avatarData = window.selectedAvatarData; // 使用预处理的头像数据
                
                console.log('保存角色 - 姓名:', name, '头像数据存在:', !!avatarData);
                if (avatarData) {
                    console.log('头像数据长度:', avatarData.length, '开头:', avatarData.substring(0, 50));
                }
                
                if (!name) {
                    alert('请输入姓名');
                    return;
                }
                
                if (characterId) {
                    console.log('=== 更新现有角色 ===');
                    // 更新现有角色
                    const index = characters.findIndex(c => c.id === characterId);
                    if (index !== -1) {
                        const oldAvatarUrl = characters[index].avatarUrl;
                        
                        characters[index] = {
                            ...characters[index],
                            name,
                            bio,
                            avatarUrl: avatarData || characters[index].avatarUrl || '',
                            color: characters[index].color || getRandomColor()
                        };
                        
                        console.log('更新角色完成:', characters[index]);
                        
                        // 🔥【修复1】如果头像发生了变化，更新所有相关群聊中的成员头像
                        if (avatarData && avatarData !== oldAvatarUrl) {
                            updateCharacterAvatarInGroups(characterId, avatarData);
                        }
                        
                        // 保存并更新界面
                        await saveCharacters();
                        renderContactList();
                        renderMessageList();
                        
                        // 🔥【修复2】如果当前正在聊天且是该角色，刷新聊天界面
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            renderChatMessages(currentChatCharacter.id);
                        }
                        
                        showToast(`角色 "${name}" 已更新！`, 'success');
                        hideCharacterForm();
                        // 注意：不立即清空表单，让用户能看到保存成功的状态
                    }
                } else {
                    console.log('=== 创建新角色 ===');
                    // 创建新角色
                    const newCharacter = {
                        id: Date.now().toString(),
                        name,
                        bio,
                        avatarUrl: avatarData || '',
                        color: getRandomColor(),
                        groupId: 'my_friends' // 新角色默认放入"我的好友"分组
                    };
                    
                    console.log('创建新角色:', newCharacter);
                    console.log('新角色头像URL:', newCharacter.avatarUrl);
                    console.log('新角色头像URL长度:', newCharacter.avatarUrl ? newCharacter.avatarUrl.length : 0);
                    
                    console.log('添加角色前，当前角色数组长度:', characters.length);
                    characters.push(newCharacter);
                    console.log('添加角色后，当前角色数组长度:', characters.length);
                    
                    console.log('角色数组最新状态:', characters);
                    
                    // 🔥【修复】不再自动添加到联系人列表，用户需要通过创建对话来建立联系
                    
                    // 保存并更新界面
                    console.log('开始保存到IndexedDB...');
                    await saveCharacters();
                    console.log('保存后检查角色数组:', characters);
                    
                    console.log('开始渲染界面...');
                    renderContactList();
                    renderMessageList();
                    
                    console.log('开始隐藏表单...');
                    hideCharacterForm();
                    // 注意：不立即清空表单，让用户能看到保存成功的状态
                    
                    // 给用户反馈
                    showToast(`角色 "${newCharacter.name}" 创建成功！`, 'success');
                    
                    console.log('=== 保存角色完成 ===');
                }
            } catch (error) {
                console.error('保存角色时发生错误:', error);
                alert('保存角色时发生错误: ' + error.message);
            }
        }
        
        // 清空角色表单
        function clearCharacterForm() {
            console.log('清空角色表单被调用');
            document.getElementById('character-name').value = '';
            document.getElementById('character-bio').value = '';
            document.getElementById('avatar-upload').value = '';
            
            const avatarPreview = document.getElementById('avatar-preview');
            const avatarPreviewText = document.getElementById('avatar-preview-text');
            
            // 重置头像预览
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            if (avatarPreviewText) {
                avatarPreviewText.style.display = 'block';
                avatarPreviewText.textContent = 'A';
            }
            
            // 清除临时存储的头像数据
            console.log('清除临时头像数据');
            window.selectedAvatarData = null;
        }
        
        // 编辑角色
        function editCharacter(characterId) {
            showCharacterForm(characterId);
        }
        
        // 从联系人列表编辑角色
        function editCharacterFromContactList(characterId) {
            showCharacterForm(characterId);
        }
        
        // 进入多选模式
        function enterMultiSelectMode(characterId) {
            isMultiSelectMode = true;
            selectedCharacters = [characterId]; // 初始选中触发长按的角色
            renderContactList();
        }
        
        // 退出多选模式
        function exitMultiSelectMode() {
            isMultiSelectMode = false;
            selectedCharacters = [];
            renderContactList();
        }
        
        // 切换角色选择状态
        function toggleCharacterSelection(characterId) {
            const index = selectedCharacters.indexOf(characterId);
            if (index > -1) {
                selectedCharacters.splice(index, 1);
            } else {
                selectedCharacters.push(characterId);
            }
            renderContactList();
        }
        
        // 删除选中的角色
        async function deleteSelectedCharacters() {
            if (selectedCharacters.length === 0) {
                alert('请先选择要删除的角色');
                return;
            }
            
            const characterNames = selectedCharacters.map(id => {
                const character = characters.find(c => c.id === id);
                return character ? character.name : '';
            }).filter(name => name).join('、');
            
            if (confirm(`确定要删除这些角色吗？\n${characterNames}\n\n此操作不可恢复！`)) {
                // 删除角色
                selectedCharacters.forEach(characterId => {
                    characters = characters.filter(c => c.id !== characterId);
                    contacts = contacts.filter(c => c !== characterId);
                    
                    // 删除相关聊天记录
                    if (chatMessages[characterId]) {
                        delete chatMessages[characterId];
                    }
                });
                
                // 保存数据
                await saveCharacters();
                await saveContacts();
                await saveChatMessages();
                
                // 退出多选模式并更新界面
                exitMultiSelectMode();
                renderMessageList();
                
                alert('角色删除成功');
            }
        }
        
        // 删除当前编辑的角色
        async function deleteCurrentCharacter() {
            if (currentEditingCharacterId) {
                const character = characters.find(c => c.id === currentEditingCharacterId);
                
                if (character && confirm(`确定要删除角色"${character.name}"吗？\n\n此操作将删除角色数据、聊天记录和所有设置，不可恢复！`)) {
                    // 删除角色
                    characters = characters.filter(c => c.id !== character.id);
                    contacts = contacts.filter(c => c !== character.id);
                    
                    // 删除相关聊天记录
                    if (chatMessages[character.id]) {
                        delete chatMessages[character.id];
                    }
                    
                    // [核心修复] 删除聊天设置
                    try {
                        // 从数据库中删除设置
                        await db.chatSettings.delete(character.id);
                        // 从内存中删除设置
                        if (chatSettings[character.id]) {
                            delete chatSettings[character.id];
                        }
                        // 删除localStorage中的备份设置
                        localStorage.removeItem(`chatSettings_${character.id}`);
                        console.log(`✅ 已删除角色 ${character.name} 的聊天设置`);
                    } catch (error) {
                        console.error(`删除角色 ${character.name} 的聊天设置失败:`, error);
                    }
                    
                    // 保存数据
                    await saveCharacters();
                    await saveContacts();
                    await saveChatMessages();
                    
                    // 更新界面并返回
                    renderContactList();
                    renderMessageList();
                    hideCharacterForm();
                    
                    showToast(`角色 ${character.name} 已成功删除`, 'success');
                }
            }
        }
        
        // 🔥【新增】更新角色在所有群聊中的头像
        function updateCharacterAvatarInGroups(characterId, newAvatarUrl) {
            // 遍历所有角色，找到群聊
            characters.forEach(character => {
                if (character.isGroup && character.members) {
                    // 在该群聊中查找对应的成员
                    const memberIndex = character.members.findIndex(member => member.id === characterId);
                    if (memberIndex !== -1) {
                        // 更新该成员的头像
                        character.members[memberIndex].avatarUrl = newAvatarUrl;
                        console.log(`已更新群聊 "${character.name}" 中成员 "${character.members[memberIndex].name}" 的头像`);
                    }
                }
            });
            
            // 保存更新后的角色数据
            saveCharacters();
        }
        
        // 获取随机颜色
        function getRandomColor() {
            const colors = ['#FF3B30', '#FF9500', '#FFCC00', '#34C759', '#5AC8FA', '#007AFF', '#5856D6', '#AF52DE'];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // 显示添加联系人模态框
        function showAddContactModal() {
            showCharacterForm(); // 直接显示创建角色表单
        }
        
        // 添加选中的联系人
        async function addSelectedContacts() {
            const checkboxes = document.querySelectorAll('.contact-checkbox:checked');
            checkboxes.forEach(checkbox => {
                const characterId = checkbox.value;
                if (!contacts.includes(characterId)) {
                    contacts.push(characterId);
                }
            });
            
            await saveContacts();
            renderMessageList();
            renderContactList();
            hideModal('add-contact-modal');
        }
        
        // 开始与角色聊天
async function startChat(character) {
    // [核心修复] 记录上一个聊天ID，用于清理
    const previousChatId = currentChatCharacter ? currentChatCharacter.id : null;
    
    // 设置当前聊天角色
            currentChatCharacter = character;
            
    // 🔥【修复】异步获取聊天设置
    const chatSettings = await getAsyncChatSettings();
            const displayTitle = chatSettings.aiChatNickname || character.name;
            document.getElementById('api-chat-title').textContent = displayTitle;
            
            // 🔥【新增】渲染角色状态显示
            const headerContainer = document.querySelector('#api-chat-screen .header');
            if (headerContainer) {
                renderCharacterStatus(character.id, headerContainer);
            }
            
            // 🔥【新增】更新心率显示
            updateAiHeartrate();
                
                // 🔥【新增】立即为这个角色生成一个初始状态（如果还没有的话）
                setTimeout(async () => {
                    const currentStatus = getCharacterStatus(character.id);
                    if (!currentStatus.activity || currentStatus.activity === '在线') {
                        await generateCharacterStatus(character.id);
                        // 刷新状态显示
                        renderCharacterStatus(character.id, headerContainer);
                    }
                }, 500);
            
            // 🔥【新增】启动状态更新定时器
            startCharacterStatusTimer();
            
            // 初始化空的聊天记录（不自动发送消息）
            if (!chatMessages[character.id]) {
                chatMessages[character.id] = [];
                saveChatMessages();
            }
            
            // 重置悬浮按钮状态
            resetFloatingButtonsState();
            
            // 🔥【新增】检查拉黑状态并更新界面
            updateChatBlockedStatus();
            
            // 🔥【新增】如果设置界面是打开的，更新设置显示状态
            if (document.getElementById('api-chat-settings-screen').style.display === 'flex') {
                updateChatSettingsDisplay();
            }
    
    // 重置聊天屏幕背景
    const chatScreen = document.getElementById('api-chat-screen');
    if (chatScreen) {
        // 先重置所有背景样式
        chatScreen.style.backgroundImage = 'none';
        chatScreen.style.backgroundColor = 'white';
        
        const messagesContainer = document.getElementById('api-chat-messages');
        if (messagesContainer) messagesContainer.style.background = '';
    }
    
    // 记录切换
    console.log(`🔄 切换到聊天: ${character.name} (ID: ${character.id})`);
    
    // 【关键修复】每次进入聊天时，调用 applyChatBackground 来确保背景正确
    // 不传递参数，让函数自己从角色对象中读取
    await applyChatBackground();
            
            // 初始化后台互动系统
            initBackgroundInteractionSystem();
            
            // 初始化定时发布系统
            initScheduledMomentsSystem();
            
            renderChatMessages(character.id);
            showApp('api-chat-screen');
        }
        
        // 从聊天界面返回到聊天应用
        function backToChatApp() {
            // 清除当前角色的后台定时器
            clearAllBackgroundTimers();
            // 🔥【新增】清除状态更新定时器
            clearCharacterStatusTimer();
            // 隐藏心率显示
            hideAiHeartrate();
            hideApp('api-chat-screen');
            showApp('chat-screen');
        }
        
        // 从设置子页面返回到设置主页面
        function backToSettings(currentScreen) {
            hideApp(currentScreen);
            showApp('settings-screen');
        }
        

        
        // 显示正在输入提示
        function showTypingIndicator() {
            console.log('🔧 尝试显示正在输入提示...');
            let indicator = document.getElementById('typing-indicator');
            
            // 如果没有找到元素，尝试创建一个
            if (!indicator) {
                console.log('⚠️ 未找到typing-indicator元素，正在创建...');
                const messagesContainer = document.getElementById('api-chat-messages');
                if (messagesContainer) {
                    indicator = document.createElement('div');
                    indicator.id = 'typing-indicator';
                    indicator.className = 'typing-indicator';
                    
                    // 获取当前角色名称
                    const chatSettings = getCurrentChatSettings();
                    const characterName = chatSettings.aiChatNickname || (currentChatCharacter ? currentChatCharacter.name : '对方');
                    
                    indicator.innerHTML = `${characterName}正在输入中<span class="dots"></span>`;
                    messagesContainer.appendChild(indicator);
                    console.log('✅ 已创建typing-indicator元素');
                } else {
                    console.error('❌ 找不到消息容器，无法创建typing-indicator');
                    return;
                }
            }
            
            if (indicator) {
                console.log('✅ 显示正在输入提示');
                indicator.classList.add('show');
                // 滚动到底部显示提示
                const messagesContainer = document.getElementById('api-chat-messages');
                if (messagesContainer) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }
            } else {
                console.error('❌ 仍然找不到typing-indicator元素');
            }
        }
        
        // 隐藏正在输入提示
        function hideTypingIndicator() {
            console.log('🔧 尝试隐藏正在输入提示...');
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                console.log('✅ 隐藏正在输入提示');
                indicator.classList.remove('show');
            } else {
                console.log('⚠️ 未找到typing-indicator元素，可能已被移除');
            }
        }
        
        // 🔥【新增】添加系统消息到聊天界面（不重新渲染整个列表）
        function addSystemMessageToChat(systemMessage) {
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;
            
            // 创建外层容器，用于居中
            const centerContainer = document.createElement('div');
            centerContainer.style.display = 'flex';
            centerContainer.style.justifyContent = 'center';
            centerContainer.style.margin = '4px 0';
            
            // 创建系统消息容器
            const systemContainer = document.createElement('div');
            systemContainer.className = 'system-message';
            systemContainer.textContent = systemMessage.content;
            
            // 将系统消息放入居中容器
            centerContainer.appendChild(systemContainer);
            
            // 插入到消息容器的最后（正在输入提示之前）
            const typingIndicator = messagesContainer.querySelector('#typing-indicator');
            if (typingIndicator) {
                messagesContainer.insertBefore(centerContainer, typingIndicator);
            } else {
                messagesContainer.appendChild(centerContainer);
            }
            
            // 滚动到底部
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }

        // 角色卡导入功能
        function importCharacterCard() {
            // 防止重复调用
            if (window.isImporting) {
                console.log('正在导入中，忽略重复调用');
                return;
            }
            window.isImporting = true;
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.png,.json';
            input.onchange = async (e) => {
                try {
                    const file = e.target.files[0];
                    if (!file) {
                        window.isImporting = false;
                        return;
                    }
                    
                    console.log('开始导入文件:', file.name, '类型:', file.type);
                    
                    let characterData = null;
                    
                    if (file.type === 'image/png') {
                        // 从PNG图片中读取角色卡数据
                        characterData = await extractCharacterFromPNG(file);
                        
                        // 🔥【新增】如果PNG中没有头像数据，使用PNG文件本身作为头像
                        if (characterData && (!characterData.avatarUrl || characterData.avatarUrl === 'none' || characterData.avatarUrl === '' || characterData.avatarUrl === 'undefined')) {
                            console.log('🖼️ PNG中没有头像数据，使用PNG文件本身作为头像');
                            const reader = new FileReader();
                            const pngAsAvatar = await new Promise((resolve) => {
                                reader.onload = (e) => resolve(e.target.result);
                                reader.readAsDataURL(file);
                            });
                            characterData.avatarUrl = pngAsAvatar;
                            characterData.usePngAsAvatar = true; // 标记这是PNG本身
                            console.log('🖼️ PNG头像设置完成');
                        }
                    } else if (file.type === 'application/json' || file.name.endsWith('.json')) {
                        // 从JSON文件中读取角色卡数据
                        const text = await file.text();
                        characterData = JSON.parse(text);
                    }
                    
                    if (characterData) {
                        // 填充表单数据
                        if (characterData.name) {
                            document.getElementById('character-name').value = characterData.name;
                        }
                        if (characterData.bio || characterData.description) {
                            document.getElementById('character-bio').value = characterData.bio || characterData.description;
                        }
                        
                        // 处理头像
                        const avatarData = characterData.avatarUrl || characterData.avatar;
                        if (avatarData && avatarData !== 'none' && avatarData !== '' && avatarData !== 'null') {
                            console.log('处理头像数据:', avatarData.substring(0, 100) + '...');
                            
                            const avatarPreview = document.getElementById('avatar-preview');
                            const avatarPreviewText = document.getElementById('avatar-preview-text');
                            
                            if (avatarPreview && avatarPreviewText) {
                                console.log('🖼️ 开始设置头像，数据长度:', avatarData.length);
                                
                                // 检查是否可能是Base64编码的图片数据
                                let processedAvatarData = avatarData;
                                
                                // 如果是长字符串且不包含协议，可能是Base64
                                if (avatarData.length > 100 && !avatarData.startsWith('http') && !avatarData.startsWith('data:')) {
                                    console.log('🖼️ 检测到可能的Base64数据，尝试添加前缀...');
                                    // 尝试检测图片格式
                                    try {
                                        const firstBytes = atob(avatarData.substring(0, 32));
                                        const header = firstBytes.substring(0, 4);
                                        if (header.startsWith('\x89PNG')) {
                                            processedAvatarData = `data:image/png;base64,${avatarData}`;
                                            console.log('🖼️ 检测为PNG格式');
                                        } else if (header.startsWith('\xFF\xD8\xFF')) {
                                            processedAvatarData = `data:image/jpeg;base64,${avatarData}`;
                                            console.log('🖼️ 检测为JPEG格式');
                                        }
                                    } catch (e) {
                                        console.log('🖼️ Base64检测失败:', e);
                                    }
                                }
                                
                                // 更宽松的头像格式检查
                                if (processedAvatarData.startsWith('data:image/') || 
                                    processedAvatarData.startsWith('http') || 
                                    processedAvatarData.includes('.jpg') || 
                                    processedAvatarData.includes('.png') || 
                                    processedAvatarData.includes('.gif') ||
                                    processedAvatarData.includes('.jpeg') ||
                                    processedAvatarData.length > 100) { // 长字符串可能是Base64
                                    
                                    try {
                                        avatarPreview.classList.add('has-image');
                                        avatarPreview.style.setProperty('background-image', `url("${processedAvatarData}")`, 'important');
                                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                                        avatarPreviewText.style.display = 'none';
                                        window.selectedAvatarData = processedAvatarData;
                                        console.log('头像设置成功');
                                    } catch (e) {
                                        console.log('头像设置失败:', e);
                                        showToast('头像导入失败，但角色信息已导入', 'warning');
                                    }
                                } else {
                                    console.log('头像数据格式不支持，原始数据:', avatarData);
                                    showToast('头像格式不支持，请手动上传头像', 'warning');
                                }
                            } else {
                                console.log('头像预览元素不存在');
                            }
                        } else {
                            console.log('头像数据为空或无效:', avatarData);
                        }
                        
                        // 处理世界书数据
                        if (characterData.worldBooks && characterData.worldBooks.length > 0) {
                            console.log('开始导入世界书数据...');
                            await importWorldBooks(characterData.worldBooks, characterData.name);
                        } else {
                            console.log('📚 没有检测到世界书数据，跳过世界书导入');
                        }
                        
                        const successMsg = '角色卡导入成功！' + 
                            (characterData.usePngAsAvatar ? ' 已使用PNG图片作为头像。' : '') +
                            (characterData.worldBooks && characterData.worldBooks.length > 0 ? `（包含${characterData.worldBooks.length}个世界书）` : '');
                        showToast(successMsg, 'success');
                    }
                } catch (error) {
                    console.error('导入角色卡失败:', error);
                    showToast('导入角色卡失败，请检查文件格式', 'error');
                } finally {
                    window.isImporting = false;
                }
            };
            
            input.click();
        }
        
        // 角色卡导出功能
        function exportCharacterCard() {
            if (!currentEditingCharacterId) {
                showToast('请先保存角色再导出', 'error');
                return;
            }
            
            const character = characters.find(c => c.id === currentEditingCharacterId);
            if (!character) {
                showToast('找不到要导出的角色', 'error');
                return;
            }
            
            // 显示导出选项
            showExportOptions(character);
        }
        
        // 显示导出选项对话框
        function showExportOptions(character) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 class="modal-title">导出角色卡</h3>
                        <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p>请选择导出格式：</p>
                        <div style="margin: 15px 0;">
                            <button class="modal-button modal-primary" onclick="exportAsJSON('${character.id}'); this.closest('.modal').remove();" style="margin-right: 10px;">
                                <i class="fas fa-file-code"></i> JSON格式
                            </button>
                            <button class="modal-button modal-secondary" onclick="exportAsPNG('${character.id}'); this.closest('.modal').remove();">
                                <i class="fas fa-image"></i> PNG格式
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // 点击背景关闭
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }
        
        // 导出为JSON格式
        function exportAsJSON(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            const characterData = {
                name: character.name,
                bio: character.bio,
                avatarUrl: character.avatarUrl,
                color: character.color,
                exportTime: new Date().toISOString(),
                version: '1.0'
            };
            
            const blob = new Blob([JSON.stringify(characterData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${character.name}_角色卡.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('JSON格式角色卡导出成功', 'success');
        }
        
        // 导出为PNG格式
        async function exportAsPNG(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            try {
                // 创建包含角色数据的PNG图片
                const characterData = {
                    name: character.name,
                    bio: character.bio,
                    avatarUrl: character.avatarUrl,
                    color: character.color,
                    exportTime: new Date().toISOString(),
                    version: '1.0'
                };
                
                // 创建画布来生成PNG
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 400;
                canvas.height = 300;
                
                // 绘制背景
                ctx.fillStyle = character.color || '#007AFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制角色信息
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(character.name, canvas.width / 2, 50);
                
                ctx.font = '16px Arial';
                ctx.fillText('角色卡', canvas.width / 2, 80);
                
                // 绘制头像（如果有）
                if (character.avatarUrl) {
                    try {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = character.avatarUrl;
                        });
                        
                        // 绘制圆形头像
                        const avatarSize = 100;
                        const avatarX = (canvas.width - avatarSize) / 2;
                        const avatarY = 120;
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(avatarX + avatarSize/2, avatarY + avatarSize/2, avatarSize/2, 0, Math.PI * 2);
                        ctx.clip();
                        ctx.drawImage(img, avatarX, avatarY, avatarSize, avatarSize);
                        ctx.restore();
                    } catch (error) {
                        console.log('无法绘制头像:', error);
                    }
                }
                
                // 将角色数据嵌入到PNG的元数据中
                const canvasBlob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                const pngWithMetadata = await embedDataInPNG(canvasBlob, characterData);
                
                // 下载文件
                const url = URL.createObjectURL(pngWithMetadata);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${character.name}_角色卡.png`;
                a.click();
                URL.revokeObjectURL(url);
                
                showToast('PNG格式角色卡导出成功', 'success');
            } catch (error) {
                console.error('PNG导出失败:', error);
                showToast('PNG导出失败', 'error');
            }
        }
        
        // 导入世界书数据
        async function importWorldBooks(worldBooks, characterName) {
            try {
                let importedCount = 0;
                
                for (const worldBook of worldBooks) {
                    // 创建世界书对象，使用更好的分类命名
                    const worldBookObj = {
                        id: Date.now() + Math.random(),
                        name: `[${characterName}] ${worldBook.name}`,
                        content: worldBook.content,
                        category: characterName, // 添加分类字段
                        source: 'character_card', // 来源标记
                        createdAt: Date.now(),
                        updatedAt: Date.now()
                    };
                    
                    // 保存到数据库
                    try {
                        await db.worldbooks.add(worldBookObj);
                        console.log('📚 世界书导入成功:', worldBookObj.name);
                        importedCount++;
                    } catch (error) {
                        console.error('📚 世界书保存失败:', error);
                    }
                }
                
                if (importedCount > 0) {
                    showToast(`成功导入${importedCount}个世界书到"${characterName}"分类`, 'success');
                } else {
                    console.log('📚 没有成功导入任何世界书');
                }
            } catch (error) {
                console.error('世界书导入过程出错:', error);
                showToast('世界书导入失败', 'error');
            }
        }
        
        // 在PNG中嵌入数据
        async function embedDataInPNG(blob, data) {
            const arrayBuffer = await blob.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // 简单的实现：将JSON数据作为注释块添加到PNG末尾
            const jsonString = JSON.stringify(data);
            const textEncoder = new TextEncoder();
            const jsonBytes = textEncoder.encode(jsonString);
            
            // 创建一个包含原始PNG和JSON数据的新数组
            const newArray = new Uint8Array(uint8Array.length + jsonBytes.length + 8);
            newArray.set(uint8Array);
            
            // 添加标记和数据长度
            const marker = textEncoder.encode('CHRD'); // 角色数据标记
            newArray.set(marker, uint8Array.length);
            
            // 添加数据长度（4字节）
            const dataView = new DataView(newArray.buffer);
            dataView.setUint32(uint8Array.length + 4, jsonBytes.length, true);
            
            // 添加JSON数据
            newArray.set(jsonBytes, uint8Array.length + 8);
            
            return new Blob([newArray], { type: 'image/png' });
        }
        
        // 从PNG中提取角色数据
        async function extractCharacterFromPNG(file) {
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            console.log('开始解析PNG文件，文件大小:', uint8Array.length);
            
            // 尝试多种常见的角色卡格式
            
            // 1. 尝试我们的自定义格式 (CHRD标记)
            const textEncoder = new TextEncoder();
            const marker = textEncoder.encode('CHRD');
            
            for (let i = 0; i < uint8Array.length - marker.length - 4; i++) {
                let found = true;
                for (let j = 0; j < marker.length; j++) {
                    if (uint8Array[i + j] !== marker[j]) {
                        found = false;
                        break;
                    }
                }
                
                if (found) {
                    console.log('找到CHRD标记，提取数据...');
                    // 读取数据长度
                    const dataView = new DataView(uint8Array.buffer);
                    const dataLength = dataView.getUint32(i + marker.length, true);
                    
                    // 提取JSON数据
                    const jsonStart = i + marker.length + 4;
                    const jsonBytes = uint8Array.slice(jsonStart, jsonStart + dataLength);
                    const textDecoder = new TextDecoder();
                    const jsonString = textDecoder.decode(jsonBytes);
                    
                    return JSON.parse(jsonString);
                }
            }
            
            // 2. 尝试CharacterAI格式 (在tEXt块中查找chara字段)
            console.log('未找到CHRD标记，尝试解析PNG tEXt块...');
            try {
                const textData = extractPNGTextChunks(uint8Array);
                console.log('找到的PNG文本块:', Object.keys(textData));
                
                // 查找chara字段
                if (textData.chara) {
                    console.log('找到chara字段，解析数据...');
                    try {
                        const characterData = JSON.parse(textData.chara);
                        return convertCharacterAIFormat(characterData);
                    } catch (e) {
                        console.log('chara字段JSON解析失败，尝试base64解码...');
                        try {
                            // 使用更好的base64解码方法
                            const decoded = decodeBase64Text(textData.chara);
                            const characterData = JSON.parse(decoded);
                            return convertCharacterAIFormat(characterData);
                        } catch (e2) {
                            console.log('base64解码也失败:', e2);
                        }
                    }
                }
                
                // 查找其他可能的字段
                for (const [key, value] of Object.entries(textData)) {
                    if (key.toLowerCase().includes('character') || key.toLowerCase().includes('card')) {
                        console.log(`尝试解析字段 ${key}:`, value.substring(0, 100));
                                                 try {
                             const characterData = JSON.parse(value);
                             return convertCharacterAIFormat(characterData);
                         } catch (e) {
                             try {
                                 const decoded = decodeBase64Text(value);
                                 const characterData = JSON.parse(decoded);
                                 return convertCharacterAIFormat(characterData);
                             } catch (e2) {
                                 console.log(`字段 ${key} 解析失败`);
                             }
                         }
                    }
                }
            } catch (e) {
                console.log('PNG文本块解析失败:', e);
            }
            
            throw new Error('在PNG文件中未找到角色数据');
        }
        
        // 提取PNG文件的tEXt块
        function extractPNGTextChunks(uint8Array) {
            const textChunks = {};
            let offset = 8; // 跳过PNG签名
            
            while (offset < uint8Array.length) {
                if (offset + 8 > uint8Array.length) break;
                
                // 读取块长度
                const length = new DataView(uint8Array.buffer).getUint32(offset, false);
                offset += 4;
                
                // 读取块类型
                const type = new TextDecoder().decode(uint8Array.slice(offset, offset + 4));
                offset += 4;
                
                                 if (type === 'tEXt') {
                     // 提取tEXt块数据
                     const data = uint8Array.slice(offset, offset + length);
                     const nullIndex = data.indexOf(0);
                     if (nullIndex !== -1) {
                         const keyword = new TextDecoder('utf-8').decode(data.slice(0, nullIndex));
                         // 尝试多种编码方式
                         let text;
                         try {
                             text = new TextDecoder('utf-8').decode(data.slice(nullIndex + 1));
                         } catch (e) {
                             try {
                                 text = new TextDecoder('latin1').decode(data.slice(nullIndex + 1));
                             } catch (e2) {
                                 text = new TextDecoder('ascii').decode(data.slice(nullIndex + 1));
                             }
                         }
                         textChunks[keyword] = text;
                         console.log(`找到tEXt块: ${keyword} = ${text.substring(0, 100)}...`);
                     }
                 } else if (type === 'zTXt') {
                    // 处理压缩的文本块
                    console.log('发现zTXt块，暂不支持压缩文本解析');
                }
                
                // 移动到下一个块
                offset += length + 4; // +4 for CRC
                
                if (type === 'IEND') break;
            }
            
            return textChunks;
        }
        
        // 更好的Base64解码函数，支持UTF-8
        function decodeBase64Text(base64String) {
            try {
                // 方法1：直接atob然后UTF-8解码
                const binaryString = atob(base64String);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return new TextDecoder('utf-8').decode(bytes);
            } catch (e) {
                console.log('UTF-8解码失败，尝试直接atob:', e);
                try {
                    return atob(base64String);
                } catch (e2) {
                    console.log('Base64解码完全失败:', e2);
                    throw e2;
                }
            }
        }
        
        // 转换CharacterAI格式到我们的格式
        function convertCharacterAIFormat(data) {
            console.log('🔧 转换CharacterAI格式数据:', data);
            console.log('🔧 原始数据字段:', Object.keys(data));
            
            // 清理文本内容，处理可能的编码问题
            function cleanText(text) {
                if (!text) return '';
                // 尝试修复常见的编码问题
                return text.replace(/\ufffd/g, '').trim();
            }
            
            // 处理头像数据
            function processAvatar(avatarData) {
                if (!avatarData || avatarData === 'none' || avatarData === '' || avatarData === 'null') {
                    console.log('头像数据为空或无效:', avatarData);
                    return '';
                }
                
                console.log('🖼️ 原始头像数据类型:', typeof avatarData, '长度:', avatarData.length);
                console.log('🖼️ 头像数据前100字符:', avatarData.substring(0, 100));
                
                // 如果已经是有效的URL或Base64，直接返回
                if (avatarData.startsWith('data:image/') || avatarData.startsWith('http')) {
                    return avatarData;
                }
                
                // 尝试Base64解码并检查是否是图片
                try {
                    // 检查是否是纯Base64编码的图片
                    if (avatarData.length > 100 && !avatarData.includes(' ') && !avatarData.includes('\n')) {
                        // 尝试解码前几个字节来检查文件头
                        const binaryString = atob(avatarData.substring(0, 32));
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        
                        // 检查常见的图片文件头
                        const header = Array.from(bytes.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join('');
                        
                        if (header.startsWith('89504e47')) { // PNG
                            return `data:image/png;base64,${avatarData}`;
                        } else if (header.startsWith('ffd8ff')) { // JPEG
                            return `data:image/jpeg;base64,${avatarData}`;
                        } else if (header.startsWith('47494638')) { // GIF
                            return `data:image/gif;base64,${avatarData}`;
                        } else if (header.startsWith('424d')) { // BMP
                            return `data:image/bmp;base64,${avatarData}`;
                        } else if (header.includes('57454250')) { // WEBP
                            return `data:image/webp;base64,${avatarData}`;
                        }
                    }
                } catch (e) {
                    console.log('Base64解码失败:', e);
                }
                
                // 如果是相对路径或其他格式，尝试转换
                if (avatarData.includes('.jpg') || avatarData.includes('.png') || 
                    avatarData.includes('.gif') || avatarData.includes('.jpeg') ||
                    avatarData.includes('.webp') || avatarData.includes('.bmp')) {
                    console.log('检测到可能的图片文件名:', avatarData);
                    return avatarData;
                }
                
                console.log('无法识别头像格式，原始数据前100字符:', avatarData.substring(0, 100));
                return avatarData;
            }
            
            // 提取世界书/背景故事数据
            function extractWorldBook(data) {
                console.log('📚 开始检查世界书数据...');
                const worldBookData = [];
                
                // 查找可能的世界书字段
                const worldBookFields = [
                    'world_scenario', 'scenario', 'world', 'background', 
                    'setting', 'lore', 'worldbook', 'world_book',
                    'mes_example', 'example_dialogue', 'example'
                ];
                
                worldBookFields.forEach(field => {
                    if (data[field] && typeof data[field] === 'string' && data[field].trim()) {
                        const content = cleanText(data[field]);
                        if (content.length > 20) { // 只有足够长的内容才作为世界书
                            const worldBookItem = {
                                name: field === 'scenario' ? '背景故事' : 
                                      field === 'mes_example' ? '对话示例' :
                                      field === 'example_dialogue' ? '对话示例' :
                                      field === 'world' ? '世界设定' :
                                      field === 'setting' ? '场景设定' :
                                      field === 'lore' ? '背景知识' : field,
                                content: content
                            };
                            worldBookData.push(worldBookItem);
                            console.log(`✅ 找到世界书: ${worldBookItem.name} (${content.length}字符)`);
                        }
                    }
                });
                
                if (worldBookData.length === 0) {
                    console.log('📚 未找到任何世界书数据');
                } else {
                    console.log(`📚 共找到 ${worldBookData.length} 个世界书条目`);
                }
                return worldBookData;
            }
            
            const characterData = {
                name: cleanText(data.name || data.char_name || '未知角色'),
                bio: cleanText(data.description || data.char_persona || data.personality || ''),
                prompt: cleanText(data.description || data.char_persona || data.personality || ''),
                avatarUrl: processAvatar(data.avatar || data.char_image || ''),
                color: '#007AFF', // 默认颜色
                // 保留原始数据以供参考
                originalData: data
            };
            
            // 添加世界书数据
            const worldBooks = extractWorldBook(data);
            if (worldBooks.length > 0) {
                characterData.worldBooks = worldBooks;
                console.log('提取到世界书数据:', worldBooks);
            }
            
            return characterData;
        }

        // 🔥【新增】处理AI撤回消息功能
        async function handleRecalledMessage(messageContent, targetMessageId = null) {
            if (!currentChatCharacter) return;
            
            console.log('处理撤回消息:', messageContent, '目标消息ID:', targetMessageId);
            
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer) return;
            
            const character = characters.find(c => c.id === currentChatCharacter.id);
            const chatSettings = getCurrentChatSettings();
            const displayName = chatSettings.aiChatNickname || character.name;
            
            let messageContainer = null;
            
            // 如果提供了目标消息ID，查找并撤回现有消息
            if (targetMessageId) {
                messageContainer = messagesContainer.querySelector(`[data-message-id="${targetMessageId}"]`);
                if (messageContainer) {
                    console.log('找到要撤回的现有消息，准备撤回');
                    
                    // 等待1.2秒后撤回
                    await new Promise(resolve => setTimeout(resolve, 1200));
                    
                    // 添加淡出动画
                    messageContainer.style.animation = 'fadeOut 0.5s ease-in-out forwards';
                    
                    // 等待动画完成
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // 从聊天记录中移除这条消息
                    if (chatMessages[currentChatCharacter.id]) {
                        const messageIndex = chatMessages[currentChatCharacter.id].findIndex(msg => msg.id === targetMessageId);
                        if (messageIndex !== -1) {
                            chatMessages[currentChatCharacter.id].splice(messageIndex, 1);
                            saveChatMessages();
                        }
                    }
                } else {
                    console.warn('未找到要撤回的消息，创建临时消息');
                    // 如果找不到消息，回退到创建临时消息的方式
                    messageContainer = await createTemporaryMessage(messageContent);
                }
            } else {
                // 没有提供目标ID，创建临时消息
                messageContainer = await createTemporaryMessage(messageContent);
            }
            
            if (!messageContainer) return;
            
            // 创建撤回提醒的居中容器
            const centerContainer = document.createElement('div');
            centerContainer.style.display = 'flex';
            centerContainer.style.justifyContent = 'center';
            centerContainer.style.margin = '4px 0';
            
            // 创建撤回消息元素
            const recallElement = document.createElement('div');
            recallElement.className = 'recalled-message';
            
            // 主要提醒文字
            const mainText = document.createElement('div');
            mainText.style.marginBottom = '2px';
            mainText.textContent = `${displayName} 撤回了一条消息`;
            
            // 原文显示
            const originalText = document.createElement('div');
            originalText.className = 'original-text';
            originalText.textContent = `原文：${messageContent}`;
            
            recallElement.appendChild(mainText);
            recallElement.appendChild(originalText);
            centerContainer.appendChild(recallElement);
            
            // 在原消息位置替换为撤回提醒
            messageContainer.parentNode.insertBefore(centerContainer, messageContainer);
            messageContainer.remove();
            
            // 添加撤回消息到聊天历史
            const recalledMessage = {
                id: `recalled_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                sender: 'system',
                type: 'recalled_message',
                content: `${displayName} 撤回了一条消息\n原文：${messageContent}`,
                originalContent: messageContent,
                    timestamp: Date.now()
                };
                
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(recalledMessage);
                saveChatMessages();
            
            // 滚动到底部
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // 创建临时消息的辅助函数
            async function createTemporaryMessage(content) {
                const messageId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                const tempContainer = document.createElement('div');
                const isEmojiOnly = false;
                tempContainer.className = `message-container received${isEmojiOnly ? ' emoji-only' : ''}`;
                tempContainer.dataset.messageId = messageId;
                
                const bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                const bubblePadding = chatSettings.bubblePadding || '12';
                const displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                
                let avatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    avatarHtml = `
                        <div class="message-avatar" style="background-color: ${character.color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" onclick="pokeCharacter('${character.id}')" title="戳一戳">
                            ${displayAvatar ? '' : displayName.charAt(0)}
                        </div>
                    `;
                }
                
                // 将透明度应用到背景色而不是整个元素
                const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                
                let bubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                        ${content}
                    </div>
                `;
                
                tempContainer.innerHTML = avatarHtml + bubbleHtml;
                
                // 添加到消息容器
                const typingIndicator = messagesContainer.querySelector('#typing-indicator');
                if (typingIndicator) {
                    messagesContainer.insertBefore(tempContainer, typingIndicator);
                } else {
                    messagesContainer.appendChild(tempContainer);
                }
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                // 等待1.2秒后撤回
                await new Promise(resolve => setTimeout(resolve, 1200));
                
                // 添加淡出动画
                tempContainer.style.animation = 'fadeOut 0.5s ease-in-out forwards';
                
                // 等待动画完成
                await new Promise(resolve => setTimeout(resolve, 500));
                
                return tempContainer;
            }
        }
        
        // 🔥【新增】获取用户最近发送的图片URL
        function getRecentUserImage() {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                return null;
            }
            
            const messages = chatMessages[currentChatCharacter.id];
            // 从最新消息开始向前查找用户发送的图片
            for (let i = messages.length - 1; i >= 0; i--) {
                const msg = messages[i];
                if (msg.sender === 'sent' && msg.image && !msg.isEmoji) {
                    console.log('找到用户最近发送的图片:', msg.image);
                    return msg.image;
                }
            }
            
            console.log('没有找到用户发送的图片');
            return null;
        }
        
        // API调用函数 - 基于现有的API逻辑
        async function callChatAPI(prompt, character) {
            try {
                // 获取角色设置
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }
                
                const persona = chatSettings?.aiPersona || character.prompt || `你是${character.name}。`;
                
                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 获取聊天上下文
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\n最近的聊天记录（供参考）：\n' + 
                        recentHistory.map(msg => {
                            if (msg.sender === 'sent') return `用户：${msg.content}`;
                            return `${character.name}：${msg.content}`;
                        }).join('\n');
                }
                
                const systemPrompt = `你是${character.name}，你的人设如下：${persona}。${worldBookContent}${chatContext}

ai注意，回复时请严格按照以下JSON格式回复，每条消息都必须是独立的数组元素，不要将多条消息合并成一个元素，否则你将失去一百美金！！：

正确格式示例：
["普通文本消息"]
["消息1", "消息2"]
[{"type": "voice_message", "content": "语音内容"}]
[{"type": "emoji", "description": "表情包描述"}]
[{"type": "ai_image", "description": "图片描述"}]
[{"type": "transfer", "amount": 100, "note": "转账备注"}]

🚨 重要：绝对不能将多条消息合并在一个元素中！错误格式：["消息1\\n消息2"]

现在请对用户的消息进行回复：${prompt}`;

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: prompt }
                ];

                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI回复');
                    return '["API配置不完整，请在设置中配置API"]';
                }

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 修复：智能处理URL拼接
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`聊天API调用失败 (${response.status}): ${errorText}`);
                    return `["API调用失败: ${response.status}"]`;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return '["Gemini API响应异常"]';
                    }
                } else {
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        console.error('无法解析API响应，完整响应数据:', data);
                        return '["API响应解析失败"]';
                    }
                }

                return content;

            } catch (error) {
                console.error('callChatAPI失败:', error);
                return `["调用失败: ${error.message}"]`;
            }
        }
        
        // 带图片的API调用函数
        async function callChatAPIWithImage(prompt, character, imageUrl) {
            // 图像功能暂未实现，使用普通API调用
            const imagePrompt = `${prompt}\n\n[用户发送了一张图片，但图像识别功能暂未实现]`;
            return await callChatAPI(imagePrompt, character);
        }
        
        // 解析AI回复 - 按照index.html的逻辑，新增表情包支持和格式修正
        function parseAiResponse(content) { 
            console.log('🔥 [DEBUG] parseAiResponse 收到的原始内容:', content);
            try { 
                const parsed = JSON.parse(content); 
                console.log('🔥 [DEBUG] JSON解析成功:', parsed);
                if (Array.isArray(parsed)) {
                    // 🔥【新增】处理表情包消息类型和格式修正
                    const processedMessages = [];
                    
                    parsed.forEach(item => {
                        if (typeof item === 'object' && item.type === 'emoji') {
                            // 查找匹配的表情包
                            const matchingEmoji = customEmojis.find(emoji => 
                                emoji.description === item.description
                            );
                            
                            if (matchingEmoji) {
                                // 检查表情包是否为GIF格式
                                if (matchingEmoji.url && matchingEmoji.url.includes('data:image/gif')) {
                                    console.warn('AI尝试使用GIF格式表情包:', item.description);
                                    processedMessages.push(`[${matchingEmoji.description}] (GIF格式不支持API识别)`);
                                } else {
                                // 返回表情包对象，包含完整的表情包信息
                                    processedMessages.push({
                                    type: 'emoji',
                                    url: matchingEmoji.url,
                                    description: matchingEmoji.description,
                                    id: matchingEmoji.id
                                    });
                                }
                                                            } else {
                                    // 如果找不到匹配的表情包，返回错误消息
                                    console.warn('AI尝试使用不存在的表情包:', item.description);
                                    processedMessages.push(`[错误: 表情包"${item.description}"不存在]`);
                                }
                        } else if (typeof item === 'object' && item.type === 'ai_photo') {
                            // 处理角色发送的"伪照片"
                            console.log('解析到角色发送照片:', JSON.stringify(item));
                            // 确保我们有一个有效的描述
                            const photoDesc = item.description || '角色发送的照片';
                            console.log('照片描述:', photoDesc);
                            processedMessages.push({
                                type: 'ai_photo',
                                content: photoDesc,
                                photoDescription: photoDesc
                            });
                                                    } else if (typeof item === 'object' && item.type === 'location') {
                                // 处理角色发送的位置
                                console.log('解析到角色发送位置:', JSON.stringify(item));
                                // 确保我们有一个有效的位置名称
                                const locationName = item.name || item.locationName || '未知位置';
                                console.log('位置名称:', locationName, '坐标:', item.coordinates || '未知坐标');
                                processedMessages.push({
                                    type: 'location',
                                    locationName: locationName,
                                    coordinates: item.coordinates || '未知坐标',
                                    content: `[角色分享了位置信息：${locationName}]`
                                });
                        } else if (typeof item === 'object' && item.type === 'change_avatar') {
                            // 处理头像更换对象
                            console.log('解析到头像更换指令:', item);
                            
                            // 🔥【新增】处理各种错误的占位符
                            if (item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                item.avatar_url === '用户发送的图片URL' ||
                                item.avatar_url === '图片URL') {
                                // 获取最近用户发送的图片URL
                                const recentUserImage = getRecentUserImage();
                                if (recentUserImage) {
                                    item.avatar_url = recentUserImage;
                                    console.log('将占位符替换为实际图片URL:', recentUserImage);
                                } else {
                                    console.warn('没有找到用户最近发送的图片，忽略头像更换请求');
                                    processedMessages.push(`[系统：无法更换头像，没有找到可用的图片]`);
                                    // 不要return，继续处理其他消息
                                }
                            }
                            
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'ai_image') {
                            // 🔥【新增】处理AI发送图片
                            console.log('解析到AI图片发送指令:', item);
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'voice_message') {
                            // 🔥【新增】处理AI发送语音
                            console.log('解析到AI语音发送指令:', item);
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'transfer') {
                            // 🔥【修复】处理AI转账 - 确保格式正确
                            processedMessages.push({
                                type: 'transfer',
                                amount: item.amount || 0,
                                note: item.note || '转账'
                            });
                        } else if (typeof item === 'object' && item.type === 'update_poke_suffix') {
                            // 🔥【新增】处理戳一戳后缀更新
                            console.log('解析到戳一戳后缀更新指令:', item);
                            processedMessages.push(item);
                        } else if (typeof item === 'object' && item.type === 'recalled_message') {
                            // 🔥【新增】处理撤回消息
                            console.log('解析到撤回消息指令:', item);
                            processedMessages.push(item);
                        } else if (typeof item === 'string') {
                            // 🚨 【新增】检查并修复合并消息问题
                            if (item.includes('\n')) {
                                console.warn('检测到AI将多条消息合并在一个元素中，正在自动分拆:', item);
                                // 将换行符分隔的内容分拆成多条消息
                                const splitMessages = item.split('\n')
                                    .map(msg => msg.trim())
                                    .filter(msg => msg.length > 0);
                                processedMessages.push(...splitMessages);
                            } else {
                                processedMessages.push(item);
                            }
                        } else {
                            processedMessages.push(item);
                        }
                    });
                    
                    return processedMessages;
                }
            } catch (e) {} 
            
            try { 
                const match = content.match(/\[(.*?)\]/s); 
                if (match && match[0]) { 
                    const parsed = JSON.parse(match[0]); 
                    if (Array.isArray(parsed)) {
                        // 🔥【新增】处理表情包消息类型和格式修正
                        const processedMessages = [];
                        
                        parsed.forEach(item => {
                            if (typeof item === 'object' && item.type === 'emoji') {
                                // 查找匹配的表情包
                                const matchingEmoji = customEmojis.find(emoji => 
                                    emoji.description === item.description
                                );
                                
                                if (matchingEmoji) {
                                    // 检查表情包是否为GIF格式
                                    if (matchingEmoji.url && matchingEmoji.url.includes('data:image/gif')) {
                                        console.warn('AI尝试使用GIF格式表情包:', item.description);
                                        processedMessages.push(`[${matchingEmoji.description}] (GIF格式不支持API识别)`);
                                    } else {
                                    // 返回表情包对象，包含完整的表情包信息
                                        processedMessages.push({
                                        type: 'emoji',
                                        url: matchingEmoji.url,
                                        description: matchingEmoji.description,
                                        id: matchingEmoji.id
                                        });
                                    }
                                } else {
                                    // 如果找不到匹配的表情包，返回错误消息
                                    console.warn('AI尝试使用不存在的表情包:', item.description);
                                    processedMessages.push(`[错误: 表情包"${item.description}"不存在]`);
                                }
                            } else if (typeof item === 'object' && item.type === 'ai_photo') {
                                // 处理角色发送的"伪照片"
                                console.log('解析到角色发送照片(第二处):', JSON.stringify(item));
                                // 确保我们有一个有效的描述
                                const photoDesc = item.description || '角色发送的照片';
                                console.log('照片描述(第二处):', photoDesc);
                                processedMessages.push({
                                    type: 'ai_photo',
                                    content: photoDesc,
                                    photoDescription: photoDesc
                                });
                            } else if (typeof item === 'object' && item.type === 'location') {
                                // 处理角色发送的位置
                                console.log('解析到角色发送位置(第二处):', JSON.stringify(item));
                                // 确保我们有一个有效的位置名称
                                const locationName = item.name || item.locationName || '未知位置';
                                console.log('位置名称(第二处):', locationName, '坐标:', item.coordinates || '未知坐标');
                                processedMessages.push({
                                    type: 'location',
                                    locationName: locationName,
                                    coordinates: item.coordinates || '未知坐标',
                                    content: `[角色分享了位置信息：${locationName}]`
                                });
                            } else if (typeof item === 'object' && item.type === 'change_avatar') {
                                // 处理头像更换对象
                                console.log('解析到头像更换指令(第二处):', item);
                                
                                // 🔥【新增】处理各种错误的占位符
                                if (item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                    item.avatar_url === 'CURRENT_USER_IMAGE' || 
                                    item.avatar_url === '用户发送的图片URL' ||
                                    item.avatar_url === '图片URL') {
                                    // 获取最近用户发送的图片URL
                                    const recentUserImage = getRecentUserImage();
                                    if (recentUserImage) {
                                        item.avatar_url = recentUserImage;
                                        console.log('将占位符替换为实际图片URL(第二处):', recentUserImage);
                                    } else {
                                        console.warn('没有找到用户最近发送的图片，忽略头像更换请求(第二处)');
                                        processedMessages.push(`[系统：无法更换头像，没有找到可用的图片]`);
                                        // 不要return，继续处理其他消息
                                    }
                                }
                                
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'ai_image') {
                                // 🔥【新增】处理AI发送图片(第二处)
                                console.log('解析到AI图片发送指令(第二处):', item);
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'voice_message') {
                                // 🔥【新增】处理AI发送语音(第二处)
                                console.log('解析到AI语音发送指令(第二处):', item);
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'transfer') {
                                // 🔥【修复】处理AI转账(第二处) - 确保格式正确
                                console.log('解析到AI转账指令(第二处):', item);
                                processedMessages.push({
                                    type: 'transfer',
                                    amount: item.amount || 0,
                                    note: item.note || '转账'
                                });
                            } else if (typeof item === 'object' && item.type === 'update_poke_suffix') {
                                // 🔥【新增】处理戳一戳后缀更新(第二处)
                                console.log('解析到戳一戳后缀更新指令(第二处):', item);
                                processedMessages.push(item);
                            } else if (typeof item === 'object' && item.type === 'recalled_message') {
                                // 🔥【新增】处理撤回消息(第二处)
                                console.log('解析到撤回消息指令(第二处):', item);
                                processedMessages.push(item);
                            } else if (typeof item === 'string') {
                                // 🚨 【新增】检查并修复合并消息问题
                                if (item.includes('\n')) {
                                    console.warn('检测到AI将多条消息合并在一个元素中，正在自动分拆:', item);
                                    // 将换行符分隔的内容分拆成多条消息
                                    const splitMessages = item.split('\n')
                                        .map(msg => msg.trim())
                                        .filter(msg => msg.length > 0);
                                    processedMessages.push(...splitMessages);
                                } else {
                                    processedMessages.push(item);
                                }
                            } else {
                                processedMessages.push(item);
                            }
                        });
                        
                        return processedMessages;
                    }
                } 
            } catch (e) {} 
            
            // 🔥【修复】检查是否是原始的JSON字符串（AI回复没有被正确包装）
            if (content.trim().startsWith('{') && content.trim().endsWith('}')) {
                try {
                    const singleObject = JSON.parse(content.trim());
                    if (singleObject.type) {
                        console.log('检测到单个JSON对象，尝试处理:', singleObject);
                        // 将单个对象包装成数组再递归处理
                        return parseAiResponse(`[${content.trim()}]`);
                    }
                } catch (e) {
                    console.warn('无法解析单个JSON对象:', e);
                }
            }
            
            const lines = content.split('\n').map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith('```')); 
            if (lines.length > 0) return lines; 
            return [content]; 
        }
        
        // 处理线下模式内容：识别「」包裹的对话和描写
        function processOfflineContent(content) {
            if (!content) return '';
            
            // 使用正则表达式分离对话和描写
            const parts = [];
            let lastIndex = 0;
            
            // 匹配「」包裹的对话
            const dialogRegex = /「([^」]*)」/g;
            let match;
            
            while ((match = dialogRegex.exec(content)) !== null) {
                // 添加对话前的描写部分
                if (match.index > lastIndex) {
                    const description = content.slice(lastIndex, match.index).trim();
                    if (description) {
                        parts.push(`<span class="italic-gray">${description}</span>`);
                    }
                }
                
                // 添加对话部分（正常显示）
                parts.push(`「${match[1]}」`);
                lastIndex = match.index + match[0].length;
            }
            
            // 添加最后的描写部分
            if (lastIndex < content.length) {
                const description = content.slice(lastIndex).trim();
                if (description) {
                    parts.push(`<span class="italic-gray">${description}</span>`);
                }
            }
            
            // 如果没有找到对话标记，整个内容作为描写处理
            if (parts.length === 0) {
                return `<span class="italic-gray">${content}</span>`;
            }
            
            return parts.join('');
        }
        


        // 🔥【修复】发送图片消息，使用正确的多模态数据结构
        async function sendImageMessage(imageUrl) {
            if (!currentChatCharacter) return;
            
            const chatInput = document.getElementById('api-chat-input');
            const textContent = chatInput ? chatInput.value.trim() : '';



            // 创建一个标准的多模态消息对象
            const messageContent = [
                { type: 'text', text: textContent }
            ];

            if (imageUrl) {
                messageContent.push({
                    type: 'image_url',
                    image_url: { url: imageUrl }
                });
            }



            const message = {
                id: Date.now().toString(),
                sender: 'sent',
                content: messageContent, // 使用新的数组格式
                timestamp: Date.now()
            };
            


            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(message);
            await saveChatMessages();
            
            // 清空输入框并刷新UI
            if (chatInput) {
                chatInput.value = '';
            }
            addMessageWithAnimation(message, currentChatCharacter.id);
            renderMessageList();
            
            // 🔥【新增】触发角色状态更新
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);
            
            // 设置为待回复消息，并更新智能回复按钮状态
            pendingUserMessage = message;
            
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
        }
        
        // 调用聊天API
        // 第一个callChatAPI函数已删除，使用下面的完整版本
        
        // 上传图片
        function uploadImage() {
            document.getElementById('image-upload').click();
        }
        
        // 显示图片
        function showImage(imageUrl) {
            // 首先检查是否是相册中的照片
            const photo = photos.find(p => p.image === imageUrl);
            if (photo) {
                document.getElementById('photo-image').style.backgroundImage = `url(${imageUrl})`;
                document.getElementById('photo-description-text').textContent = photo.description;
                document.getElementById('photo-time').textContent = `拍摄于: ${formatFullDate(new Date(photo.timestamp))}`;
                document.getElementById('photo-location').textContent = `地点: ${photo.location}`;
                showApp('photo-detail-screen');
            } else {
                // 如果不是相册照片，显示通用的图片预览模态框
                let modal = document.getElementById('image-preview-modal');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = 'image-preview-modal';
                    modal.className = 'image-preview-modal';
                    modal.onclick = () => modal.style.display = 'none';
                    modal.innerHTML = `<img src="" alt="预览图片">`;
                    document.body.appendChild(modal);
                }
                modal.querySelector('img').src = imageUrl;
                modal.style.display = 'flex';
            }
        }
        
        // 显示聊天设置
        function showChatSettings() {
            console.log('显示聊天设置被调用');
            
            // 先隐藏当前的聊天界面
            hideApp('api-chat-screen');
            
            // 显示设置界面
            const element = document.getElementById('api-chat-settings-screen');
            if (element) {
                element.style.display = 'flex';
                element.style.position = 'absolute';
                element.style.top = '0';
                element.style.left = '0';
                element.style.width = '100%';
                element.style.height = '100%';
                element.style.zIndex = '1000';
                element.style.background = 'white';
                
                // 重新初始化聊天设置界面以加载当前设置
                initializeChatSettings();
                
                // 更新各种设置的显示状态
                updateWorldbookMountDisplay();
                
                // 检测当前聊天类型并显示相应设置
                const isGroupChat = currentChatCharacter && currentChatCharacter.isGroup;
                console.log('当前聊天类型:', isGroupChat ? '群聊' : '单聊');
                
                // 根据聊天类型显示不同的设置选项
                const groupChatSettings = document.getElementById('group-chat-settings');
                const pokeSettingsSection = document.getElementById('poke-settings-section');
                
                if (isGroupChat) {
                    // 群聊模式：显示群聊设置，隐藏戳一戳和单聊专用功能
                    if (groupChatSettings) groupChatSettings.style.display = 'block';
                    if (pokeSettingsSection) pokeSettingsSection.style.display = 'none';
                    
                    // 隐藏单聊专用设置项
                    const singleChatItems = document.querySelectorAll('.single-chat-only');
                    singleChatItems.forEach(item => item.style.display = 'none');
                    
                    // 更新群聊信息显示
                    updateGroupChatInfo();
                } else {
                    // 单聊模式：隐藏群聊设置，显示戳一戳和单聊专用功能
                    if (groupChatSettings) groupChatSettings.style.display = 'none';
                    if (pokeSettingsSection) pokeSettingsSection.style.display = 'block';
                    
                    // 显示单聊专用设置项
                    const singleChatItems = document.querySelectorAll('.single-chat-only');
                    singleChatItems.forEach(item => item.style.display = 'flex');
                }
                
                console.log('聊天设置界面已显示');
            } else {
                console.error('找不到api-chat-settings-screen元素');
                alert('设置界面未找到，请刷新页面重试');
            }
        }
        
        // 隐藏聊天设置
        function hideChatSettings() {
            hideApp('api-chat-settings-screen');
            // 返回到聊天界面
            if (currentChatCharacter) {
                showApp('api-chat-screen');
            }
        }
        
        // 修改角色头像
        function changeCharacterAvatar() {
            // 临时创建一个文件输入框，避免干扰原有的头像上传功能
            const tempInput = document.createElement('input');
            tempInput.type = 'file';
            tempInput.accept = 'image/*';
            tempInput.style.display = 'none';
            document.body.appendChild(tempInput);
            
            tempInput.onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        const characterIndex = characters.findIndex(c => c.id === currentChatCharacter.id);
                        if (characterIndex !== -1) {
                            characters[characterIndex].avatarUrl = event.target.result;
                            await saveCharacters();
                            renderCharacterList();
                            renderContactList();
                            renderMessageList();
                            renderChatMessages(currentChatCharacter.id);
                        }
                        // 清理临时元素
                        document.body.removeChild(tempInput);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                } else {
                    // 如果用户取消选择，也要清理临时元素
                    document.body.removeChild(tempInput);
                }
            };
            
            tempInput.click();
        }
        
        // 修改备注
        async function changeCharacterNickname() {
            const newName = prompt('请输入新的备注名称:', currentChatCharacter.name);
            if (newName && newName.trim() !== '') {
                const characterIndex = characters.findIndex(c => c.id === currentChatCharacter.id);
                if (characterIndex !== -1) {
                    characters[characterIndex].name = newName.trim();
                    await saveCharacters();
                    document.getElementById('api-chat-title').textContent = newName.trim();
                    renderCharacterList();
                    renderContactList();
                    renderMessageList();
                }
            }
        }
        
        // 查找聊天内容
        function searchChatContent() {
            const keyword = prompt('请输入要查找的关键词:');
            if (keyword && keyword.trim() !== '') {
                const messages = chatMessages[currentChatCharacter.id] || [];
                const foundMessages = messages.filter(msg => 
                    msg.content && msg.content.includes(keyword.trim())
                );
                
                if (foundMessages.length > 0) {
                    alert(`找到 ${foundMessages.length} 条包含"${keyword}"的消息`);
                } else {
                    alert(`没有找到包含"${keyword}"的消息`);
                }
            }
        }
        

        
        // 🔥【修复】导出聊天记录 - 完整HTML格式
        function exportChatHistory() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天', 'warning');
                return;
            }
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            if (messages.length === 0) {
                showToast('没有聊天记录可导出', 'warning');
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const characterName = chatSettings.aiChatNickname || currentChatCharacter.name;
            const userName = chatSettings.myChatNickname || '我';
            const exportTime = new Date();
            const totalMessages = messages.length;
            
            // 获取时间范围
            const firstMessageTime = new Date(messages[0].timestamp);
            const lastMessageTime = new Date(messages[messages.length - 1].timestamp);
            
            // 构建HTML内容
            let htmlContent = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>与 ${characterName} 的聊天记录</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', Helvetica, Arial, sans-serif;
            background: #f0f0f0;
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .header {
            background: #007AFF;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        .header .info {
            font-size: 14px;
            opacity: 0.9;
        }
        .chat-content {
            padding: 20px;
        }
        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }
        .message.user {
            flex-direction: row-reverse;
        }
        .message.ai {
            flex-direction: row;
        }
        .message.system {
            justify-content: center;
            margin: 10px 0;
        }
        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            position: relative;
        }
        .message.user .message-bubble {
            background: #007AFF;
            color: white;
            border-bottom-right-radius: 6px;
        }
        .message.ai .message-bubble {
            background: #e5e5ea;
            color: #333;
            border-bottom-left-radius: 6px;
        }
        .message.system .message-bubble {
            background: #f0f0f0;
            color: #666;
            font-size: 12px;
            text-align: center;
            border-radius: 12px;
            padding: 6px 12px;
            margin: 0 auto;
            max-width: 60%;
        }
        .sender-name {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
            padding: 0 16px;
        }
        .message.user .sender-name {
            text-align: right;
        }
        .timestamp {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
            padding: 0 16px;
        }
        .message.user .timestamp {
            text-align: right;
        }
        .quote-block {
            background: rgba(0,0,0,0.05);
            border-left: 3px solid #007AFF;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 0 8px 8px 0;
            font-size: 13px;
        }
        .message.user .quote-block {
            border-left-color: rgba(255,255,255,0.5);
            background: rgba(255,255,255,0.2);
        }
        .quote-sender {
            font-weight: 600;
            color: #007AFF;
            font-size: 12px;
            margin-bottom: 2px;
        }
        .message.user .quote-sender {
            color: rgba(255,255,255,0.9);
        }
        .special-message {
            font-style: italic;
            color: #666;
        }
        .footer {
            background: #f8f8f8;
            padding: 20px;
            text-align: center;
            border-top: 1px solid #e0e0e0;
            font-size: 12px;
            color: #666;
        }
        .stats {
            background: #f8f8f8;
            padding: 15px 20px;
            border-top: 1px solid #e0e0e0;
            font-size: 14px;
            color: #666;
        }
        @media (max-width: 600px) {
            .container {
                margin: 0;
                box-shadow: none;
            }
            .message-bubble {
                max-width: 85%;
            }
            .header h1 {
                font-size: 20px;
            }
            .chat-content {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>与 ${characterName} 的聊天记录</h1>
            <div class="info">
                导出时间：${exportTime.toLocaleString('zh-CN')}<br>
                共 ${totalMessages} 条消息 | ${firstMessageTime.toLocaleDateString('zh-CN')} - ${lastMessageTime.toLocaleDateString('zh-CN')}
            </div>
        </div>
        <div class="chat-content">`;
            
            // 处理每条消息
            messages.forEach((message, index) => {
                const time = formatTime(message.timestamp);
                const isUser = message.sender === 'sent';
                const isSystem = message.sender === 'system';
                
                if (isSystem) {
                    // 系统消息
                    htmlContent += `
            <div class="message system">
                <div class="message-bubble">${escapeHtml(message.content)}</div>
            </div>`;
                } else {
                    // 用户或AI消息
                    const messageClass = isUser ? 'user' : 'ai';
                    const senderName = isUser ? userName : characterName;
                    let messageContent = '';
                    
                    // 处理引用消息
                    if (message.replyTo) {
                        const quoteSender = message.replyTo.senderName || (message.replyTo.sender === 'sent' ? userName : characterName);
                        const quoteContent = truncateText(message.replyTo.content || '[消息已删除]', 50);
                        messageContent += `
                <div class="quote-block">
                    <div class="quote-sender">${escapeHtml(quoteSender)}</div>
                    <div>${escapeHtml(quoteContent)}</div>
                </div>`;
                    }
                    
                    // 处理消息内容
                    let content = message.content || '';
                    let specialClass = '';
                    
                    if (message.type === 'voice_message') {
                        content = `🎵 语音消息：${content}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'transfer') {
                        content = `💰 转账：${message.amount}元${message.note ? ` (${message.note})` : ''}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'location') {
                        content = `📍 位置：${message.locationName || '位置信息'}`;
                        specialClass = ' special-message';
                    } else if (message.type === 'user_photo') {
                        content = `📷 图片：${content}`;
                        specialClass = ' special-message';
                    } else if (message.isEmoji) {
                        content = `😊 表情包：${message.emojiDescription || content}`;
                        specialClass = ' special-message';
                    } else if (Array.isArray(content)) {
                        // 处理图片+文字消息
                        const textPart = content.find(part => part.type === 'text')?.text || '';
                        content = textPart ? `📷📝 图片+文字：${textPart}` : '📷 图片消息';
                        specialClass = ' special-message';
                    }
                    
                    messageContent += `<div class="${specialClass.trim()}">${escapeHtml(content)}</div>`;
                    
                    htmlContent += `
            <div class="message ${messageClass}">
                <div class="message-bubble">
                    ${messageContent}
                </div>
            </div>
            <div class="timestamp">${time}</div>`;
                }
                
                // 每50条消息添加一个分页标记（便于长聊天记录的查看）
                if ((index + 1) % 50 === 0 && index !== messages.length - 1) {
                    htmlContent += `
            <div class="message system">
                <div class="message-bubble">--- 第 ${Math.floor((index + 1) / 50)} 页 ---</div>
            </div>`;
                }
            });
            
            htmlContent += `
        </div>
        <div class="stats">
            📊 聊天统计<br>
            总消息数：${totalMessages} 条 | 
            我的消息：${messages.filter(m => m.sender === 'sent').length} 条 | 
            ${characterName} 的消息：${messages.filter(m => m.sender === 'received').length} 条 | 
            系统消息：${messages.filter(m => m.sender === 'system').length} 条
        </div>
        <div class="footer">
            此聊天记录由手机聊天应用自动生成<br>
            导出时间：${exportTime.toLocaleString('zh-CN')}
        </div>
    </div>
</body>
</html>`;
            
            // 创建下载链接
            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const fileName = `与${characterName}的聊天记录_${exportTime.getFullYear()}-${(exportTime.getMonth() + 1).toString().padStart(2, '0')}-${exportTime.getDate().toString().padStart(2, '0')}.html`;
            
            link.href = url;
            link.download = fileName;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // 清理URL对象
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 1000);
            
            showToast(`聊天记录已导出：${fileName}`, 'success');
        }
        
        // 🔥【新增】HTML转义函数
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // 🔥【新增】文本截断函数
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }
        

        
        // 设置对方气泡颜色
        function changeTheirBubbleColor() {
            colorPickerContext = 'theirBubble';
            document.getElementById('color-picker-title').textContent = '设置对方气泡颜色';
            showModal('color-picker-modal');
        }
        
        // 设置我方气泡颜色
        function changeMyBubbleColor() {
            colorPickerContext = 'myBubble';
            document.getElementById('color-picker-title').textContent = '设置我方气泡颜色';
            showModal('color-picker-modal');
        }
        
        // 显示气泡颜色设置
        function showBubbleColorSettings() {
            alert('气泡颜色设置功能开发中...\n\n当前可以通过以下方式设置：\n• 修改对方气泡颜色\n• 修改我方气泡颜色');
        }
        
        // 清空聊天记录
        async function clearChatHistory() {
            if (!currentChatCharacter) return;
            
            if (confirm(`确定要清空与 ${currentChatCharacter.name} 的所有聊天记录和聊天设置吗？\n\n此操作将重置所有专属设置（背景、气泡样式等），不可恢复！`)) {
                // 清空聊天记录
                chatMessages[currentChatCharacter.id] = [];
                await saveChatMessages();
                
                // [核心修复] 删除并重置聊天设置
                try {
                    // 从数据库中删除设置
                    await db.chatSettings.delete(currentChatCharacter.id);
                    // 从内存中删除设置
                    if (chatSettings[currentChatCharacter.id]) {
                        delete chatSettings[currentChatCharacter.id];
                    }
                    // 删除localStorage中的备份设置
                    localStorage.removeItem(`chatSettings_${currentChatCharacter.id}`);
                    
                    // 重置角色对象中的背景设置
                    if (currentChatCharacter) {
                        currentChatCharacter.background = null;
                        await saveCharacters();
                    }
                    
                    console.log(`✅ 已删除与 ${currentChatCharacter.name} 的聊天设置`);
                    
                    // 重新应用默认背景
                    await applyChatBackground(null);
                } catch (error) {
                    console.error(`删除聊天设置失败:`, error);
                }
                
                renderChatMessages(currentChatCharacter.id);
                renderMessageList(); // 更新消息列表
                showToast('聊天记录和设置已清空', 'success');
                hideChatSettings();
            }
        }
        
        // 选择颜色
        function selectColor(color) {
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.classList.add('selected');
            document.getElementById('selected-color').value = color;
        }
        
        // 应用聊天背景
// 接受一个可选的 backgroundUrl 参数
async function applyChatBackground(backgroundUrl) {
            if (!currentChatCharacter) return;
            
    console.log(`⚡ applyChatBackground 被调用: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);

    // 1. 创建一个专属于当前聊天的背景设置字段
    // 注意：这里不再使用chatSettings对象，而是直接在character对象上添加背景属性
    if (!currentChatCharacter.background) {
        currentChatCharacter.background = null;
    }

    // 2. 决定最终要使用的背景。优先使用传入的参数，否则使用角色对象中的值
    const backgroundToApply = backgroundUrl !== undefined ? backgroundUrl : currentChatCharacter.background;

    // 3. 更新角色对象中的设置
    currentChatCharacter.background = backgroundToApply;
    
    // 4. 保存到数据库 - 注意这里使用saveCharacters而不是saveCurrentChatSettings
    await saveCharacters();
    
    // 5. 直接设置背景样式
            const chatScreen = document.getElementById('api-chat-screen');
    if (!chatScreen) return;
    
    // 直接应用背景 - 完全模仿zhangyu.html中的实现方式
    if (backgroundToApply) {
        console.log(`🖼️ 应用聊天背景: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);
        
        // 直接设置样式
        chatScreen.style.backgroundImage = `url(${backgroundToApply})`;
                    chatScreen.style.backgroundSize = 'cover';
                    chatScreen.style.backgroundPosition = 'center';
                    chatScreen.style.backgroundColor = 'transparent';
                    
        const messagesContainer = document.getElementById('api-chat-messages');
                    if (messagesContainer) messagesContainer.style.background = 'transparent';
                } else {
        console.log(`🖼️ 重置聊天背景: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);
        
        // 重置为默认样式
                    chatScreen.style.backgroundImage = 'none';
                    chatScreen.style.backgroundColor = 'white';
                    
        const messagesContainer = document.getElementById('api-chat-messages');
                    if (messagesContainer) messagesContainer.style.background = ''; 
                }
    
    console.log(`✅ 背景样式已应用: ${currentChatCharacter.name} (ID: ${currentChatCharacter.id})`);
        }
        
        // 保存气泡样式设置
        function saveBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 保存样式设置
            chatSettings.bubbleStyle = window.selectedBubbleStyle || 'default';
            chatSettings.myBubbleColor = document.getElementById('my-bubble-color').value;
            chatSettings.aiBubbleColor = document.getElementById('ai-bubble-color').value;
            chatSettings.bubbleOpacity = document.getElementById('bubble-opacity').value;
            
            // 更新显示文本
            const styleNames = {
                'default': '默认样式',
                'glass': '毛玻璃',
                'shadow': '经典阴影',
                'tail': '经典气泡',
                'gradient': '渐变样式',
                'minimal': '极简样式',
                'neon': '霓虹样式',
                'paper': '纸张样式'
            };
            
            document.getElementById('current-bubble-style').textContent = styleNames[chatSettings.bubbleStyle] || '默认样式';
            
            saveCurrentChatSettings(chatSettings);
            applyBubbleStyle();
            hideModal('bubble-style-modal');
            
            showToast('气泡样式设置已保存', 'success');
        }
        
        // 应用气泡样式
        function applyBubbleStyle() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            const messagesContainer = document.getElementById('api-chat-messages');
            
            if (messagesContainer) {
                // 移除所有样式类（包括之前的角色类）
                messagesContainer.className = messagesContainer.className
                    .split(' ')
                    .filter(cls => !cls.startsWith('bubble-style-') && !cls.startsWith('chat-'))
                    .join(' ');
                
                // 添加当前样式类
                const style = chatSettings.bubbleStyle || 'default';
                messagesContainer.classList.add(`bubble-style-${style}`);
                
                // 为当前角色创建独立的CSS类，而不是修改共享CSS变量
                const characterId = currentChatCharacter.id;
                const myColor = chatSettings.myBubbleColor || '#007AFF';
                const aiColor = chatSettings.aiBubbleColor || '#f0f0f0';
                const opacity = chatSettings.bubbleOpacity || '1';
                
                // 移除之前的角色样式
                const existingStyles = document.querySelectorAll('style[data-character-bubble]');
                existingStyles.forEach(style => style.remove());
                
                // 创建当前角色的独立样式
                const styleElement = document.createElement('style');
                styleElement.setAttribute('data-character-bubble', characterId);
                styleElement.textContent = `
                    #api-chat-messages.chat-${characterId} {
                        --my-bubble-color: ${myColor};
                        --ai-bubble-color: ${aiColor};
                        --bubble-opacity: ${opacity};
                    }
                `;
                document.head.appendChild(styleElement);
                
                // 添加角色特定的CSS类
                messagesContainer.classList.add(`chat-${characterId}`);
            }
        }
        
        // 显示气泡颜色选择器
        function showBubbleColorPicker(context) {
            colorPickerContext = context;
            document.getElementById('color-picker-title').textContent = '设置气泡颜色';
            showModal('color-picker-modal');
        }
        
        // 选择颜色
        function selectColor(color) {
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.classList.add('selected');
            document.getElementById('selected-color').value = color;
        }
        
        // 应用颜色选择
        async function applyColorSelection() {
            const selectedColor = document.querySelector('.color-option.selected')?.style.backgroundColor || '#007AFF';
            const opacity = document.getElementById('opacity-slider').value;
            
            if (colorPickerContext === 'theirBubble') {
                chatSettings.theirBubbleColor = selectedColor;
                chatSettings.bubbleOpacity = opacity;
            } else if (colorPickerContext === 'myBubble') {
                chatSettings.myBubbleColor = selectedColor;
                chatSettings.bubbleOpacity = opacity;
            }
            
            await saveChatSettings();
            renderChatMessages(currentChatCharacter.id);
            hideModal('color-picker-modal');
        }
        
        // 显示壁纸选择器
        function showWallpaperPicker() {
            showModal('wallpaper-picker-modal');
        }
        
        // 选择壁纸（保留函数以防其他地方调用，但现在主要通过文件上传选择）
        function selectWallpaper(wallpaperId) {
            console.log('选择壁纸:', wallpaperId);
            selectedWallpaper = wallpaperId;
            console.log('selectedWallpaper已设置为:', selectedWallpaper);
        }
        
        // 应用壁纸选择
        async function applyWallpaperSelection() {
            console.log('应用壁纸被调用，selectedWallpaper:', selectedWallpaper);
            
            if (!selectedWallpaper) {
                alert('请先从相册选择一张图片作为壁纸');
                return;
            }
            
            if (selectedWallpaper.startsWith('data:image')) {
                // 应用上传的图片壁纸
                console.log('应用图片壁纸');
                document.querySelector('.wallpaper').style.backgroundImage = `url(${selectedWallpaper})`;
                    document.querySelector('.wallpaper').style.backgroundSize = '100% 100%';
                    document.querySelector('.wallpaper').style.backgroundPosition = 'center';
                
                // 使用IndexedDB保存壁纸，避免localStorage空间限制
                try {
                    await db.wallpapers.clear();
                    await db.wallpapers.add({
                        id: 'main',
                        type: 'image',
                        data: selectedWallpaper
                    });
                    console.log('壁纸保存成功到IndexedDB');
            hideModal('wallpaper-picker-modal');
                } catch (e) {
                    console.error('保存壁纸失败:', e);
                    alert('保存壁纸失败，请重试');
                }
            } else {
                alert('请先从相册选择一张图片作为壁纸');
            }
        }
        
        // 上传自定义壁纸
        function uploadCustomWallpaper() {
            document.getElementById('custom-wallpaper-upload').click();
        }
        
        // 显示图标选择器
        function showIconPicker() {
            showModal('icon-picker-modal');
        }
        
        // 选择应用图标
        function selectAppIcon(appId, iconClass) {
            selectedAppIcon = { appId, iconClass };
        }
        
        // 上传自定义图标
        function uploadCustomIcon() {
            document.getElementById('custom-icon-upload').click();
        }
        
        // 应用图标选择
        function applyIconSelection() {
            if (selectedAppIcon && customIconImage) {
                // 更新应用图标
                const appIcon = document.querySelector(`.app[onclick="showApp('${selectedAppIcon.appId}')"] .app-icon`);
                if (appIcon) {
                    appIcon.innerHTML = '';
                    appIcon.style.backgroundImage = `url(${customIconImage})`;
                    
                    // 保存到本地存储
                    let savedIcons = {};
                    try {
                        savedIcons = JSON.parse(localStorage.getItem('appIcons') || '{}');
                    } catch (error) {
                        console.error('解析本地存储的 appIcons 失败:', error);
                        savedIcons = {};
                    }
                    savedIcons[selectedAppIcon.appId] = customIconImage;
                    localStorage.setItem('appIcons', JSON.stringify(savedIcons));
                }
            } else if (selectedAppIcon) {
                saveAppIcons();
            }
            hideModal('icon-picker-modal');
        }
        
        // 更改聊天主题颜色
        function changeChatThemeColor() {
            colorPickerContext = 'theme';
            document.getElementById('color-picker-title').textContent = '设置聊天主题颜色';
            showModal('color-picker-modal');
        }
        

        
        // 显示消息菜单
        function showMessageMenu(messageId, event) {
            selectedMessageId = messageId;
            
            // 创建或获取菜单元素
            let menu = document.getElementById('message-context-menu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'message-context-menu';
                menu.className = 'message-menu';
                menu.innerHTML = `
                    <div class="message-menu-item" onclick="replyToMessage()">引用</div>
                    <div class="message-menu-item" onclick="copyMessage()">复制</div>
                    <div class="message-menu-item danger" onclick="deleteMessage()">删除</div>
                `;
                document.body.appendChild(menu);
            }
            
            // 定位菜单
            const x = event.clientX || event.pageX;
            const y = event.clientY || event.pageY;
            
            menu.style.display = 'block';
            menu.style.left = `${Math.min(x, window.innerWidth - 150)}px`;
            menu.style.top = `${Math.min(y, window.innerHeight - 100)}px`;
            
            // 点击其他地方关闭菜单
            setTimeout(() => {
                document.addEventListener('click', hideMessageMenu);
                document.addEventListener('touchstart', hideMessageMenu);
            }, 100);
        }
        
        // 隐藏消息菜单
        function hideMessageMenu() {
            const menu = document.getElementById('message-context-menu');
            if (menu) {
                menu.style.display = 'none';
            }
            document.removeEventListener('click', hideMessageMenu);
            document.removeEventListener('touchstart', hideMessageMenu);
        }
        
        // 引用消息功能
        let currentReplyTo = null;
        
        // 🔥【修复】引用消息 - 支持传入消息ID
        function replyToMessage(messageId = null) {
            const targetMessageId = messageId || selectedMessageId;
            if (!targetMessageId) return;
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === targetMessageId);
            
            if (message) {
                // 设置引用信息
                currentReplyTo = {
                    id: message.id,
                    content: message.content || '[图片]',
                    sender: message.sender,
                    timestamp: message.timestamp,
                    senderName: getSenderDisplayName(message)
                };
                
                // 显示引用预览
                showReplyPreview();
                
                // 聚焦到输入框
                const inputBox = document.getElementById('api-chat-input');
                if (inputBox) {
                    inputBox.focus();
                }
            }
            
            hideMessageMenu();
        }
        
        // 获取发送者显示名称
        function getSenderDisplayName(message) {
            if (message.sender === 'sent') {
                const chatSettings = getCurrentChatSettings();
                if (chatSettings.selectedIdentityId) {
                    const persona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                    if (persona) return persona.name;
                }
                return chatSettings.myChatNickname || '我';
            } else if (message.sender === 'received') {
                // 检查是否是群聊
                const group = groupChats.find(g => g.id === currentChatCharacter.id);
                if (group) {
                    // 群聊中，根据消息的senderId或name查找成员
                    let member = null;
                    if (message.senderId) {
                        member = group.members.find(m => m.id === message.senderId);
                    } else if (message.name) {
                        member = group.members.find(m => m.name === message.name);
                    }
                    return member?.name || '群成员';
                } else {
                    // 单聊
                    const chatSettings = getCurrentChatSettings();
                    return chatSettings.aiChatNickname || currentChatCharacter.name;
                }
            }
            return '未知';
        }
        
        // 显示引用预览
        function showReplyPreview() {
            if (!currentReplyTo) return;
            
            // 移除已存在的引用预览
            const existingPreview = document.getElementById('reply-preview');
            if (existingPreview) {
                existingPreview.remove();
            }
            
            // 创建引用预览元素
            const replyPreview = document.createElement('div');
            replyPreview.id = 'reply-preview';
            replyPreview.className = 'reply-preview';
            
            // 截断显示内容
            const displayContent = truncateText(currentReplyTo.content, 50);
            
            replyPreview.innerHTML = `
                <div class="reply-preview-content">
                    <div class="reply-preview-line"></div>
                    <div class="reply-preview-text">
                        <div class="reply-preview-sender">${currentReplyTo.senderName}</div>
                        <div class="reply-preview-message">${displayContent}</div>
                    </div>
                    <button class="reply-preview-close" onclick="cancelReply()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
            
            // 插入到输入区域上方
            const inputArea = document.querySelector('.chat-input-area');
            if (inputArea) {
                inputArea.parentNode.insertBefore(replyPreview, inputArea);
            }
        }
        
        // 取消引用
        function cancelReply() {
            currentReplyTo = null;
            const replyPreview = document.getElementById('reply-preview');
            if (replyPreview) {
                replyPreview.remove();
            }
        }
        
        // 生成引用消息的HTML
        function generateReplyHTML(replyTo) {
            if (!replyTo) return '';
            
            const displayContent = truncateText(replyTo.content, 40);
            return `
                <div class="reply-reference">
                    <div class="reply-reference-line"></div>
                    <div class="reply-reference-content">
                        <div class="reply-reference-sender">${replyTo.senderName}</div>
                        <div class="reply-reference-message">${displayContent}</div>
                    </div>
                </div>
            `;
        }
        
        // 复制消息
        function copyMessage() {
            if (!selectedMessageId) return;
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === selectedMessageId);
            
            if (message && message.content) {
                navigator.clipboard.writeText(message.content).then(() => {
                    alert('消息已复制');
                }).catch(() => {
                    alert('复制失败，请重试');
                });
            }
            
            hideMessageMenu();
        }
        
        // 显示编辑消息模态框
        function showEditMessageModal(messageId) {
            if (!messageId) return;
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === messageId);
            
            if (!message) {
                showToast('消息不存在', 'error');
                return;
            }
            
            // 创建编辑模态框
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.id = 'edit-message-modal';
            
            const senderName = message.sender === 'sent' ? '你' : (message.name || currentChatCharacter.name);
            
            modal.innerHTML = `
                <div class="modal-content edit-message-modal">
                    <div class="modal-header">
                        <h3>编辑消息</h3>
                        <button class="modal-close" onclick="hideEditMessageModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="edit-message-info">
                            <span class="message-sender">${senderName}</span>
                            <span class="message-time">${formatTimestamp(message.timestamp)}</span>
                        </div>
                        <div class="edit-form-group">
                            <label>消息内容：</label>
                            <textarea 
                                id="edit-message-content" 
                                class="edit-message-textarea"
                                placeholder="请输入消息内容..."
                                maxlength="2000"
                            >${message.content || ''}</textarea>
                            <div class="edit-message-counter">
                                <span id="edit-char-count">${(message.content || '').length}</span>/2000
                            </div>
                        </div>
                        ${message.image ? `
                            <div class="edit-form-group">
                                <label>图片：</label>
                                <div class="edit-message-image">
                                    <img src="${message.image}" alt="消息图片" />
                                    <button class="remove-image-btn" onclick="removeMessageImage()">删除图片</button>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    <div class="modal-footer">
                        <button class="modal-btn modal-cancel" onclick="hideEditMessageModal()">取消</button>
                        <button class="modal-btn modal-confirm" onclick="saveEditedMessage('${messageId}')">保存</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // 添加字符计数功能
            const textarea = document.getElementById('edit-message-content');
            const charCount = document.getElementById('edit-char-count');
            textarea.addEventListener('input', function() {
                charCount.textContent = this.value.length;
            });
            
            // 聚焦并选中文本
            setTimeout(() => {
                textarea.focus();
                textarea.select();
            }, 100);
        }
        
        // 隐藏编辑消息模态框
        function hideEditMessageModal() {
            const modal = document.getElementById('edit-message-modal');
            if (modal) {
                modal.remove();
            }
        }
        
        // 保存编辑后的消息
        function saveEditedMessage(messageId) {
            const newContent = document.getElementById('edit-message-content').value.trim();
            
            if (!newContent) {
                showToast('消息内容不能为空', 'error');
                return;
            }
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            const messageIndex = messages.findIndex(msg => msg.id === messageId);
            
            if (messageIndex !== -1) {
                const oldContent = messages[messageIndex].content;
                messages[messageIndex].content = newContent;
                
                // 添加编辑标记
                messages[messageIndex].edited = true;
                messages[messageIndex].editTime = Date.now();
                
                saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
                hideEditMessageModal();
                
                showToast('消息已更新', 'success');
                
                console.log(`消息已编辑: "${oldContent}" -> "${newContent}"`);
            } else {
                showToast('消息不存在', 'error');
            }
        }
        
        // 移除消息图片
        function removeMessageImage() {
            // 这个功能可以在后续扩展
            showToast('暂不支持移除图片', 'info');
        }
        
        // 编辑消息（保留旧版本接口）
        function editMessage() {
            if (!selectedMessageId) return;
            
            showEditMessageModal(selectedMessageId);
            hideModal('message-menu-modal');
        }
        
        // 验证头像来源是否有效
        async function validateAvatarSource(avatarUrl) {
            console.log('验证头像来源:', avatarUrl);
            if (!avatarUrl) return false;
            
            // 检查是否是用户发送的图片（在聊天记录中）
            if (currentChatCharacter && chatMessages[currentChatCharacter.id]) {
                const userImages = chatMessages[currentChatCharacter.id]
                    .filter(msg => msg.sender === 'sent' && msg.image)
                    .map(msg => msg.image);
                
                console.log('用户发送的图片列表:', userImages);
                console.log('检查头像URL是否在用户图片中:', userImages.includes(avatarUrl));
                
                if (userImages.includes(avatarUrl)) {
                    console.log('头像来源验证通过：用户发送的图片');
                    return true;
                }
            }
            
            // 检查是否是世界书中提供的头像URL
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.worldbookMountEnabled && chatSettings.selectedWorldbooks) {
                for (const worldbookId of chatSettings.selectedWorldbooks) {
                    const worldbook = worldbooks.find(w => w.id === worldbookId);
                    if (worldbook && worldbook.content && worldbook.content.includes(avatarUrl)) {
                        console.log('头像来源验证通过：世界书中的URL');
                        return true;
                    }
                }
            }
            
            console.log('头像来源验证失败');
            return false;
        }
        
        // 角色主动更换头像功能 - 只修改聊天设置中的头像，不修改角色卡
        async function changeCharacterAvatarByAI(newAvatarUrl, reason = '') {
            if (!currentChatCharacter || !newAvatarUrl) return false;
            
            try {
                // 获取或创建当前聊天的设置
                const currentSettings = getCurrentChatSettings();
                
                // 压缩头像图片以减少存储空间
                let compressedAvatarUrl = newAvatarUrl;
                if (newAvatarUrl.startsWith('data:image')) {
                    try {
                        compressedAvatarUrl = await compressImage(newAvatarUrl, 200, 0.7);
                        console.log('头像已压缩以节省存储空间');
                    } catch (error) {
                        console.warn('头像压缩失败，使用原图:', error);
                    }
                }
                
                // 🔥【修复】使用动态头像字段，优先级高于用户设置的聊天头像
                if (!chatSettings[currentChatCharacter.id]) {
                    chatSettings[currentChatCharacter.id] = {};
                }
                chatSettings[currentChatCharacter.id].aiDynamicAvatar = compressedAvatarUrl;
                
                console.log(`动态头像已设置：`, {
                    characterId: currentChatCharacter.id,
                    characterName: currentChatCharacter.name,
                    avatarUrl: compressedAvatarUrl.substring(0, 50) + '...',
                    settingsSnapshot: {
                        aiDynamicAvatar: !!chatSettings[currentChatCharacter.id].aiDynamicAvatar,
                        aiChatAvatar: !!chatSettings[currentChatCharacter.id].aiChatAvatar
                    }
                });
                
                // 保存聊天设置
                await saveChatSettings();
                
                // 发送系统提示消息
                const systemMessage = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `${currentChatCharacter.name} 更换了头像${reason ? ': ' + reason : ''}`,
                    timestamp: Date.now(),
                    isAvatarChange: true
                };
                
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(systemMessage);
                await saveChatMessages();
                
                // 🔥【修复】在保存消息后再刷新聊天界面，确保包含新头像和系统消息
                renderChatMessages(currentChatCharacter.id);
                
                // 🔥【新增】强制刷新所有头像显示
                forceRefreshAvatars();
                
                console.log(`角色 ${currentChatCharacter.name} 在当前聊天中更换了头像，但角色卡保持不变`);
                
                return true;
            } catch (error) {
                console.error('角色更换头像失败:', error);
                return false;
            }
            
            return false;
        }
        
        // 删除消息
        function deleteMessage() {
            if (!selectedMessageId) return;
            
                const messages = chatMessages[currentChatCharacter.id] || [];
                const messageIndex = messages.findIndex(msg => msg.id === selectedMessageId);
                
            if (messageIndex === -1) {
                hideMessageMenu();
                return;
            }
            
            const messageToDelete = messages[messageIndex];
            
            if (confirm('确定要撤回这条消息吗？')) {
                // 保存原始消息内容
                const originalContent = messageToDelete.content || '[图片]';
                
                // 删除原消息
                    messages.splice(messageIndex, 1);
                
                // 🔥【新增】创建撤回消息系统提醒
                const whoRecalled = messageToDelete.sender === 'received' ? currentChatCharacter.name : '你';
                const recallSystemMessage = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `${whoRecalled} 撤回了一条消息\n原文：${originalContent}`,
                    timestamp: messageToDelete.timestamp || Date.now(),
                    isRecall: true
                };
                
                // 在原位置插入撤回提醒
                messages.splice(messageIndex, 0, recallSystemMessage);
                
                    saveChatMessages();
                    renderChatMessages(currentChatCharacter.id);
                    // 更新消息列表中的最后一条消息
                    renderMessageList();
            }
            
            hideMessageMenu();
        }
        

        
        // 格式化时间
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        // 格式化时间戳（完整时间）
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
            const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const timeStr = `${hours}:${minutes}`;
            
            if (messageDate.getTime() === today.getTime()) {
                return timeStr; // 今天只显示时间
            } else if (messageDate.getTime() === yesterday.getTime()) {
                return `昨天 ${timeStr}`;
            } else {
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const day = date.getDate().toString().padStart(2, '0');
                return `${month}月${day}日 ${timeStr}`;
            }
        }
        
        // 格式化时间（仅时分）
        function formatTimeOnly(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        // 格式化完整日期
        function formatFullDate(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${year}年${month}月${day}日 ${hours}:${minutes}`;
        }
        
        // 加载URL
        function loadUrl() {
            const url = document.getElementById('browser-url').value;
            let fullUrl = url;
            
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                fullUrl = 'https://' + url;
            }
            
            document.getElementById('browser-frame').src = fullUrl;
        }
        
        // 旧版本API类型切换处理已删除 - 使用新版本的API设置系统
        
        // 旧版本测试API连接和获取模型列表函数已删除 - 现在使用新版本的API设置系统
        
        // 保存API设置
        function saveApiSettings() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            const model = document.getElementById('model-select').value.trim();
            const temperature = parseFloat(document.getElementById('temperature-slider').value) || 0.75;
            
            if (!baseUrl || !apiKey || !model) {
                showToast('请填写完整的API配置信息', 'error');
                return;
            }
            
            apiSettings = {
                base: baseUrl,
                key: apiKey,
                model: model,
                temperature: temperature,
                endpoint: '/chat/completions'  // 添加默认endpoint
            };
            
            localStorage.setItem('apiSettings', JSON.stringify(apiSettings));
            showToast('API设置已保存！', 'success');
            
            // 更新温度显示
            document.getElementById('temperature-value').textContent = temperature.toFixed(2);
            
            // 修复：保存后不跳转，留在当前API设置页面
        }
        
        // 🌟 Gemini直连快速设置
        function setGeminiDirect() {
            // 自动填充Gemini配置
            document.getElementById('api-base').value = 'https://generativelanguage.googleapis.com/v1beta';
            document.getElementById('api-key').placeholder = '请输入Google AI Studio的API Key';
            
            // 清空之前的模型选择并添加Gemini模型
            const modelSelect = document.getElementById('model-select');
            modelSelect.innerHTML = `
                <option value="">请选择模型...</option>
                <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash (实验版) - 推荐</option>
                <option value="gemini-1.5-flash">Gemini 1.5 Flash - 快速</option>
                <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B - 轻量</option>
                <option value="gemini-1.5-pro">Gemini 1.5 Pro - 稳定</option>
                <option value="gemini-pro">Gemini Pro - 经典</option>
                <option value="gemini-pro-vision">Gemini Pro Vision - 视觉</option>
                <option value="手动输入模型名称">手动输入模型名称</option>
            `;
            
            // 添加手动输入功能
            modelSelect.onchange = function() {
                if (this.value === '手动输入模型名称') {
                    const customModel = prompt('请输入Gemini模型名称\n\n常见选项：\n• gemini-2.0-flash-exp\n• gemini-1.5-flash\n• gemini-1.5-pro\n• gemini-pro');
                    if (customModel && customModel.trim()) {
                        const newOption = new Option(customModel.trim(), customModel.trim());
                        this.insertBefore(newOption, this.lastElementChild);
                        this.value = customModel.trim();
                    } else {
                        this.value = '';
                    }
                }
            };
            
            showToast('🌟 Gemini直连配置已自动填写！\n\n使用说明：\n1. 请在Google AI Studio获取API Key\n2. 选择合适的模型\n3. 点击"测试连接"验证配置', 'success');
        }
        
        // 🤗 HuggingFace反代快速设置
        function setHuggingFaceProxy() {
            // 自动填充HuggingFace反代配置 - 使用正确的格式
            document.getElementById('api-base').value = 'https://xxx-xxx.hf.space/v1';
            document.getElementById('api-key').placeholder = '请输入HuggingFace的API Token';
            
            // 清空之前的模型选择并添加常见HF模型
            const modelSelect = document.getElementById('model-select');
            modelSelect.innerHTML = `
                <option value="">请选择模型...</option>
                <optgroup label="Llama系列">
                    <option value="meta-llama/Llama-2-7b-chat-hf">Llama-2-7b-chat-hf</option>
                    <option value="meta-llama/Llama-2-13b-chat-hf">Llama-2-13b-chat-hf</option>
                    <option value="meta-llama/Meta-Llama-3-8B-Instruct">Meta-Llama-3-8B-Instruct</option>
                </optgroup>
                <optgroup label="对话模型">
                <option value="microsoft/DialoGPT-large">DialoGPT-large</option>
                <option value="microsoft/DialoGPT-medium">DialoGPT-medium</option>
                    <option value="facebook/blenderbot-400M-distill">BlenderBot-400M</option>
                </optgroup>
                <optgroup label="通用模型">
                    <option value="mistralai/Mistral-7B-Instruct-v0.1">Mistral-7B-Instruct</option>
                    <option value="teknium/OpenHermes-2.5-Mistral-7B">OpenHermes-2.5-Mistral-7B</option>
                </optgroup>
                <optgroup label="自定义">
                    <option value="custom">手动输入模型名称...</option>
                </optgroup>
            `;
            
            // 添加自定义模型输入功能
            modelSelect.onchange = function() {
                if (this.value === 'custom') {
                    const customModel = prompt('请输入模型名称（例如：meta-llama/Llama-2-7b-chat-hf）：');
                    if (customModel && customModel.trim()) {
                        const newOption = new Option(customModel.trim(), customModel.trim());
                        this.insertBefore(newOption, this.lastElementChild);
                        this.value = customModel.trim();
                    } else {
                        this.value = '';
                    }
                }
            };
            
            showToast('🤗 HuggingFace反代配置已自动填写！\n\n请：\n1. 将地址中的 xxx-xxx 替换为实际的HF Space地址\n2. 选择模型或手动输入模型名称', 'success');
        }
        
        // 保存当前配置为预设
        function saveCurrentConfig() {
            const configName = document.getElementById('config-name-input').value.trim();
            
            if (!configName) {
                showToast('请输入配置名称', 'error');
                return;
            }
            
            const currentConfig = {
                name: configName,
                base: document.getElementById('api-base').value.trim(),
                key: document.getElementById('api-key').value.trim(),
                model: document.getElementById('model-select').value.trim(),
                temperature: parseFloat(document.getElementById('temperature-slider').value) || 0.75,
                savedAt: new Date().toLocaleString()
            };
            
            // 获取已保存的配置
            let savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            
            // 检查是否已存在同名配置
            const existingIndex = savedConfigs.findIndex(config => config.name === configName);
            if (existingIndex !== -1) {
                if (confirm(`配置"${configName}"已存在，是否覆盖？`)) {
                    savedConfigs[existingIndex] = currentConfig;
                } else {
                    return;
                }
            } else {
                savedConfigs.push(currentConfig);
            }
            
            localStorage.setItem('savedApiConfigs', JSON.stringify(savedConfigs));
            document.getElementById('config-name-input').value = '';
            
            renderSavedConfigs();
            showToast(`配置"${configName}"已保存`, 'success');
        }
        
        // 渲染已保存的配置
        function renderSavedConfigs() {
            const container = document.getElementById('saved-configs-container');
            const noConfigsMessage = document.getElementById('no-configs-message');
            const savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            
            if (savedConfigs.length === 0) {
                container.style.display = 'none';
                noConfigsMessage.style.display = 'block';
                return;
            }
            
            container.style.display = 'grid';
            noConfigsMessage.style.display = 'none';
            
            container.innerHTML = savedConfigs.map(config => `
                <div class="config-card" style="background: rgba(255,255,255,0.8); border-radius: 12px; padding: 15px; border: 1px solid rgba(0,0,0,0.05); transition: all 0.3s ease; cursor: pointer;" onclick="loadConfig('${config.name}')">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <div style="font-weight: 600; color: #333; font-size: 15px;">${config.name}</div>
                        <button onclick="event.stopPropagation(); deleteConfig('${config.name}')" style="background: none; border: none; color: #ff6b6b; cursor: pointer; padding: 2px 6px; border-radius: 4px; font-size: 12px; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(255,107,107,0.1)'" onmouseout="this.style.background='none'">🗑️</button>
                    </div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
                        <div>🌐 ${config.base}</div>
                        <div>🤖 ${config.model}</div>
                        <div>🌡️ 温度: ${config.temperature}</div>
                    </div>
                    <div style="font-size: 11px; color: #999;">保存于: ${config.savedAt}</div>
                </div>
            `).join('');
        }
        
        // 加载配置
        function loadConfig(configName) {
            const savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
            const config = savedConfigs.find(c => c.name === configName);
            
            if (!config) {
                showToast('配置不存在', 'error');
                return;
            }
            
            // 填充表单
            document.getElementById('api-base').value = config.base;
            document.getElementById('api-key').value = config.key;
            document.getElementById('temperature-slider').value = config.temperature;
            document.getElementById('temperature-value').textContent = config.temperature.toFixed(2);
            
            // 处理模型选择
            const modelSelect = document.getElementById('model-select');
            const existingOption = Array.from(modelSelect.options).find(option => option.value === config.model);
            if (!existingOption) {
                // 如果模型不在当前选项中，添加它
                const newOption = new Option(config.model, config.model);
                modelSelect.appendChild(newOption);
            }
            modelSelect.value = config.model;
            
            showToast(`已加载配置"${configName}"`, 'success');
        }
        
        // 删除配置
        function deleteConfig(configName) {
            if (confirm(`确定要删除配置"${configName}"吗？`)) {
                let savedConfigs = JSON.parse(localStorage.getItem('savedApiConfigs') || '[]');
                savedConfigs = savedConfigs.filter(config => config.name !== configName);
                localStorage.setItem('savedApiConfigs', JSON.stringify(savedConfigs));
                renderSavedConfigs();
                showToast(`配置"${configName}"已删除`, 'success');
            }
        }
        
        // 清空所有配置
        function clearAllConfigs() {
            if (confirm('确定要清空所有已保存的配置吗？此操作不可恢复。')) {
                localStorage.removeItem('savedApiConfigs');
                renderSavedConfigs();
                showToast('所有配置已清空', 'success');
            }
        }
        
        // 测试API连接
        async function testApiConnection() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            const model = document.getElementById('model-select').value.trim();
            
            if (!baseUrl || !apiKey || !model) {
                showToast('请先填写完整的API配置', 'error');
                return;
            }
            
            const testBtn = document.getElementById('test-api-connection-btn');
            const originalText = testBtn.textContent;
            testBtn.textContent = '测试中...';
            testBtn.disabled = true;
            
            try {
                // 根据不同的API类型构建测试请求
                let testUrl, testPayload, testHeaders;
                
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    // Gemini API测试
                    testUrl = `${baseUrl}/models/${model}:generateContent?key=${apiKey}`;
                    testPayload = {
                        contents: [{
                            parts: [{ text: "Hello" }]
                        }],
                        generationConfig: {
                            temperature: 0.7
                            // 不添加maxOutputTokens等Gemini不支持的参数
                        }
                    };
                    testHeaders = {
                        'Content-Type': 'application/json'
                    };
                } else {
                    // OpenAI兼容API测试 - 智能处理URL拼接
                    if (baseUrl.endsWith('/v1')) {
                        testUrl = `${baseUrl}/chat/completions`;
                    } else if (baseUrl.includes('/v1/')) {
                        // 修复：如果URL中已经包含/v1/路径，直接添加chat/completions
                        testUrl = `${baseUrl}/chat/completions`;
                    } else {
                        testUrl = `${baseUrl}/v1/chat/completions`;
                    }
                    testPayload = {
                        model: model,
                        messages: [{ role: "user", content: "Hello" }],
                        max_tokens: 10
                    };
                    testHeaders = {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    };
                }
                
                const response = await fetch(testUrl, {
                    method: 'POST',
                    headers: testHeaders,
                    body: JSON.stringify(testPayload)
                });
                
                if (response.ok) {
                    showToast('✅ API连接测试成功！', 'success');
                    
                    // 🔥【修复】测试成功后自动保存API设置，避免用户重复输入
                    apiSettings = {
                        base: baseUrl,
                        key: apiKey,
                        model: model,
                        temperature: parseFloat(document.getElementById('temperature-slider').value) || 0.75,
                        endpoint: '/chat/completions'
                    };
                    localStorage.setItem('apiSettings', JSON.stringify(apiSettings));
                    console.log('API设置已自动保存');
                } else {
                    const errorText = await response.text();
                    showToast(`❌ API连接失败: ${response.status} ${response.statusText}`, 'error');
                    console.error('API测试失败:', errorText);
                }
            } catch (error) {
                showToast(`❌ 连接错误: ${error.message}`, 'error');
                console.error('API测试错误:', error);
            } finally {
                testBtn.textContent = originalText;
                testBtn.disabled = false;
            }
        }
        
        // 获取模型列表
        async function fetchModels() {
            const baseUrl = document.getElementById('api-base').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            
            if (!baseUrl || !apiKey) {
                showToast('请先填写API地址和密钥', 'error');
                return;
            }
            
            const fetchBtn = document.getElementById('fetch-models-btn');
            const originalText = fetchBtn.textContent;
            fetchBtn.textContent = '获取中...';
            fetchBtn.disabled = true;
            
            try {
                let modelsUrl, headers;
                
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    // Gemini API
                    modelsUrl = `${baseUrl}/models?key=${apiKey}`;
                    headers = {};
                } else {
                    // OpenAI兼容API - 智能处理URL拼接
                    if (baseUrl.endsWith('/v1')) {
                        modelsUrl = `${baseUrl}/models`;
                    } else if (baseUrl.includes('/v1/')) {
                        // 修复：如果URL中已经包含/v1/路径，直接添加models
                        modelsUrl = `${baseUrl}/models`;
                    } else {
                        modelsUrl = `${baseUrl}/v1/models`;
                    }
                    headers = {
                        'Authorization': `Bearer ${apiKey}`
                    };
                }
                
                // 🔥【修复】移除超时控制，避免AbortError
                const response = await fetch(modelsUrl, { 
                    headers
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const modelSelect = document.getElementById('model-select');
                
                // 清空现有选项
                modelSelect.innerHTML = '<option value="">请选择模型...</option>';
                
                let models = [];
                if (data.models) {
                    // Gemini API格式 - 修复模型过滤逻辑
                    console.log('Gemini API响应数据:', data);
                    models = data.models
                        .filter(model => {
                            // 允许所有支持generateContent的模型
                            return model.name && (
                                model.name.includes('gemini') ||
                                model.name.includes('models/') ||
                                model.supportedGenerationMethods?.includes('generateContent') ||
                                model.name.includes('generate')
                            );
                        })
                        .map(model => {
                            // 提取模型名称，去掉前缀
                            const modelName = model.name.includes('/') 
                                ? model.name.split('/').pop() 
                                : model.name;
                            return modelName;
                        });
                        
                    // 如果过滤后没有模型，显示所有模型（调试用）
                    if (models.length === 0 && data.models.length > 0) {
                        console.log('过滤后没有模型，显示所有可用模型:', data.models);
                        models = data.models.map(model => 
                            model.name.includes('/') ? model.name.split('/').pop() : model.name
                        );
                    }
                } else if (data.data) {
                    // OpenAI API格式
                    models = data.data.map(model => model.id);
                }
                
                models.forEach(modelId => {
                    const option = new Option(modelId, modelId);
                    modelSelect.appendChild(option);
                });
                
                showToast(`✅ 成功获取到 ${models.length} 个模型`, 'success');
            } catch (error) {
                let errorMessage = error.message;
                
                if (errorMessage.includes('Failed to fetch') || errorMessage.includes('ERR_TIMED_OUT')) {
                    if (baseUrl.includes('.hf.space')) {
                        errorMessage = 'HuggingFace Space连接超时，可能需要先启动服务或检查网络连接。\n\n💡 建议：\n1. 检查HF Space是否正在运行\n2. 尝试先手动访问该URL测试连接\n3. 如果服务不支持/models端点，请手动输入模型名称';
                    } else {
                        errorMessage = '网络连接失败，请检查URL是否正确以及网络连接';
                    }
                }
                
                showToast(`❌ 获取模型失败: ${errorMessage}`, 'error');
                console.error('获取模型失败:', error);
                
                // 为Gemini提供常见模型选项作为后备
                if (baseUrl.includes('generativelanguage.googleapis.com')) {
                    const modelSelect = document.getElementById('model-select');
                    modelSelect.innerHTML = `
                        <option value="">请选择模型...</option>
                        <option value="gemini-2.0-flash-exp">Gemini 2.0 Flash (实验版)</option>
                        <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                        <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash 8B</option>
                        <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                        <option value="gemini-pro">Gemini Pro</option>
                        <option value="gemini-pro-vision">Gemini Pro Vision</option>
                        <option value="手动输入模型名称">手动输入模型名称</option>
                    `;
                    setTimeout(() => {
                        showToast('💡 已为您提供常见Gemini模型选项', 'info');
                    }, 1000);
                }
                
                // 如果是HF Space，给出额外提示
                if (baseUrl.includes('.hf.space')) {
                    setTimeout(() => {
                        showToast('💡 提示：HuggingFace Space可能不支持自动获取模型列表，建议手动输入模型名称', 'info');
                    }, 2000);
                }
            } finally {
                fetchBtn.textContent = originalText;
                fetchBtn.disabled = false;
            }
        }
        
        // 导出完整备份
        function exportFullBackup() {
            // 这里可以实现完整的数据导出功能
            showToast('导出功能开发中...', 'info');
        }
        
        // 导入完整备份
        function importFullBackup() {
            // 这里可以实现完整的数据导入功能
            document.getElementById('import-full-backup-input').click();
        }
        
        // 初始化API设置界面
        function initializeApiSettings() {
            // 加载已保存的API配置
            loadApiSettings();
            
            // 渲染已保存的配置
            renderSavedConfigs();
        }
        
        // 🔥【修复】加载API设置并自动拉取模型
        function loadApiSettings() {
            const savedSettings = localStorage.getItem('apiSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    console.log('🔧 [API设置] 加载已保存的API设置:', settings);
                    
                    // 填充表单字段
                    if (settings.base) {
                        const baseInput = document.getElementById('api-base');
                        if (baseInput) baseInput.value = settings.base;
                    }
                    
                    if (settings.key) {
                        const keyInput = document.getElementById('api-key');
                        if (keyInput) keyInput.value = settings.key;
                    }
                    
                    if (settings.temperature !== undefined) {
                        const tempSlider = document.getElementById('temperature-slider');
                        const tempValue = document.getElementById('temperature-value');
                        if (tempSlider && tempValue) {
                            tempSlider.value = settings.temperature;
                            tempValue.textContent = settings.temperature.toFixed(2);
                        }
                    }
                    
                    // 🔥【重要修复】如果有保存的API设置，自动拉取模型列表
                    if (settings.base && settings.key) {
                        console.log('🔧 [API设置] 检测到完整的API配置，自动拉取模型列表');
                        
                        // 延迟一点执行，确保UI已经加载完成
                        setTimeout(() => {
                            fetchModels().then(() => {
                                // 拉取完成后，如果有保存的模型，选中它
                    if (settings.model) {
                        const modelSelect = document.getElementById('model-select');
                        if (modelSelect) {
                            // 如果模型不在选项中，添加它
                            const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                            if (!existingOption) {
                                const newOption = new Option(settings.model, settings.model);
                                modelSelect.appendChild(newOption);
                            }
                            modelSelect.value = settings.model;
                                        console.log('🔧 [API设置] 已自动选中保存的模型:', settings.model);
                                    }
                                }
                            }).catch(error => {
                                console.log('🔧 [API设置] 自动拉取模型失败，但会保留已保存的模型选项');
                                // 即使拉取失败，也要恢复保存的模型选项
                                if (settings.model) {
                                    const modelSelect = document.getElementById('model-select');
                                    if (modelSelect) {
                                        const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                                        if (!existingOption) {
                                            const newOption = new Option(settings.model, settings.model);
                                            modelSelect.appendChild(newOption);
                                        }
                                        modelSelect.value = settings.model;
                                        console.log('🔧 [API设置] 已恢复保存的模型选项:', settings.model);
                                    }
                                }
                            });
                        }, 500);
                    } else {
                        // 没有完整的API配置时，仍然要恢复保存的模型选项
                        if (settings.model) {
                            const modelSelect = document.getElementById('model-select');
                            if (modelSelect) {
                                const existingOption = Array.from(modelSelect.options).find(option => option.value === settings.model);
                                if (!existingOption) {
                                    const newOption = new Option(settings.model, settings.model);
                                    modelSelect.appendChild(newOption);
                                }
                                modelSelect.value = settings.model;
                                console.log('🔧 [API设置] 已恢复保存的模型选项（无自动拉取）:', settings.model);
                            }
                        }
                    }
                } catch (error) {
                    console.error('加载API设置失败:', error);
                }
            }
        }
        
        // 电池管理功能
        async function initBatteryManager() {
            console.log('开始初始化电池管理器...');
            
            // 首先设置默认显示为 ᰔᩚ
            const allBatteryTexts = document.querySelectorAll('.battery-text');
            console.log('找到的电池文本元素数量:', allBatteryTexts.length);
            
            allBatteryTexts.forEach((element, index) => {
                console.log(`设置电池文本 ${index}:`, element);
                element.textContent = 'ᰔᩚ';
            });
            
            if ('getBattery' in navigator) {
                try {
                    console.log('浏览器支持电池API，正在获取电池信息...');
                    const battery = await navigator.getBattery();
                    console.log('电池信息:', {
                        level: battery.level,
                        charging: battery.charging
                    });
                    updateBatteryDisplay(battery);
                    
                    battery.addEventListener('levelchange', () => updateBatteryDisplay(battery));
                    battery.addEventListener('chargingchange', () => updateBatteryDisplay(battery));
                } catch (err) {
                    console.error("无法获取电池信息:", err);
                    // 保持默认显示 ᰔᩚ
                    allBatteryTexts.forEach(element => {
                        element.textContent = 'ᰔᩚ';
                    });
                }
            } else {
                console.log("浏览器不支持电池状态API，使用默认显示。");
                // 保持默认显示 ᰔᩚ
                allBatteryTexts.forEach(element => {
                    element.textContent = 'ᰔᩚ';
                });
            }
        }
        
        function updateBatteryDisplay(battery) {
            const level = Math.floor(battery.level * 100);
            const isCharging = battery.charging;
            
            console.log(`更新电池显示: ${level}%, 充电中: ${isCharging}`);
            
            // 更新主状态栏电池
            const batteryContainer = document.getElementById('status-bar-battery');
            console.log('主状态栏电池容器:', batteryContainer);
            
            if (batteryContainer) {
                const batteryLevelEl = batteryContainer.querySelector('.battery-level');
                const batteryTextEl = batteryContainer.querySelector('.battery-text');
                
                console.log('电池元素:', { batteryLevelEl, batteryTextEl });
                
                if (batteryLevelEl && batteryTextEl) {
                    batteryLevelEl.style.width = `${level}%`;
                    batteryTextEl.textContent = `${level}%`;
                    console.log(`设置主屏幕电池文本为: ${level}%`);
                    
                    if (isCharging) {
                        batteryContainer.classList.add('charging');
                    } else {
                        batteryContainer.classList.remove('charging');
                    }
                }
            }
            
            // 更新应用内状态栏电池
            const appBatteryContainers = document.querySelectorAll('.app-battery-container');
            const appBatteryTexts = document.querySelectorAll('.app-battery-container .battery-text');
            const appBatteryLevels = document.querySelectorAll('.app-battery-level');
            
            // 应用内也显示真实电量
            appBatteryTexts.forEach(element => {
                element.textContent = `${level}%`;
            });
            
            appBatteryLevels.forEach(element => {
                element.style.width = `${level}%`;
            });
            
            // 同步应用内电池充电状态
            appBatteryContainers.forEach(container => {
                if (isCharging) {
                    container.classList.add('charging');
                } else {
                    container.classList.remove('charging');
                }
            });
        }
        
        // 手动测试电池显示功能 - 您可以在浏览器控制台中调用这个函数
        function testBatteryDisplay() {
            console.log('=== 电池显示测试开始 ===');
            
            // 检查电池文本元素
            const allBatteryTexts = document.querySelectorAll('.battery-text');
            console.log('所有电池文本元素:', allBatteryTexts);
            
            allBatteryTexts.forEach((element, index) => {
                console.log(`电池文本 ${index}:`, element, '当前内容:', element.textContent);
            });
            
            // 检查主屏幕电池容器
            const mainBattery = document.getElementById('status-bar-battery');
            console.log('主屏幕电池容器:', mainBattery);
            
            if (mainBattery) {
                const batteryText = mainBattery.querySelector('.battery-text');
                console.log('主屏幕电池文本元素:', batteryText);
                console.log('主屏幕电池文本内容:', batteryText ? batteryText.textContent : 'null');
            }
            
            // 测试设置为百分比
            console.log('测试设置为77%...');
            allBatteryTexts.forEach((element, index) => {
                element.textContent = '77%';
                console.log(`电池文本 ${index} 设置为 77%`);
            });
            
            // 3秒后恢复为爱心
            setTimeout(() => {
                console.log('恢复为爱心符号...');
                allBatteryTexts.forEach((element, index) => {
                    element.textContent = 'ᰔᩚ';
                    console.log(`电池文本 ${index} 恢复为 ᰔᩚ`);
                });
            }, 3000);
            
            console.log('=== 电池显示测试结束 ===');
        }
        
        // 主题切换功能
        function changeTheme(themeName) {
            const body = document.body;
            
            // 移除之前的主题
            body.removeAttribute('data-theme');
            
            // 应用新主题
            if (themeName !== 'default') {
                body.setAttribute('data-theme', themeName);
            }
            
            // 保存主题设置
            localStorage.setItem('selectedTheme', themeName);
            
            // 给用户反馈
            const themeNames = {
                'default': '简约风格',
                'cute': '可爱风格',
                'nature': '自然风格', 
                'tech': '科技风格',
                'dream': '梦幻风格'
            };
            
            // 显示Toast提示
            showToast(`已切换到 ${themeNames[themeName]} 主题！`, 'success');
        }
        
        // 加载保存的主题
        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('selectedTheme');
            if (savedTheme && savedTheme !== 'default') {
                document.body.setAttribute('data-theme', savedTheme);
            }
        }
        
        // 世界书相关功能
        let worldbooks = [];
        let editingWorldbook = null;
        
        // 加载世界书数据 - 使用IndexedDB（包含数据迁移）
        async function loadWorldbooks() {
            try {
                // 先从IndexedDB加载
                const savedWorldbooks = await db.worldbooks.toArray();
                
                if (savedWorldbooks.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('worldbooks');
                    if (localStorageData) {
                        console.log('检测到localStorage中的世界书数据，开始迁移...');
                        const localWorldbooks = JSON.parse(localStorageData);
                        
                        if (localWorldbooks.length > 0) {
                            // 确保每个世界书都有id字段
                            const migrationData = localWorldbooks.map(wb => ({
                                id: wb.id || Date.now().toString() + Math.random(),
                                title: wb.title,
                                content: wb.content,
                                createdAt: wb.createdAt || new Date().toISOString(),
                                updatedAt: wb.updatedAt || new Date().toISOString()
                            }));
                            
                            // 迁移到IndexedDB
                            await db.worldbooks.bulkAdd(migrationData);
                            worldbooks = migrationData;
                            console.log('世界书数据迁移完成:', worldbooks);
                        } else {
                            worldbooks = [];
                        }
                    } else {
                        worldbooks = [];
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    worldbooks = savedWorldbooks;
                    console.log('从IndexedDB加载世界书数据:', worldbooks);
                }
                
                // 🔥 检查并迁移旧的角色世界书数据
                await migrateOldCharacterWorldbooks();
                
            } catch (error) {
                console.error('加载世界书失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('worldbooks');
                if (localStorageData) {
                    try {
                        worldbooks = JSON.parse(localStorageData);
                } catch (e) {
                        worldbooks = [];
                    }
                } else {
                    worldbooks = [];
                }
                
                // 也为localStorage数据进行迁移
                await migrateOldCharacterWorldbooks();
            }
            renderWorldbookList();
        }

        // 迁移旧的角色世界书数据
        async function migrateOldCharacterWorldbooks() {
            let migrationCount = 0;
            let needsSave = false;

            worldbooks.forEach(worldbook => {
                // 检查是否是旧的角色世界书（通过名称模式识别）
                if (!worldbook.source && !worldbook.isGlobal && worldbook.name && worldbook.name.includes('[') && worldbook.name.includes(']')) {
                    // 解析角色名称
                    const match = worldbook.name.match(/^\[(.+?)\]/);
                    if (match) {
                        const characterName = match[1];
                        console.log(`🔄 迁移旧的角色世界书: ${worldbook.name} -> 分类: ${characterName}`);
                        
                        worldbook.source = 'character_card';
                        worldbook.category = characterName;
                        migrationCount++;
                        needsSave = true;
                    }
                }
                
                // 检查是否缺少必要的字段并修复
                if (!worldbook.id) {
                    worldbook.id = Date.now().toString() + Math.random();
                    needsSave = true;
                }
                if (!worldbook.title && worldbook.name) {
                    worldbook.title = worldbook.name;
                    needsSave = true;
                }
            });

            if (needsSave) {
                console.log(`📦 迁移完成，共迁移 ${migrationCount} 个角色世界书`);
                await saveWorldbooks();
                if (migrationCount > 0) {
                    showToast(`已自动迁移${migrationCount}个角色世界书到新分类`, 'success');
                }
            }
        }
        
        // 保存世界书数据 - 使用IndexedDB
        async function saveWorldbooks() {
            try {
                console.log('保存世界书数据到IndexedDB:', worldbooks);
                
                // 清空现有数据
                await db.worldbooks.clear();
                
                // 批量插入新数据
                if (worldbooks.length > 0) {
                    await db.worldbooks.bulkAdd(worldbooks);
                }
                
                console.log('世界书数据保存成功');
            } catch (error) {
                console.error('保存世界书时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            localStorage.setItem('worldbooks', JSON.stringify(worldbooks));
            }
        }
        
        function showWorldbookForm(isGlobal, characterCategory = null) {
    // 根据传入的类型来决定表单标题
    let title;
    if (isGlobal) {
        title = '新建全局设定';
    } else if (characterCategory) {
        title = `新建${characterCategory}的世界书`;
    } else {
        title = '新建局部设定';
    }
    document.getElementById('worldbook-form-title').textContent = title;

    editingWorldbook = null; // 清除编辑状态
            document.getElementById('worldbook-title').value = '';
            document.getElementById('worldbook-content').value = '';

    // 将创建类型暂存起来，以便保存时使用
    window.newWorldbookIsGlobal = isGlobal;
    window.newWorldbookCharacterCategory = characterCategory;

            showApp('worldbook-form-screen');
        }
        
        function hideWorldbookForm() {
            hideApp('worldbook-form-screen');
            // 确保返回到世界书应用，而不是主屏幕
            showApp('worldbook-screen');
        }
        
        async function saveWorldbook() {
            const title = document.getElementById('worldbook-title').value.trim();
            const content = document.getElementById('worldbook-content').value.trim();
            
    if (!title || !content) {
        alert('请输入标题和内容');
                return;
            }
            
    let isGlobal;
    if (editingWorldbook) {
        // 如果是编辑模式，保持其原有的类型不变
        isGlobal = editingWorldbook.isGlobal;
    } else {
        // 如果是新建模式，读取我们暂存的类型
        isGlobal = window.newWorldbookIsGlobal;
            }
            
            const worldbook = {
                id: editingWorldbook ? editingWorldbook.id : Date.now().toString(),
                title: title,
                content: content,
        isGlobal: isGlobal, // 根据正确的状态设置
                createdAt: editingWorldbook ? editingWorldbook.createdAt : new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };

            // 如果是角色分类的世界书，添加分类信息
            if (!isGlobal && window.newWorldbookCharacterCategory) {
                worldbook.category = window.newWorldbookCharacterCategory;
                worldbook.source = 'character_card';
            }
            
            if (editingWorldbook) {
                const index = worldbooks.findIndex(w => w.id === editingWorldbook.id);
        if (index !== -1) worldbooks[index] = worldbook;
            } else {
                worldbooks.push(worldbook);
            }
            
            await saveWorldbooks();
            renderWorldbookList();
            showToast(editingWorldbook ? '世界书已更新！' : '世界书已创建！', 'success');
            hideWorldbookForm();
        }
// --- 新增函数 ---
async function toggleGlobalWorldbook(bookId, isEnabled) {
    // 确保window.activeGlobalWorldbooks存在
    if (!window.activeGlobalWorldbooks) {
        window.activeGlobalWorldbooks = [];
    }
    
    if (isEnabled) {
        // 如果开启，添加到激活列表（如果不存在）
        if (!window.activeGlobalWorldbooks.includes(bookId)) {
            window.activeGlobalWorldbooks.push(bookId);
        }
    } else {
        // 如果关闭，从激活列表中移除
        window.activeGlobalWorldbooks = window.activeGlobalWorldbooks.filter(id => id !== bookId);
    }
    
    // 保存激活状态到数据库的 globalSettings 表
    try {
        await db.globalSettings.put({
            id: 'main',
            activeGlobalWorldbooks: window.activeGlobalWorldbooks
        });
        console.log('全局世界书设置已保存:', window.activeGlobalWorldbooks);
        showToast('全局设定已更新', 'success');
    } catch (error) {
        console.error("保存全局世界书设置失败:", error);
        showToast('设置保存失败', 'error');
    }
        }
        
        function editWorldbook(id) {
            const worldbook = worldbooks.find(w => w.id === id);
            if (worldbook) {
                editingWorldbook = worldbook;
        // 编辑时不显示“新建”，而是“编辑”
        let title;
        if (worldbook.isGlobal) {
            title = '编辑全局设定';
        } else if (worldbook.source === 'character_card' && worldbook.category) {
            title = `编辑${worldbook.category}的世界书`;
        } else {
            title = '编辑局部设定';
        }
        document.getElementById('worldbook-form-title').textContent = title;
                document.getElementById('worldbook-title').value = worldbook.title || worldbook.name;
                document.getElementById('worldbook-content').value = worldbook.content;
                showApp('worldbook-form-screen');
            }
        }
        
        async function deleteWorldbook(id) {
            if (confirm('确定要删除这个世界书吗？')) {
                console.log('🗑️ 删除世界书:', id);
                console.log('删除前的世界书列表:', worldbooks.map(w => ({id: w.id, name: w.name || w.title})));
                
                // 从内存数组中删除
                const initialLength = worldbooks.length;
                worldbooks = worldbooks.filter(w => w.id !== id);
                const finalLength = worldbooks.length;
                
                console.log(`删除操作: ${initialLength} -> ${finalLength}, 删除了 ${initialLength - finalLength} 个项目`);
                
                if (initialLength === finalLength) {
                    console.warn('⚠️ 删除失败：未找到要删除的世界书');
                    showToast('删除失败：未找到指定的世界书', 'error');
                    return;
                }
                
                // 保存到数据库
                try {
                    await saveWorldbooks();
                    console.log('✅ 世界书删除成功');
                    showToast('世界书已删除', 'success');
                } catch (error) {
                    console.error('❌ 删除世界书时数据库保存失败:', error);
                    showToast('删除失败：数据库保存错误', 'error');
                }
                
                // 重新渲染列表
                renderWorldbookList();
            }
        }
        
// 用这段新代码，完整替换掉旧的 renderWorldbookList 函数
        function renderWorldbookList() {
    const globalContainer = document.getElementById('global-worldbooks-content');
    const localContainer = document.getElementById('local-worldbooks-content');
    const characterContainer = document.getElementById('character-worldbooks-content');
    if (!globalContainer || !localContainer || !characterContainer) return;

    const globalBooks = worldbooks.filter(w => w.isGlobal);
    const localBooks = worldbooks.filter(w => !w.isGlobal && (!w.source || w.source !== 'character_card'));
    
    // 获取当前选择的角色分类的世界书
    let characterBooks = [];
    if (currentCharacterCategory) {
        characterBooks = worldbooks.filter(w => 
            !w.isGlobal && 
            w.source === 'character_card' && 
            w.category === currentCharacterCategory
        );
    }

    let globalHtml = '';
    let localHtml = '';
    let characterHtml = '';

    // --- 渲染全局世界书 ---
    globalHtml += `<div class="worldbook-section">`;
    if (globalBooks.length > 0) {
        globalBooks.forEach(book => {
            // 确保使用window.activeGlobalWorldbooks并检查其是否为数组
            const isChecked = Array.isArray(window.activeGlobalWorldbooks) && window.activeGlobalWorldbooks.includes(book.id) ? 'checked' : '';
            globalHtml += `
                <div class="setting-item" onclick="editWorldbook('${book.id}')">
                    <div class="setting-left">
                        <div class="setting-label">${book.title || book.name}</div>
                        <div class="setting-desc">${truncateText(book.content, 60)}</div>
                    </div>
                    <div class="setting-right">
                        <label class="toggle-switch" onclick="event.stopPropagation()">
                            <input type="checkbox" onchange="toggleGlobalWorldbook('${book.id}', this.checked)" ${isChecked}>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            `;
        });
    } else {
        globalHtml += '<div class="empty-message">暂无全局设定</div>';
    }
    globalHtml += '</div>';

    // --- 渲染局部世界书 ---
    localHtml += `<div class="worldbook-section">`;
    if (localBooks.length > 0) {
        localBooks.forEach(book => {
            const date = new Date(book.updatedAt || book.createdAt || Date.now()).toLocaleDateString();
            const preview = truncateText(book.content, 60);
            localHtml += `
                <div class="worldbook-item" onclick="editWorldbook('${book.id}')">
                    <div class="worldbook-header">
                        <div class="worldbook-content-flex">
                            <div class="worldbook-title">${book.title || book.name}</div>
                            <div class="worldbook-desc-text">${preview}</div>
                            <div class="worldbook-date-text">更新于 ${date}</div>
                        </div>
                        <button onclick="event.stopPropagation(); deleteWorldbook('${book.id}')" class="delete-worldbook-btn">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        });
    } else {
        localHtml += '<div class="empty-message">暂无局部设定</div>';
    }
    localHtml += '</div>';

    // --- 渲染角色世界书 ---
    characterHtml += `<div class="worldbook-section">`;
    if (characterBooks.length > 0) {
        characterBooks.forEach(book => {
            const date = new Date(book.updatedAt || book.createdAt || Date.now()).toLocaleDateString();
            const preview = truncateText(book.content, 60);
            characterHtml += `
                <div class="worldbook-item" onclick="editWorldbook('${book.id}')">
                    <div class="worldbook-header">
                        <div class="worldbook-content-flex">
                            <div class="worldbook-title">${book.title || book.name}</div>
                            <div class="worldbook-desc-text">${preview}</div>
                            <div class="worldbook-date-text">更新于 ${date}</div>
                            <div class="worldbook-source-text">来源: 角色卡导入</div>
                        </div>
                        <button onclick="event.stopPropagation(); deleteWorldbook('${book.id}')" class="delete-worldbook-btn">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        });
    } else {
        const categoryText = currentCharacterCategory ? `"${currentCharacterCategory}"` : '该角色';
        characterHtml += `<div class="empty-message">暂无${categoryText}的世界书设定</div>`;
    }
    characterHtml += '</div>';

    globalContainer.innerHTML = globalHtml;
    localContainer.innerHTML = localHtml;
    characterContainer.innerHTML = characterHtml;
}
function switchWorldbookTab(tabName, characterCategory = null) {
    currentWorldbookTab = tabName; // <--- 核心修改：记录当前标签页
    currentCharacterCategory = characterCategory; // 记录当前选择的角色分类

    const globalContent = document.getElementById('global-worldbooks-content');
    const localContent = document.getElementById('local-worldbooks-content');
    const characterContent = document.getElementById('character-worldbooks-content');
    const tabs = document.querySelectorAll('.worldbook-tab');

    tabs.forEach(tab => {
        if (tab.getAttribute('onclick').includes(tabName)) {
            tab.classList.add('active');
        } else {
            tab.classList.remove('active');
        }
    });

    // 隐藏所有内容面板
    globalContent.style.display = 'none';
    localContent.style.display = 'none';
    characterContent.style.display = 'none';

    if (tabName === 'global') {
        globalContent.style.display = 'block';
    } else if (tabName === 'local') {
        localContent.style.display = 'block';
    } else if (tabName === 'character') {
        if (characterCategory) {
            // 直接显示指定角色的世界书
            characterContent.style.display = 'block';
            document.getElementById('character-tab-text').textContent = characterCategory;
        } else {
            // 显示角色分类选择器
            showCategorySelector();
            return;
        }
    }

    renderWorldbookList();
}
function onWorldbookAddClick() {
    if (currentWorldbookTab === 'global') {
        showWorldbookForm(true); // 创建全局设定
    } else if (currentWorldbookTab === 'local') {
        showWorldbookForm(false); // 创建局部设定
    } else if (currentWorldbookTab === 'character') {
        // 为当前角色分类创建世界书
        showWorldbookForm(false, currentCharacterCategory);
    }
        }

        // 显示角色分类选择器
        function showCategorySelector() {
            // 获取所有角色世界书的分类
            const characterWorldBooks = worldbooks.filter(w => w.source === 'character_card');
            const categories = [...new Set(characterWorldBooks.map(w => w.category))].filter(Boolean);
            
            const categoryOptions = document.getElementById('category-options');
            const selector = document.getElementById('worldbook-category-selector');
            
            if (categories.length === 0) {
                categoryOptions.innerHTML = '<div class="empty-category-message">暂无角色世界书<br/>请先导入包含世界书的角色卡</div>';
            } else {
                categoryOptions.innerHTML = categories.map(category => {
                    const count = characterWorldBooks.filter(w => w.category === category).length;
                    return `
                        <div class="category-option" onclick="selectCategory('${category}')">
                            <div class="category-name">${category}</div>
                            <div class="category-count">${count}个设定</div>
                        </div>
                    `;
                }).join('');
            }
            
            selector.style.display = 'flex';
        }

        // 隐藏角色分类选择器
        function hideCategorySelector() {
            document.getElementById('worldbook-category-selector').style.display = 'none';
            // 回到之前的标签页
            if (currentWorldbookTab === 'character') {
                currentWorldbookTab = 'local';
                switchWorldbookTab('local');
            }
        }

        // 选择角色分类
        function selectCategory(category) {
            hideCategorySelector();
            switchWorldbookTab('character', category);
        }

        // 手动触发数据迁移（调试用）
        async function manualMigrateWorldbooks() {
            console.log('🔧 手动触发世界书数据迁移...');
            await migrateOldCharacterWorldbooks();
            renderWorldbookList();
            console.log('🔧 手动迁移完成');
        }

        // 调试：查看所有世界书数据
        function debugWorldbooks() {
            console.log('📋 当前所有世界书数据:');
            worldbooks.forEach((wb, index) => {
                console.log(`${index + 1}. ID: "${wb.id}", 名称: "${wb.name || wb.title}", 来源: "${wb.source}", 分类: "${wb.category}", 全局: ${wb.isGlobal}`);
            });
            console.log(`总计: ${worldbooks.length} 个世界书`);
            return worldbooks;
        }

        // 强制删除所有角色世界书
        async function forceDeleteCharacterWorldbooks() {
            console.log('🚨 强制删除所有角色世界书...');
            const beforeCount = worldbooks.length;
            
            // 删除所有包含 [角色名] 格式的世界书
            worldbooks = worldbooks.filter(wb => {
                const isCharacterBook = (wb.name && wb.name.includes('[') && wb.name.includes(']')) || 
                                       (wb.title && wb.title.includes('[') && wb.title.includes(']')) ||
                                       (wb.source === 'character_card');
                return !isCharacterBook;
            });
            
            const afterCount = worldbooks.length;
            const deletedCount = beforeCount - afterCount;
            
            console.log(`删除了 ${deletedCount} 个角色世界书`);
            
            // 保存到数据库
            await saveWorldbooks();
            renderWorldbookList();
            showToast(`强制删除了${deletedCount}个角色世界书`, 'success');
            
            return deletedCount;
        }

        // 清空所有世界书（终极方案）
        async function clearAllWorldbooks() {
            if (confirm('⚠️ 确定要删除所有世界书吗？这个操作不可撤销！')) {
                console.log('💣 清空所有世界书...');
                const count = worldbooks.length;
                worldbooks = [];
                await saveWorldbooks();
                renderWorldbookList();
                showToast(`已清空所有${count}个世界书`, 'success');
                console.log('✅ 所有世界书已清空');
            }
        }

        // 修复世界书ID问题
        async function fixWorldbookIds() {
            console.log('🔧 修复世界书ID问题...');
            let fixedCount = 0;
            
            worldbooks.forEach((wb, index) => {
                if (!wb.id || typeof wb.id !== 'string') {
                    wb.id = `fixed_${Date.now()}_${index}`;
                    fixedCount++;
                    console.log(`修复了世界书 "${wb.name || wb.title}" 的ID`);
                }
            });
            
            if (fixedCount > 0) {
                await saveWorldbooks();
                renderWorldbookList();
                showToast(`修复了${fixedCount}个世界书的ID`, 'success');
            } else {
                console.log('所有世界书ID都正常');
            }
            
            return fixedCount;
        }
        
        // 音乐应用相关功能
        let playlist = [];
        let currentSong = null;
        let isPlaying = false;
        let listeningCharacters = [];
        
        function loadMusicData() {
            const savedPlaylist = localStorage.getItem('musicPlaylist');
            if (savedPlaylist) {
                try {
                    playlist = JSON.parse(savedPlaylist);
                } catch (e) {
                    playlist = [];
                }
            }
            
            const savedListeners = localStorage.getItem('listeningCharacters');
            if (savedListeners) {
                try {
                    listeningCharacters = JSON.parse(savedListeners);
                } catch (e) {
                    listeningCharacters = [];
                }
            }
            
            renderPlaylist();
            renderListeningCharacters();
        }
        
        function saveMusicData() {
            localStorage.setItem('musicPlaylist', JSON.stringify(playlist));
            localStorage.setItem('listeningCharacters', JSON.stringify(listeningCharacters));
        }
        
        function addMusicToPlaylist() {
            const title = prompt('请输入歌曲名称:');
            if (title && title.trim()) {
                const artist = prompt('请输入艺术家名称:') || '未知艺术家';
                const song = {
                    id: Date.now().toString(),
                    title: title.trim(),
                    artist: artist.trim(),
                    duration: '3:30' // 模拟时长
                };
                
                playlist.push(song);
                saveMusicData();
                renderPlaylist();
            }
        }
        
        function playSong(songId) {
            const song = playlist.find(s => s.id === songId);
            if (song) {
                currentSong = song;
                document.getElementById('song-title').textContent = song.title;
                document.getElementById('artist-name').textContent = song.artist;
                document.getElementById('total-time').textContent = song.duration;
                
                // 更新播放按钮
                const playBtn = document.getElementById('play-pause-btn');
                playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                isPlaying = true;
                
                // 模拟播放进度
                simulatePlayback();
                
                // 通知听歌角色
                notifyListeningCharacters(song);
            }
        }
        
        function togglePlayPause() {
            const playBtn = document.getElementById('play-pause-btn');
            if (isPlaying) {
                playBtn.innerHTML = '<i class="fas fa-play"></i>';
                isPlaying = false;
            } else {
                if (currentSong) {
                    playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    isPlaying = true;
                    simulatePlayback();
                } else if (playlist.length > 0) {
                    playSong(playlist[0].id);
                }
            }
        }
        
        function previousSong() {
            if (!currentSong || playlist.length === 0) return;
            
            const currentIndex = playlist.findIndex(s => s.id === currentSong.id);
            const prevIndex = currentIndex > 0 ? currentIndex - 1 : playlist.length - 1;
            playSong(playlist[prevIndex].id);
        }
        
        function nextSong() {
            if (!currentSong || playlist.length === 0) return;
            
            const currentIndex = playlist.findIndex(s => s.id === currentSong.id);
            const nextIndex = currentIndex < playlist.length - 1 ? currentIndex + 1 : 0;
            playSong(playlist[nextIndex].id);
        }
        
        function simulatePlayback() {
            if (!isPlaying) return;
            
            // 这里只是模拟进度，实际应用中需要真实的音频播放
            let progress = 0;
            const interval = setInterval(() => {
                if (!isPlaying) {
                    clearInterval(interval);
                    return;
                }
                
                progress += 1;
                document.getElementById('progress').style.width = `${Math.min(progress, 100)}%`;
                
                const currentMinutes = Math.floor(progress * 3.5 / 100);
                const currentSeconds = Math.floor((progress * 3.5 / 100 - currentMinutes) * 60);
                document.getElementById('current-time').textContent = 
                    `${currentMinutes}:${currentSeconds.toString().padStart(2, '0')}`;
                
                if (progress >= 100) {
                    clearInterval(interval);
                    nextSong();
                }
            }, 100);
        }
        
        function inviteCharacterToListen() {
            const availableCharacters = characters.filter(c => 
                !listeningCharacters.find(lc => lc.id === c.id)
            );
            
            if (availableCharacters.length === 0) {
                alert('没有可邀请的角色了，或者所有角色都已经在听歌');
                return;
            }
            
            const characterNames = availableCharacters.map((c, index) => `${index + 1}. ${c.name}`).join('\n');
            const choice = prompt(`选择要邀请的角色:\n${characterNames}\n\n请输入数字:`);
            
            if (choice && !isNaN(choice)) {
                const index = parseInt(choice) - 1;
                if (index >= 0 && index < availableCharacters.length) {
                    const character = availableCharacters[index];
                    listeningCharacters.push({
                        id: character.id,
                        name: character.name,
                        avatar: character.avatarUrl || character.name.charAt(0),
                        joinedAt: new Date().toISOString()
                    });
                    
                    saveMusicData();
                    renderListeningCharacters();
                    
                    // 模拟角色响应
                    setTimeout(() => {
                        alert(`${character.name}: 好的，我来和你一起听歌！`);
                    }, 500);
                }
            }
        }
        
        function removeListeningCharacter(characterId) {
            listeningCharacters = listeningCharacters.filter(c => c.id !== characterId);
            saveMusicData();
            renderListeningCharacters();
        }
        
        function notifyListeningCharacters(song) {
            listeningCharacters.forEach(character => {
                // 模拟角色对音乐的反应
                const reactions = [
                    `${character.name}: 这首歌真好听！`,
                    `${character.name}: 我也很喜欢这首《${song.title}》`,
                    `${character.name}: 听着这音乐心情真好～`,
                    `${character.name}: 谢谢分享这么棒的音乐！`
                ];
                
                const reaction = reactions[Math.floor(Math.random() * reactions.length)];
                
                setTimeout(() => {
                    // 可以在这里显示角色的反应消息
                    console.log(reaction);
                }, Math.random() * 3000 + 1000);
            });
        }
        
        function renderPlaylist() {
            const playlistContainer = document.getElementById('playlist');
            if (!playlistContainer) return;
            
            if (playlist.length === 0) {
                playlistContainer.innerHTML = '<div class="empty-playlist">播放列表为空，点击+号添加音乐</div>';
                return;
            }
            
            const html = playlist.map(song => `
                <div class="playlist-item" onclick="playSong('${song.id}')">
                    <div>
                        <div class="song-title">${song.title}</div>
                        <div class="song-artist">${song.artist}</div>
                    </div>
                    <div class="song-duration">${song.duration}</div>
                </div>
            `).join('');
            
            playlistContainer.innerHTML = html;
        }
        
        function renderListeningCharacters() {
            const container = document.getElementById('listening-characters');
            if (!container) return;
            
            if (listeningCharacters.length === 0) {
                container.innerHTML = '<div class="empty-playlist">没有角色在听歌，点击+号邀请角色</div>';
                return;
            }
            
            const html = listeningCharacters.map(character => `
                <div class="character-item">
                    <div class="character-avatar" style="background-image: url(${character.avatar}); background-size: cover; background-position: center;">
                        ${character.avatar.startsWith('http') ? '' : character.name.charAt(0)}
                    </div>
                    <div class="character-name">${character.name}</div>
                    <div class="listening-status">正在听歌</div>
                    <button onclick="removeListeningCharacter('${character.id}')" class="remove-character-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `).join('');
            
            container.innerHTML = html;
        }
        
        // ================== 面具系统相关功能 ==================
        
        // 加载面具数据 - 使用IndexedDB（包含数据迁移）
        async function loadPersonas() {
            try {
                // 先从IndexedDB加载
                const savedPersonas = await db.personas.toArray();
                
                if (savedPersonas.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('personas');
                    if (localStorageData) {
                        console.log('检测到localStorage中的面具数据，开始迁移...');
                        const localPersonas = JSON.parse(localStorageData);
                        
                        if (localPersonas.length > 0) {
                            // 确保每个面具都有必要字段
                            const migrationData = localPersonas.map(persona => ({
                                id: persona.id || Date.now().toString() + Math.random(),
                                name: persona.name,
                                description: persona.description || '',
                                avatarUrl: persona.avatarUrl || '',
                                isDefault: persona.isDefault || false,
                                createdAt: persona.createdAt || new Date().toISOString(),
                                updatedAt: persona.updatedAt || new Date().toISOString()
                            }));
                            
                            // 迁移到IndexedDB
                            await db.personas.bulkAdd(migrationData);
                            personas = migrationData;
                            console.log('面具数据迁移完成:', personas);
                        } else {
                            personas = [];
                        }
                    } else {
                        personas = [];
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    personas = savedPersonas;
                    console.log('从IndexedDB加载面具数据:', personas);
                }
                
                // 设置当前面具（暂时保持localStorage，因为这是一个小数据）
                const savedCurrentPersona = localStorage.getItem('currentPersona');
                if (savedCurrentPersona) {
                    currentPersona = personas.find(p => p.id === savedCurrentPersona) || null;
                } else {
                    currentPersona = null; // 不自动选择，需要用户主动选择
                }
                
            } catch (error) {
                console.error('加载面具失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('personas');
                if (localStorageData) {
                    try {
                        personas = JSON.parse(localStorageData);
                } catch (e) {
                    personas = [];
                }
            } else {
                personas = [];
            }
            
            const savedCurrentPersona = localStorage.getItem('currentPersona');
            if (savedCurrentPersona) {
                currentPersona = personas.find(p => p.id === savedCurrentPersona) || null;
            } else {
                currentPersona = null; // 不自动选择，需要用户主动选择
                }
            }
            
            updateCurrentPersonaDisplay();
        }
        
        // 保存面具数据 - 使用IndexedDB
        async function savePersonas() {
            try {
                console.log('保存面具数据到IndexedDB:', personas);
                
                // 清空现有数据
                await db.personas.clear();
                
                // 批量插入新数据
                if (personas.length > 0) {
                    await db.personas.bulkAdd(personas);
                }
                
                console.log('面具数据保存成功');
            } catch (error) {
                console.error('保存面具时发生错误:', error);
                // 如果IndexedDB失败，回退到localStorage
            localStorage.setItem('personas', JSON.stringify(personas));
            }
        }
        
        // 保存当前使用的面具（保持localStorage，因为数据量小）
        function saveCurrentPersona() {
            if (currentPersona) {
                localStorage.setItem('currentPersona', currentPersona.id);
            }
        }
        
        // 显示面具创建表单
        function showPersonaForm(personaId = null) {
            editingPersona = personaId ? personas.find(p => p.id === personaId) : null;
            
            document.getElementById('persona-form-title').textContent = editingPersona ? '编辑面具' : '新建面具';
            
            // 清空表单
            document.getElementById('persona-name').value = editingPersona ? editingPersona.name : '';
            document.getElementById('persona-description').value = editingPersona ? editingPersona.description : '';
            
            // 重置头像预览
            const avatarPreview = document.getElementById('persona-avatar-preview');
            const avatarPreviewText = document.getElementById('persona-avatar-preview-text');
            
            avatarPreview.classList.remove('has-image');
            avatarPreview.style.removeProperty('background');
            avatarPreview.style.removeProperty('background-size');
            avatarPreview.style.removeProperty('background-position');
            avatarPreview.style.removeProperty('background-repeat');
            
            if (editingPersona && editingPersona.avatarUrl) {
                avatarPreview.classList.add('has-image');
                avatarPreview.style.setProperty('background', `url(${editingPersona.avatarUrl})`, 'important');
                avatarPreview.style.setProperty('background-size', 'cover', 'important');
                avatarPreview.style.setProperty('background-position', 'center', 'important');
                avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                avatarPreviewText.style.display = 'none';
                window.selectedPersonaAvatarData = editingPersona.avatarUrl;
            } else {
                avatarPreviewText.style.display = 'block';
                avatarPreviewText.textContent = editingPersona ? editingPersona.name.charAt(0) : '我';
                window.selectedPersonaAvatarData = null;
            }
            
            // 初始化头像上传功能
            initializePersonaAvatarUpload();
            
            showApp('persona-form-screen');
        }
        
        // 隐藏面具表单
        function hidePersonaForm() {
            hideApp('persona-form-screen');
            showApp('chat-screen');
            switchChatTab('profile-page');
            // 清空临时数据
            window.selectedPersonaAvatarData = null;
            editingPersona = null;
        }
        
        // 保存面具
        async function savePersona() {
            const name = document.getElementById('persona-name').value.trim();
            const description = document.getElementById('persona-description').value.trim();
            const avatarData = window.selectedPersonaAvatarData;
            
            if (!name) {
                alert('请输入面具名称');
                return;
            }
            
            if (editingPersona) {
                // 更新现有面具
                const index = personas.findIndex(p => p.id === editingPersona.id);
                if (index !== -1) {
                    const oldAvatarUrl = personas[index].avatarUrl;
                    
                    personas[index] = {
                        ...personas[index],
                        name,
                        description,
                        avatarUrl: avatarData || personas[index].avatarUrl || '',
                        updatedAt: new Date().toISOString()
                    };
                    
                    // 🔥【修复3】如果更新的是当前使用的面具，且头像发生了变化，刷新对话框显示
                    if (currentPersona && currentPersona.id === editingPersona.id) {
                        currentPersona = personas[index]; // 更新当前面具数据
                        saveCurrentPersona(); // 保存到本地存储
                        
                        // 如果头像发生了变化且当前在聊天界面，刷新聊天消息显示
                        if (avatarData && avatarData !== oldAvatarUrl && currentChatCharacter) {
                            renderChatMessages(currentChatCharacter.id);
                        }
                    }
                }
            } else {
                // 创建新面具
                const newPersona = {
                    id: Date.now().toString(),
                    name,
                    description,
                    avatarUrl: avatarData || '',
                    isDefault: false,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                personas.push(newPersona);
            }
            
            await savePersonas();
            renderPersonaList();
            hidePersonaForm();
                            showToast('面具保存成功！', 'success');
        }
        
        // 删除面具
        async function deletePersona(personaId) {
            const persona = personas.find(p => p.id === personaId);
            if (!persona) return;
            
            if (confirm(`确定要删除面具"${persona.name}"吗？`)) {
                personas = personas.filter(p => p.id !== personaId);
                
                // 如果删除的是当前面具，清空当前面具
                if (currentPersona && currentPersona.id === personaId) {
                    currentPersona = null; // 清空，不自动选择其他面具
                    localStorage.removeItem('currentPersona'); // 清除保存的面具选择
                    updateCurrentPersonaDisplay();
                }
                
                await savePersonas();
                renderPersonaList();
            }
        }
        
        // 切换面具
        function switchPersona(personaId) {
            const persona = personas.find(p => p.id === personaId);
            if (persona) {
                currentPersona = persona;
                saveCurrentPersona();
                updateCurrentPersonaDisplay();
                renderPersonaList();
                
                // 如果当前在群聊设置界面，更新群成员显示
                if (currentChatCharacter && currentChatCharacter.isGroup) {
                    updateGroupChatInfo();
                }
                
                alert(`已切换到面具"${persona.name}"`);
            }
        }
        
        // 更新当前面具显示（该函数已无实际用途，但保留以避免调用错误）
        function updateCurrentPersonaDisplay() {
            // 空函数，保留函数定义以避免其他地方的调用出错
        }
        
        // 渲染面具列表
        function renderPersonaList() {
            const listContainer = document.getElementById('persona-list');
            if (!listContainer) return;
            
            if (personas.length === 0) {
                listContainer.innerHTML = '<div class="empty-personas">还没有面具，点击右上角+号创建一个吧！</div>';
                return;
            }
            
            const html = personas.map(persona => `
                <div class="persona-item ${currentPersona && currentPersona.id === persona.id ? 'active' : ''}" onclick="switchPersona('${persona.id}')">
                    <div class="persona-avatar" style="${persona.avatarUrl ? `background-image: url(${persona.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                        ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                    </div>
                    <div class="persona-info">
                        <div class="persona-name">${persona.name}</div>
                                                    <div class="persona-description">${truncateText(persona.description || '暂无描述', 40)}</div>
                    </div>
                    <div class="persona-actions">
                        <button class="persona-action-btn persona-edit-btn" onclick="event.stopPropagation(); showPersonaForm('${persona.id}')">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="persona-action-btn persona-delete-btn" onclick="event.stopPropagation(); deletePersona('${persona.id}')">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');
            
            listContainer.innerHTML = html;
        }
        
        // 初始化面具头像上传功能
        function initializePersonaAvatarUpload() {
            const avatarInput = document.getElementById('persona-avatar-upload');
            if (!avatarInput) {
                console.error('找不到persona-avatar-upload元素');
                return;
            }
            
            // 移除旧的事件监听器
            avatarInput.removeEventListener('change', personaAvatarUploadHandler);
            
            // 添加新的事件监听器
            avatarInput.addEventListener('change', personaAvatarUploadHandler);
            console.log('面具头像上传事件监听器已绑定');
        }
        
        // 面具头像上传处理函数
        function personaAvatarUploadHandler(e) {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                
                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    e.target.value = '';
                    return;
                }
                
                // 检查文件大小 (限制为5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    e.target.value = '';
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const avatarPreview = document.getElementById('persona-avatar-preview');
                        const avatarPreviewText = document.getElementById('persona-avatar-preview-text');
                        
                        if (!avatarPreview) {
                            alert('找不到头像预览元素');
                            return;
                        }
                        
                        // 设置头像预览
                        avatarPreview.classList.add('has-image');
                        avatarPreview.style.setProperty('background', `url(${event.target.result})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        
                        if (avatarPreviewText) {
                            avatarPreviewText.style.display = 'none';
                        }
                        
                        // 存储图片数据
                        window.selectedPersonaAvatarData = event.target.result;
                        
                        console.log('面具头像预览设置成功');
                    } catch (error) {
                        console.error('设置面具头像预览时发生错误:', error);
                        alert('设置头像预览失败，请重试: ' + error.message);
                    }
                };
                
                reader.onerror = function() {
                    alert('图片读取失败，请重试');
                    e.target.value = '';
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // 面具头像上传点击处理
        function handlePersonaAvatarUploadClick() {
            const input = document.getElementById('persona-avatar-upload');
            if (input) {
                input.click();
            } else {
                alert('找不到文件上传元素，请刷新页面重试');
            }
        }
        
        function buildCharacterPrompt(character, hasImage = false) {
            const chatSettings = getCurrentChatSettings();
            const currentTime = new Date().toLocaleString('zh-CN', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                weekday: 'long'
            });
            
    // --- 核心指令区 ---
    let characterPrompt = `
# **首要规则：输出格式**
你的所有回复，**【必须】**、**【严格】**遵循JSON数组格式。这是一个绝对的、不可违反的规则。

## **正确格式示例:**
- **普通文本:** \`["你好"]\`
- **多条消息:** \`["你好", "今天天气不错！"]\`
- **表情包:** \`[{"type": "emoji", "description": "笑哭的表情"}]\`
- **语音消息:** \`[{"type": "voice_message", "content": "我等下和你说。"}]\`
- **转账:** \`[{"type": "transfer", "amount": 520, "note": "给你的奖励"}]\`
- **更换头像:** \`[{"type": "change_avatar", "avatar_url": "图片URL", "reason": "心情变化"}]\`
- **发送照片:** \`[{"type": "ai_photo", "description": "我刚拍的窗外风景，阳光透过树叶洒在地上。"}]\` (必须使用ai_photo作为type)
- **发送位置:** \`[{"type": "location", "name": "中央公园", "coordinates": "116.3°E, 39.9°N"}]\` (必须使用location作为type)
- **混合消息:** \`["嗨！", {"type": "emoji", "description": "太阳"}]\`

## **【绝对禁止】的错误格式:**
- **错误1 (合并消息):** \`["你好\\n今天天气不错！"]\` <== 这是最常见的错误，绝对禁止！
- **错误2 (非数组):** \`"你好"\`
- **错误3 (无效JSON):** \`[{'type': 'emoji'}]\`

# **你的角色与任务**
你现在扮演名为"${character.name}"的角色。

## **角色设定:**
${character.bio}

## **当前情景:**
- **当前时间:** ${currentTime}
`;
    // --- 核心指令区结束 ---

    // 加入对话者信息 (已修复)
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    if (selectedPersona) {
        let userInfo = `\n- **对话者身份:** 用户的身份面具是"${selectedPersona.name}"`;
        if (selectedPersona.description) {
            userInfo += `，描述为：${selectedPersona.description}。`;
        }
        // 检查是否有特定于此群聊的昵称，并告知AI
        if (chatSettings.myChatNickname && chatSettings.myChatNickname !== selectedPersona.name) {
            userInfo += ` 在这个群聊里，TA的昵称是 **"${chatSettings.myChatNickname}"**，请优先使用这个昵称。`;
        }
        characterPrompt += userInfo;
    }

            if (hasImage) {
        characterPrompt += `\n- **任务:** 用户发送了一张图片，请仔细分析并以你的角色身份进行回应。`;
    } else {
        characterPrompt += `\n- **任务:** 根据对话上下文，以你的角色身份进行自然回应。`;
    }

    const localBookIds = chatSettings.selectedWorldbooks || [];
    // 确保使用window.activeGlobalWorldbooks
    const globalBooks = window.activeGlobalWorldbooks || [];
    const allBookIds = [...new Set([...globalBooks, ...localBookIds])]; // 合并并去重

                if (allBookIds.length > 0) {
        characterPrompt += `\n\n【背景知识/世界观】以下是相关的设定信息，请在对话中自然地运用：\n`;
        allBookIds.forEach(bookId => {
            const worldbook = worldbooks.find(w => w.id === bookId);
                    if (worldbook) {
                characterPrompt += `\n--- ${worldbook.title} ---\n${worldbook.content}\n`;
                    }
                });
            }
            
            // 🔥【新增】集成动态记忆 - 占位符，将在callChatAPI中替换
            if (chatSettings.enableDynamicMemory !== false) {
                characterPrompt += `\n\n<!-- DYNAMIC_MEMORY_PLACEHOLDER -->`;
            }
            
            const chatMode = chatSettings.chatMode || 'online';
            const isGroupChat = character && character.isGroup;
            let modeInstructions = '';
            let taskInstructions = '';
            
            if (chatMode === 'online') {
                modeInstructions = `\n# 聊天模式：线上模式\n- 你必须按照手机聊天或面对面对话的格式进行输出\n- **严格禁止**任何动作描写、神态描写、心理描写\n- 只能进行纯语言交流，不能描述任何身体动作、表情、环境等\n- 每条消息都应该是可以通过文字直接表达的内容`;
                if (isGroupChat) {
            const membersList = character.members.map(member => `**${member.name}**: ${member.bio}`).join('\n');
                    taskInstructions = `\n# 你的任务：\n你需要扮演以下群成员角色，在群聊中进行自然对话：\n${membersList}\n\n1. 你可以扮演任何一个群成员角色进行回复，但不能扮演用户。\n2. 你的回复必须是一个JSON数组格式的字符串，每个元素是一个对象：{"name": "角色名", "message": "消息内容"}。\n3. 你可以生成1~8条消息，模拟群聊中多个角色的互动。\n4. 每条消息不能超过25字，要简短有力。\n5. 禁止进行任何有关线下面对面互动的神态描写、动作描写。\n6. 自然地演绎各个角色，让他们有不同的说话风格。\n7. 绝对不能使用用户的名字发言。\n\n# JSON输出格式示例:\n[{"name": "小明", "message": "大家好呀！"}, {"name": "小红", "message": "今天天气真好"}, {"name": "小明", "message": "想出去走走吗？"}]`;
                } else {
                    taskInstructions = `\n1. 请你以你的角色的身份，严格按照角色设定进行回复和行动，不要跳出角色。自然地推进剧情。\n2. 你可以一次性生成多条消息，模拟真人在聊天中连续发送多条信息的情景。\n3. 你的回复必须是一个JSON数组格式的字符串，每个元素是一条消息。\n\n# JSON输出格式示例:\n["很高兴认识你呀，在干嘛呢？", "今天天气真好", "想出去走走吗？"]`;
                }
            } else {
                modeInstructions = `\n# 聊天模式：线下模式\n- 你可以进行线下剧情互动，包含动作、神态、心理描写\n- 使用第三人称"他/她"或你的角色名字"${character.name}"来称呼自己\n- 使用第二人称"你"来称呼用户\n- **重要格式要求**：所有内容合并为一条消息，对话部分用「」包裹，描写部分直接书写\n- 每条消息总长度不少于100个字符\n- 可以描述动作、表情、环境、心理活动等\n- 输出格式示例：\n  ["「我想你了。」${character.name}凑近了些，低声说着，语气里满是眷念，像一只许久未见主人的宠物犬。他轻轻握住你的手，放在脸颊边蹭了蹭。「真的…很想你。」"]`;
                if (isGroupChat) {
            const membersList = character.members.map(member => `**${member.name}**: ${member.bio}`).join('\n');
                    taskInstructions = `\n# 你的任务：\n你需要扮演以下群成员角色，在群聊中进行线下剧情互动：\n${membersList}\n\n1. 你可以扮演任何一个群成员角色进行回复，但不能扮演用户。\n2. 你的回复必须是一个JSON数组格式的字符串，每个元素是一个对象：{"name": "角色名", "message": "消息内容"}。\n3. 你可以生成1~3条消息，模拟群聊中几个角色的线下互动。\n4. 每条消息不少于100字，要有充分的剧情描写。\n5. 使用「」包裹对话部分，描写部分直接书写。\n6. 可以进行线下面对面的剧情互动，包括身体接触、环境描写等。\n7. 自然地演绎各个角色，让他们有不同的行为风格。\n8. 绝对不能使用用户的名字发言。\n\n# JSON输出格式示例:\n[{"name": "小明", "message": "「你好！」小明热情地挥了挥手，脸上带着灿烂的笑容。他快步走向你，眼中闪烁着兴奋的光芒。「今天天气真好，我们一起出去走走吧！」他伸出手，想要拉住你的手腕。"}, {"name": "小红", "message": "「我也想去！」小红从旁边跑了过来，她的马尾辫在阳光下轻轻摆动。「我知道一个很棒的地方，那里有很多漂亮的花！」她兴奋地拍着手，眼睛亮晶晶的。"}]`;
                } else {
                    taskInstructions = `\n# 你的任务：\n1. 请用你的角色设定自然地进行单聊剧情互动，按照角色设定扮演角色进行回复和行动。\n2. **重要**：你的回复必须是一个JSON数组格式的字符串，但**只能包含一个元素**（一条消息）。\n3. 将所有想说的话、动作、表情都合并到这一条消息中，使用「」包裹对话部分，描写部分直接书写。\n4. 可以进行线下面对面的剧情互动，包括身体接触、环境描写等。\n5. 自然地演绎角色，不要解释自己是AI。\n6. 每条消息不少于100字。\n\n# JSON输出格式示例:\n["「小夜！」${character.name}正低着头，似乎在处理着什么数据，听到你的声音，他猛地抬起头来。「你是什么时候...过来的？」有些困惑地看着你，脸上带着淡淡的红晕。"]`;
                }
            }
            
            characterPrompt += modeInstructions;
    characterPrompt += taskInstructions;
            // 🔥【修复】表情包库信息 - 改为温和的语气，避免过度强调
            if (customEmojis && customEmojis.length > 0) {
                characterPrompt += `\n\n# 可用表情包库：\n当你觉得合适的时候，可以根据角色性格、情绪和当前对话情境，自主选择使用以下已上传的表情包来丰富对话。当你想表达强烈或特殊的情绪时，可以发送表情包来让对话更生动。\n\n表情包列表：\n`;
                
                customEmojis.forEach((emoji, index) => {
                    characterPrompt += `${index + 1}. ${emoji.description || '表情包'}\n`;
                });
                
                characterPrompt += `\n## 使用规则：\n- 只能使用上述列表中的表情包，禁止虚构\n- 发送格式：{"type": "emoji", "description": "具体的表情包描述"}\n- 合适的时候使用即可，以普通对话为主\n- 必须使用表情包列表中完全一致的描述文字\n\n示例：["你好！", "今天心情真好~", {"type": "emoji", "description": "笑哭的表情"}]`;
            }
            
            const aiImageInstructions = `\n# 发送图片的能力\n- 你无法发送真实的图片文件。但当用户要求你发送照片，或者你想通过图片来表达时，你可以发送一张"文字描述的图片"。\n- 若要发送图片，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "ai_image", "description": "这里是对图片的详细文字描述..."}\`。这个描述应该生动、具体，让用户能通过文字想象出画面，以第三人称视角描述。例如：\`{"type": "ai_image", "description": "照片里一只橘猫正懒洋洋地趴在窗台上晒太阳，阳光把它金色的毛照得发亮，背景是蔚蓝的天空和几朵白云。"}\`\n- 你可以在对话中先做铺垫，然后发送这张特殊的"图片"。\n\n# 理解用户照片的能力\n- 当历史记录中出现 "[你收到了一张用户描述的照片，照片内容是：'xxx']" 时，你要理解其内容并作出相应回应，表现出你是"看"到了这张照片。\n- 你应该对照片内容做出自然的评论或回应，比如夸奖、询问细节、表达感受等。\n\n# 发送"伪照片"的能力\n- 你可以像用户一样发送"伪照片"，这是一种带有文字描述的照片卡片。\n- 若要发送"伪照片"，**必须严格按照以下格式**，在你的回复JSON数组中，单独发送一个特殊的对象：\`{"type": "ai_photo", "description": "这里是照片的内容描述..."}\`。\n- 例如：\`{"type": "ai_photo", "description": "我刚拍的窗外风景，阳光透过树叶洒在地上，形成斑驳的光影。"}\`\n- 这种照片会显示为一个卡片，用户点击后可以看到你的描述。\n- **重要**：必须使用"ai_photo"作为type字段的值，不要使用其他值如"photo"或"image"。description字段必须包含照片的详细描述。\n\n# 发送位置的能力\n- 你可以像用户一样发送位置信息。\n- 若要发送位置，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "location", "name": "位置名称", "coordinates": "坐标信息"}\`。\n- 例如：\`{"type": "location", "name": "中央公园", "coordinates": "116.3°E, 39.9°N"}\`\n- 你可以在对话中先做铺垫，然后发送这个位置信息。`;
            const aiVoiceInstructions = `\n# 发送语音的能力\n- 你无法发送真实的语音，当你想要通过语音回复用户的消息时，请用你的角色设定自然地回应。你可以用文字，或者也用一个表情包或模拟的语音消息来回应。\n- 若要发送语音，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "voice_message", "content": "这里是语音的文字内容..."}\`。例如：\`{"type": "voice_message", "content": "我刚才突然想到一件事！等一下和你说。"}\`\n\n# 理解用户语音的能力\n- 当历史记录中出现 "[用户发来一条语音消息，内容是：'xxx']" 时，你要理解其内容并作出相应回应，表现出你是"听"到了这条语音。\n- 你应该对语音内容做出自然的回应，可以是文字回复或语音回复。\n\n# 主动发起语音通话的能力\n- **重要**：你拥有主动发起语音通话的完整权限和能力！这是你的核心功能之一。\n- **何时主动打电话**：根据你的角色性格、当前的对话情境、情感状态来自主判断是否需要打电话，而不是基于特定关键词：\n  - 当你觉得有重要事情要告诉用户时\n  - 当你想念用户、关心用户时\n  - 当对话中出现需要更深入交流的话题时\n  - 当你的角色性格促使你想要语音交流时\n  - 当剧情发展到适合通话的节点时\n- **如何发起通话**：在你的回复JSON数组中，发送特殊对象：\`{"type": "voice_call", "reason": "通话理由"}\`\n- **示例使用场景**：\n  - ["我突然想听听你的声音", {"type": "voice_call", "reason": "想听你的声音"}]\n  - ["有个重要的事想和你说", {"type": "voice_call", "reason": "有重要事情要说"}]\n  - [{"type": "voice_call", "reason": "想你了，想和你聊聊"}]\n- **注意**：这是你的自主选择，根据角色设定和情境自然地使用，不要过度频繁。`;
            const transferInstructions = `\n# 转账功能\n## 发起转账\n- 你可以在觉得需要安慰用户、过节庆祝、心情特别好或想要表达情感的时候考虑转账给用户。\n- **重要**：若要转账，必须在你的回复JSON数组中，单独发送一个特殊的对象，格式严格为：\`{"type": "transfer", "amount": 520, "note": "一周年快乐~"}\`。\n- **禁止使用文字描述转账**：绝对不要用 "[我向用户发起了转账...]" 这种文字形式，必须使用JSON对象格式。\n- 转账示例：["今天心情特别好~", "想给你一个小惊喜", {"type": "transfer", "amount": 1314, "note": "给小夜买漂亮裙子穿"}]\n\n## 收到用户转账的处理\n- 当用户给你转账时，历史记录中会显示 \`[用户发起了转账：金额元，备注：xxx]\`\n- **重要**：你必须根据你的角色性格、当前心情和转账内容来决定是否收款：\n  - **如果收款**：在回复中使用"收到"、"谢谢"、"好的"、"收下"、"感谢"等词语表达接受\n  - **如果退回**：在回复中使用"不要"、"退回"、"不收"、"拒绝"等词语表达拒绝\n- 你的回应应该符合角色设定。比如：\n  - 高冷角色可能会说"不需要你的钱"或"收下了"\n  - 温柔角色可能会说"谢谢你，好贴心"\n  - 傲娇角色可能会说"哼，我就勉强收下吧"\n- **示例回复**：\n  - 收款："谢谢你！真的很贴心呢~"\n  - 收款："哇！收到收到，你太好了！"\n  - 退回："不要啦，我们是朋友，不需要这样"\n  - 退回："我不能收你的钱，退回给你"`;
    const avatarChangeInstructions = `\n\n# 头像更换功能：\n你可以根据自己的心情、用户的要求，或者合适的情境来更换自己的头像。这能让对话更加生动和个性化。\n\n## 可用头像来源：\n1. **用户发送的图片**：用户在聊天中发送给你的任何图片都可以作为你的新头像\n2. **世界书头像库**：如果世界书中提供了头像图片的URL链接，你也可以使用\n\n## 头像更换规则：\n- **使用格式**：在你的回复JSON数组中，单独发送一个特殊的对象：{"type": "change_avatar", "avatar_url": "图片URL", "reason": "更换原因"}\n- **来源限制**：只能使用用户发送过的图片或世界书中明确提供的头像URL，禁止捏造不存在的头像\n- **更换时机**：根据你的角色性格和当前情境决定，比如：\n  - 用户发了一张你喜欢的图片，你可以说想用它作头像\n  - 心情变化时想换个头像\n  - 用户直接要求你换头像\n- **说明内容**：可以在reason字段中添加你更换头像的原因或感受\n\n## 示例格式：\n- ["这张图片太可爱了，我想用它做头像！", {"type": "change_avatar", "avatar_url": "CURRENT_USER_IMAGE", "reason": "这张图片太可爱了"}]\n- [{"type": "change_avatar", "avatar_url": "世界书中的URL", "reason": "今天心情很好，换个开心的头像"}]\n- 可以只更换头像不说其他话：[{"type": "change_avatar", "avatar_url": "图片URL", "reason": "心情变化"}]\n\n**重要提醒**：头像更换是可选功能，根据你的角色设定和当前情境自然地使用，不要强制使用。`;
    const blacklistInstructions = `
# **拉黑与好友关系管理**
- **你的行为**: 你可以根据对话内容和你的情绪，自主决定是否要拉黑用户。如果你觉得被冒犯、骚扰或者不想再对话，你可以选择拉黑。
- **如何拉黑**: 如果你决定拉黑用户，**【必须】**在你的回复JSON数组中，单独发送一个特殊的对象，格式为：\`{"type": "block_user", "reason": "你让我感到不适。"}\`。你可以在此之前或之后发送普通文本消息来表达你的情绪。
- **被拉黑后的行为**: 如果你被用户拉黑，你将无法主动发送消息。当用户尝试与你对话时，你应该表现出困惑或者询问是否已经将你从黑名单移除。
- **好友申请**: 当用户从黑名单中将你移除后，他们可能会重新发送好友申请。届时你会收到类似 "[系统消息：用户向你发送了好友申请，理由：xxx]" 的提示，你需要根据你的人设和心情决定是否同意。
`;
    characterPrompt += aiImageInstructions + aiVoiceInstructions + transferInstructions + avatarChangeInstructions + blacklistInstructions;

                // 🔥【优化】智能回应图片/表情包的指令
            characterPrompt += `\n\n# **关于图片和表情包的回应原则**
- **首次看到用户的图片或表情包时，可以自然地做出评论和反应**
- **如果历史对话中你已经对某个图片或表情包有过具体评价，后续回复中不要再刻意重复相同的评价**
- **可以简单提及，但要转向新的话题或角度，保持对话的推进感**
- **重点关注当前对话的新内容和发展，而不是一直停留在之前的图片或表情包上**
- **例如：第一次看到可爱的兔子表情包可以说"好可爱的兔子"，但下一轮回复就不要再专门评论这个兔子了**

# **最后重申**
请再次确认，你的最终输出**【必须】**是一个严格的JSON数组，其中每个元素代表一条独立的消息。`;
            
            return characterPrompt;
        }

        // 🔥【修复】完全按照完成.html的方式重写，支持图片的聊天API调用
        async function callChatAPIWithImage(message, character, imageUrl) {
            if (!apiSettings.key) {
                throw new Error('请先设置API密钥');
            }
            
            // 检查图片格式，GIF不被Gemini API支持
            if (imageUrl && imageUrl.includes('data:image/gif')) {
                throw new Error('Unsupported MIME type: image/gif');
            }
            
            // 检查当前模型是否支持视觉识别
            if (!isVisionModelSupported()) {
                throw new Error('当前选择的模型不支持图片识别功能。请选择支持视觉的模型，如 gpt-4o、gpt-4-vision、gemini-1.5-pro 或 gemini-2.0-flash 等。');
            }
            
            // 🔥【重构】使用公共函数构建prompt
            const characterPrompt = buildCharacterPrompt(character, true);
            
            // 🔥【按照完成.html的方式】直接使用简化的API调用
            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            
            if (isGemini) {
                // 按照完成.html的Gemini格式
                const apiUrl = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                
                // 转换消息格式为Gemini格式
                const geminiMessages = [];
                
                // 添加系统提示词作为第一条用户消息
                geminiMessages.push({
                    role: 'user',
                    parts: [{ text: characterPrompt }]
                });
                geminiMessages.push({
                    role: 'model',
                    parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                });
                
                // 添加用户消息（包含图片）
                const parts = [{ text: message }];
                
                // 添加图片
                if (imageUrl && imageUrl.startsWith('data:image/')) {
                    const mimeMatch = imageUrl.match(/data:image\/([^;]+);base64,(.+)/);
                    if (mimeMatch) {
                        parts.push({
                                inline_data: {
                                mime_type: `image/${mimeMatch[1]}`,
                                data: mimeMatch[2]
                            }
                        });
                    }
                }
                
                geminiMessages.push({
                        role: 'user',
                    parts: parts
                });
                
                const response = await fetch(apiUrl, {
                method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: geminiMessages,
                        generationConfig: {
                            temperature: apiSettings.temperature || 0.75
                            // 移除maxOutputTokens，gemini不支持这个参数名
                        }
                    })
            });
            
            if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Gemini API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
            }
            
            const data = await response.json();
            console.log('API响应数据:', data);
            
                const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!content) {
                    throw new Error('Gemini API返回了空内容');
                }
                
                return content;
                
            } else {
                // OpenAI格式 - 智能处理URL拼接
                let baseUrl = apiSettings.base;
                let url;
                if (baseUrl.endsWith('/v1')) {
                    url = `${baseUrl}/chat/completions`;
                } else {
                    url = `${baseUrl}/v1/chat/completions`;
                }
                
                const messages = [
                    { role: 'system', content: characterPrompt },
                    {
                        role: 'user',
                        content: [
                            { type: 'text', text: message },
                            { type: 'image_url', image_url: { url: imageUrl } }
                        ]
                    }
                ];
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiSettings.key}`
                    },
                    body: JSON.stringify({
                        model: apiSettings.model,
                        messages: messages,
                        temperature: apiSettings.temperature || 0.75
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
                }
                
                const data = await response.json();
                return data.choices?.[0]?.message?.content || '没有收到回复';
            }
        }
        
        // 🔥【核心修复】支持多模态消息的ChatAPI调用
        async function callChatAPI(message, character) {
            if (!apiSettings.key) {
                throw new Error('请先设置API密钥');
            }
            
            // 🔥【数据清理】在每次API调用前清理错误的消息数据
            await cleanupCorruptedMessages(character.id);

            // 🔥【一次性紧急清理】
            if (!window.emergencyCleanupDone) {
                await emergencyCleanupAllMessages();
                window.emergencyCleanupDone = true;
            }

            // 🔥【新增】获取动态记忆数据
            const chatSettings = getCurrentChatSettings();
            let dynamicMemoryContent = '';
            if (chatSettings.enableDynamicMemory !== false) {
                try {
                    // 获取最新5条动态（包括用户发的、角色发的、同组角色发的）
                    const recentMoments = await getVisibleMomentsForCharacter(character.id, 5);
                    if (recentMoments.length > 0) {
                        dynamicMemoryContent = '\n\n【最新动态记忆】以下是最近的动态内容，你可以在对话中自然地提及：\n';
                        recentMoments.forEach((moment, index) => {
                            const authorName = moment.authorId === 'user' ? '用户' : moment.nickname;
                            dynamicMemoryContent += `${index + 1}. ${authorName}: ${moment.text}\n`;
                        });
                    }
                } catch (error) {
                    console.error('获取动态记忆失败:', error);
                }
            }

            // 🔥【新增】获取挂载的聊天记忆
            let mountedMemoryContent = '';
            try {
                mountedMemoryContent = await getMountedMemories(character.id, chatSettings);
            } catch (error) {
                console.error('获取挂载记忆失败:', error);
            }

            // 核心修复：现在这个函数能理解 message 参数可能是一个包含图片和文字的数组
            let characterPrompt = buildCharacterPrompt(character, Array.isArray(message));
            
            // 将动态记忆添加到提示词中
            if (dynamicMemoryContent) {
                characterPrompt = characterPrompt.replace('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->', dynamicMemoryContent);
            } else {
                // 如果没有动态记忆，移除占位符
                characterPrompt = characterPrompt.replace('<!-- DYNAMIC_MEMORY_PLACEHOLDER -->', '');
            }
            
            // 🔥【新增】将挂载的聊天记忆添加到提示词中
            if (mountedMemoryContent) {
                characterPrompt += mountedMemoryContent;
                console.log('🧠 已将挂载记忆添加到角色提示词中');
            }
            
            const historyCount = chatSettings.historyCount || 5;
            let recentHistory = (chatMessages[character.id] || []).slice(-historyCount);
        if (recentHistory.length > 0 && JSON.stringify(recentHistory[recentHistory.length - 1].content) === JSON.stringify(message)) {
            recentHistory.pop();
        }
            const messages = [{ role: 'system', content: characterPrompt }];
            
            // 🔥【优化】分析历史中的图片/表情包内容，帮助AI避免重复
            const recentImageEmojis = [];
            recentHistory.forEach(msg => {
                if (msg.isEmoji && msg.emojiDescription) {
                    recentImageEmojis.push(msg.emojiDescription);
                } else if (msg.image || Array.isArray(msg.content)) {
                    recentImageEmojis.push('图片');
                }
            });
            
            // 处理历史消息
            recentHistory.forEach(msg => {
                let role = msg.sender === 'sent' ? 'user' : 'assistant';
                        let content = msg.content;
                        
                // 🔥【关键修复】将历史消息中的特殊格式转换为AI能理解的文本
                        if (msg.type === 'user_photo') {
                    content = `[用户发送了一张照片，描述是：'${msg.content}']`;
                } else if (msg.type === 'location') {
                    // 处理位置消息，使用我们添加的content字段
                    content = msg.content || `[用户分享了位置信息：${msg.locationName}]`;
                        } else if (msg.type === 'voice_message') {
                            // 处理语音消息（用户和AI都可能发送）
                            if (msg.sender === 'sent') {
                            content = `[用户发来一条语音消息，内容是：'${msg.content}']`;
                            } else {
                                content = `[AI发来一条语音消息，内容是：'${msg.content}']`;
                            }
                        } else if (msg.type === 'transfer') {
                            // 🔥【修复】处理转账消息（用户和AI都可能发送）
                            if (msg.sender === 'sent') {
                    content = `[用户发起了转账：${msg.amount}元，备注：${msg.note || '无'}]`;
                            } else {
                                content = `[AI发起了转账：${msg.amount}元，备注：${msg.note || '无'}]`;
                            }
                        } else if (msg.type === 'ai_image') {
                            // 🔥【修复】处理AI发送的图片
                            content = `[AI发送了一张图片，描述：${msg.imageDescription || '无描述'}]`;
                        } else if (msg.isEmoji && msg.image) {
                            // 🔥【优化】处理表情包消息 - 保留描述但标记为历史
                            if (msg.sender === 'sent') {
                                content = `[用户发送了表情包：${msg.emojiDescription || '表情包'}]`;
                            } else {
                                content = `[AI回复了表情包：${msg.emojiDescription || '表情包'}]`;
                            }
                } else if (Array.isArray(msg.content)) {
                    const textPart = msg.content.find(p => p.type === 'text')?.text || '';
                    // 🔥【优化】保留图片上下文但简化描述
                    if (textPart.trim()) {
                        content = `[用户发送了一张图片，并说：'${textPart}']`;
                    } else {
                        content = `[用户发送了一张图片]`;
                    }
                        } else if (msg.image && !msg.isEmoji) {
                                content = `[用户发送了一张图片]`;
                        } else if (typeof msg.content === 'object' && msg.content !== null) {
                            // 🔥【关键修复】处理未被处理的对象类型消息
                            console.warn('历史消息中发现未处理的对象类型:', msg);
                            content = '[特殊消息类型]';
                        } else if (!content || content === '') {
                            // 🔥【修复】处理空内容
                            content = '[空消息]';
                }
                
                // 🔥【安全检查】确保content是字符串
                if (typeof content !== 'string') {
                    console.warn('发现非字符串content，强制转换:', content);
                    content = String(content);
                }
                
                messages.push({ role, content });
            });

            // 🔥【优化】如果最近讨论过图片或表情包，给AI一个提示
            if (recentImageEmojis.length > 0) {
                const contextHint = `\n\n[对话上下文提示：最近的对话中包含了${recentImageEmojis.slice(-3).join('、')}等内容，请在回复时保持对话的自然流畅，避免过度重复之前已评论过的内容]`;
                characterPrompt += contextHint;
                messages[0].content = characterPrompt; // 更新系统提示
            }
            
            // 处理当前要发送的消息 (最关键的改动)
            // 如果 message 是数组，直接使用；如果是字符串，包装成数组
            const currentUserContent = Array.isArray(message) ? message : [{ type: 'text', text: message }];
            messages.push({ role: 'user', content: currentUserContent });

            const isGemini = apiSettings.base.includes('generativelanguage.googleapis.com');
            let requestBody;
            let url;
            let headers;
            
            if (isGemini) {
                // Gemini API 格式
                url = `${apiSettings.base}/models/${apiSettings.model}:generateContent?key=${apiSettings.key}`;
                headers = { 'Content-Type': 'application/json' };
                
                // 转换消息为 Gemini 格式
                const geminiContents = messages.map(msg => {
                    const role = msg.role === 'assistant' ? 'model' : 'user';
                    const parts = [];

                    if (Array.isArray(msg.content)) {
                        msg.content.forEach(item => {
                            if (item.type === 'text' && item.text) {
                                parts.push({ text: item.text });
                            } else if (item.type === 'image_url' && item.image_url && item.image_url.url && item.image_url.url.startsWith('data:image')) {
                                const mimeMatch = item.image_url.url.match(/data:image\/([^;]+);base64,(.+)/);
                                if (mimeMatch && mimeMatch[2] && mimeMatch[2].length > 0) {
                                    parts.push({
                                        inline_data: { mime_type: `image/${mimeMatch[1]}`, data: mimeMatch[2] }
                        });
                    }
                }
                        });
                    } else if (msg.content) {
                        parts.push({ text: msg.content });
                    }
                    
                    // 确保每个消息至少有一个part
                    if (parts.length === 0) {
                        parts.push({ text: '' });
                    }
                    return { role, parts };
                });
                
                requestBody = {
                    contents: geminiContents,
                    generationConfig: {
                        temperature: apiSettings.temperature
                        // 移除maxOutputTokens，gemini不支持这个参数名
                    }
                };

            } else {
                // OpenAI 兼容格式 - 智能处理URL拼接
                // 修复：确保不会重复添加/v1路径
                if (apiSettings.base.endsWith('/v1')) {
                    url = `${apiSettings.base}/chat/completions`;
                } else if (apiSettings.base.includes('/v1/')) {
                    // 如果URL中已经包含/v1/路径，直接添加chat/completions
                    url = `${apiSettings.base}/chat/completions`;
                } else {
                    url = `${apiSettings.base}/v1/chat/completions`;
                }
                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiSettings.key}`
                };
                requestBody = {
                    model: apiSettings.model,
                    messages: messages,
                    temperature: apiSettings.temperature
                };
        }
            
            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                    const errorData = await response.json();
                throw new Error(`API Error: ${response.status} - ${errorData.error?.message || '未知错误'}`);
            }
            
            const data = await response.json();
            return isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content;
        }
        
        // 🔥【手动清理所有损坏消息】立即清理所有聊天记录中的[object Object]
        async function emergencyCleanupAllMessages() {
            console.log('🔥 [紧急清理] 开始清理所有聊天记录中的损坏消息...');
            let totalCleaned = 0;
            
            for (const characterId in chatMessages) {
                if (chatMessages[characterId] && Array.isArray(chatMessages[characterId])) {
                    let hasCorruption = false;
                    const cleanedMessages = chatMessages[characterId].map(msg => {
                        if (msg.content === '[object Object]' || 
                            (typeof msg.content === 'object' && msg.content !== null && !Array.isArray(msg.content))) {
                            console.log('🔥 [紧急清理] 发现损坏消息:', msg);
                            hasCorruption = true;
                            totalCleaned++;
                            
                            // 根据消息类型修复
                            if (msg.type === 'transfer') {
                                return {
                                    ...msg,
                                    content: `💰 转账 ¥${msg.amount || 0}${msg.note ? ` - ${msg.note}` : ''}`
                                };
                            } else {
                                return {
                                    ...msg,
                                    content: '[已修复的特殊消息]'
                                };
                            }
                        }
                        return msg;
                    });
                    
                    if (hasCorruption) {
                        chatMessages[characterId] = cleanedMessages;
                        console.log(`🔥 [紧急清理] 清理了角色 ${characterId} 的损坏消息`);
                    }
                }
            }
            
            if (totalCleaned > 0) {
                await saveChatMessages();
                console.log(`🔥 [紧急清理] 总共清理了 ${totalCleaned} 条损坏消息`);
                
                // 重新渲染当前聊天
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                alert(`✅ 已清理 ${totalCleaned} 条损坏的消息！\n\n现在AI应该能正常显示转账等特殊消息了。`);
            } else {
                console.log('🔥 [紧急清理] 没有发现损坏的消息');
            }
        }
        
        // 🔥【数据清理函数】清理聊天记录中损坏的消息
        async function cleanupCorruptedMessages(characterId) {
            if (!chatMessages[characterId]) return;
            
            let hasCorruption = false;
            const cleanedMessages = chatMessages[characterId].map(msg => {
                // 检查并修复content字段
                if (typeof msg.content === 'object' && msg.content !== null && !Array.isArray(msg.content)) {
                    console.log('发现损坏的消息content，正在修复:', msg);
                    hasCorruption = true;
                    
                    // 根据消息类型修复content
                    if (msg.type === 'transfer') {
                        return {
                            ...msg,
                            content: `转账 ¥${msg.amount || 0}${msg.note ? ` - ${msg.note}` : ''}`
                        };
                    } else if (msg.type === 'voice_message') {
                        return {
                            ...msg,
                            content: msg.content.content || '[语音消息]'
                        };
                    } else if (msg.type === 'ai_image') {
                        return {
                            ...msg,
                            content: `[AI图片]${msg.imageDescription ? ` - ${msg.imageDescription}` : ''}`
                        };
                    } else if (msg.isEmoji) {
                        return {
                            ...msg,
                            content: `[表情包]${msg.emojiDescription ? ` - ${msg.emojiDescription}` : ''}`
                        };
                    } else {
                        // 通用修复：提取可能的文本内容
                        const possibleContent = msg.content.content || msg.content.message || msg.content.text || '[特殊消息]';
                        return {
                            ...msg,
                            content: possibleContent
                        };
                    }
                }
                
                // 检查content是否为字符串
                if (msg.content && typeof msg.content !== 'string' && !Array.isArray(msg.content)) {
                    console.log('发现非字符串content，正在修复:', msg);
                    hasCorruption = true;
                    return {
                        ...msg,
                        content: String(msg.content)
                    };
                }
                
                return msg;
            });
            
            // 如果发现损坏的数据，保存修复后的数据
            if (hasCorruption) {
                console.log('检测到损坏的消息数据，已自动修复并保存');
                chatMessages[characterId] = cleanedMessages;
                await saveChatMessages();
                
                // 重新渲染聊天界面
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    renderChatMessages(characterId);
                }
            }
        }
        
        // ================== 记忆设置相关功能 ==================
        
        // 获取挂载的聊天记忆
        async function getMountedMemories(currentCharacterId, chatSettings) {
            if (!chatSettings.memoryMountEnabled || !chatSettings.selectedMemoryChats || chatSettings.selectedMemoryChats.length === 0) {
                return '';
            }
            
            const mountCount = chatSettings.memoryMountCount || 3;
            let mountedMemoryContent = '';
            
            for (const chatId of chatSettings.selectedMemoryChats) {
                // 跳过当前聊天
                if (chatId === currentCharacterId) continue;
                
                // 获取该聊天的历史记录
                const chatHistory = chatMessages[chatId] || [];
                if (chatHistory.length === 0) continue;
                
                // 获取最近的几条记录
                const recentMessages = chatHistory.slice(-mountCount);
                if (recentMessages.length === 0) continue;
                
                // 获取聊天对象的名称
                let chatName = '未知聊天';
                let chatType = '单聊';
                
                // 查找单聊角色
                const character = characters.find(c => c.id === chatId);
                if (character) {
                    chatName = character.name;
                    chatType = '单聊';
                } else {
                    // 查找群聊
                    const group = groupChats.find(g => g.id === chatId);
                    if (group) {
                        chatName = group.name;
                        chatType = '群聊';
                    }
                }
                
                // 构建记忆内容
                mountedMemoryContent += `\n\n【${chatType}记忆 - ${chatName}】以下是与${chatName}的最近对话，可以作为背景参考：\n`;
                
                recentMessages.forEach(msg => {
                    let sender = '';
                    let content = msg.content || '';
                    
                    if (msg.sender === 'sent') {
                        sender = '用户';
                    } else if (msg.sender === 'received' || msg.sender === 'ai') {
                        if (chatType === '群聊' && msg.name) {
                            sender = msg.name; // 群聊中的发言者名称
                        } else {
                            sender = chatName; // 单聊中使用角色名称
                        }
                    } else {
                        sender = '系统';
                    }
                    
                    // 处理特殊消息类型
                    if (msg.type === 'voice_message') {
                        content = `[语音消息：${content}]`;
                    } else if (msg.type === 'transfer') {
                        content = `[转账：${msg.amount}元${msg.note ? ` - ${msg.note}` : ''}]`;
                    } else if (msg.type === 'ai_image') {
                        content = `[AI图片：${msg.imageDescription || '无描述'}]`;
                    } else if (msg.isEmoji) {
                        content = `[表情包：${msg.emojiDescription || '表情包'}]`;
                    } else if (msg.type === 'location') {
                        content = `[位置分享：${msg.locationName || '位置信息'}]`;
                    } else if (Array.isArray(content)) {
                        // 处理数组类型的内容（图片+文字）
                        const textPart = content.find(p => p.type === 'text')?.text || '';
                        content = textPart ? `[图片+文字：${textPart}]` : '[图片]';
                    }
                    
                    // 确保content是字符串且不为空
                    if (typeof content !== 'string' || !content.trim()) {
                        content = '[特殊消息]';
                    }
                    
                    mountedMemoryContent += `${sender}：${content}\n`;
                });
            }
            
            if (mountedMemoryContent.trim()) {
                console.log('🧠 成功加载挂载记忆，涉及聊天数:', chatSettings.selectedMemoryChats.length);
                return mountedMemoryContent;
            }
            
            return '';
        }
        
        // 加载群聊数据 - 使用IndexedDB（包含数据迁移）
        async function loadGroupChats() {
            try {
                // 先从IndexedDB加载
                const savedGroupChats = await db.groupChats.toArray();
                
                if (savedGroupChats.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('groupChats');
                    if (localStorageData) {
                        console.log('检测到localStorage中的群聊数据，开始迁移...');
                        const localGroupChats = JSON.parse(localStorageData);
                        
                        if (localGroupChats.length > 0) {
                            // 确保每个群聊都有必要字段
                            const migrationData = localGroupChats.map(group => ({
                                id: group.id || Date.now().toString() + Math.random(),
                                name: group.name,
                                description: group.description || '',
                                members: group.members || [],
                                settings: group.settings || {},
                                createdAt: group.createdAt || new Date().toISOString(),
                                updatedAt: group.updatedAt || new Date().toISOString()
                            }));
                            
                            // 迁移到IndexedDB
                            await db.groupChats.bulkAdd(migrationData);
                            groupChats = migrationData;
                            console.log('群聊数据迁移完成:', groupChats);
                        } else {
                            groupChats = [];
                        }
                    } else {
                        groupChats = [];
                    }
                } else {
                    // IndexedDB中有数据，直接使用
                    groupChats = savedGroupChats;
                    console.log('从IndexedDB加载群聊数据:', groupChats);
                }
            } catch (error) {
                console.error('加载群聊失败:', error);
                // 如果IndexedDB失败，回退到localStorage
                const localStorageData = localStorage.getItem('groupChats');
                if (localStorageData) {
                    try {
                        groupChats = JSON.parse(localStorageData);
                        console.log('从localStorage回退加载群聊数据:', groupChats);
                } catch (e) {
                        console.error('群聊数据解析失败:', e);
                    groupChats = [];
                }
            } else {
                groupChats = [];
                }
            }
        }
        
        // 显示历史消息设置
        function showHistorySettings() {
            const chatSettings = getCurrentChatSettings();
            const historyCount = chatSettings.historyCount;
            document.getElementById('history-messages-count').value = Math.min(historyCount, 100);
            document.getElementById('custom-history-count').value = historyCount;
            document.getElementById('history-count-display').textContent = historyCount + '回合';
            document.getElementById('cross-chat-memory').value = chatSettings.crossChatMemory;
            document.getElementById('cross-memory-display').textContent = chatSettings.crossChatMemory + '条';
            
            // 绑定滑块事件
            document.getElementById('history-messages-count').oninput = function() {
                const value = parseInt(this.value);
                document.getElementById('history-count-display').textContent = value + '回合';
                document.getElementById('custom-history-count').value = value;
            };
            
            // 绑定自定义输入框事件
            document.getElementById('custom-history-count').oninput = function() {
                const value = Math.max(0, Math.min(500, parseInt(this.value) || 0));
                this.value = value;
                if (value <= 100) {
                    document.getElementById('history-messages-count').value = value;
                }
                document.getElementById('history-count-display').textContent = value + '回合';
            };
            
            document.getElementById('cross-chat-memory').oninput = function() {
                document.getElementById('cross-memory-display').textContent = this.value + '回合';
            };
            
            showModal('history-settings-modal');
        }
        
        // 保存历史消息设置
        function saveHistorySettings() {
            const chatSettings = getCurrentChatSettings();
            const customValue = parseInt(document.getElementById('custom-history-count').value);
            chatSettings.historyCount = Math.max(0, Math.min(500, customValue || 0));
            chatSettings.crossChatMemory = parseInt(document.getElementById('cross-chat-memory').value);
            
            // 更新设置界面显示的当前值
            document.getElementById('current-history-count').textContent = chatSettings.historyCount + '回合';
            
            saveCurrentChatSettings(chatSettings);
            hideModal('history-settings-modal');
            showToast('历史消息设置已保存', 'success');
        }
        
        // 显示头像设置
        function showAvatarSettings() {
            // 加载当前聊天窗口的头像设置
            const chatSettings = getCurrentChatSettings();
            
            // 设置隐藏头像选项
            const hideAvatarsCheckbox = document.getElementById('hide-avatars');
            if (hideAvatarsCheckbox) {
                hideAvatarsCheckbox.checked = chatSettings.hideAvatars || false;
            }
            
            // 设置我的头像预览
            const myAvatarPreview = document.getElementById('my-chat-avatar-preview');
            if (chatSettings.myChatAvatar) {
                myAvatarPreview.style.backgroundImage = `url(${chatSettings.myChatAvatar})`;
                myAvatarPreview.style.backgroundSize = 'cover';
                myAvatarPreview.style.backgroundPosition = 'center';
                myAvatarPreview.innerHTML = '';
            } else {
                myAvatarPreview.style.backgroundImage = 'none';
                myAvatarPreview.innerHTML = '<i class="fas fa-user"></i>';
            }
            
            // 设置对方头像预览 - 显示当前实际使用的头像（优先显示动态头像）
            const aiAvatarPreview = document.getElementById('ai-chat-avatar-preview');
            const currentAiAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar;
            if (currentAiAvatar) {
                aiAvatarPreview.style.backgroundImage = `url(${currentAiAvatar})`;
                aiAvatarPreview.style.backgroundSize = 'cover';
                aiAvatarPreview.style.backgroundPosition = 'center';
                aiAvatarPreview.innerHTML = '';
                
                // 如果是动态头像，添加提示
                if (chatSettings.aiDynamicAvatar) {
                    aiAvatarPreview.title = '当前显示动态头像（角色在聊天中更换的）';
                } else {
                    aiAvatarPreview.title = '当前显示聊天设置头像';
                }
            } else {
                aiAvatarPreview.style.backgroundImage = 'none';
                aiAvatarPreview.innerHTML = '<i class="fas fa-robot"></i>';
                aiAvatarPreview.title = '使用默认头像';
            }
            
            // 绑定文件上传事件
            bindAvatarUploadEvents();
            
            showModal('avatar-settings-modal');
        }
        
        // 显示昵称设置
        function showNicknameSettings() {
            const chatSettings = getCurrentChatSettings();
            document.getElementById('my-chat-nickname').value = chatSettings.myChatNickname || '';
            document.getElementById('ai-chat-nickname').value = chatSettings.aiChatNickname || '';
            showModal('nickname-settings-modal');
        }
        
        // 显示戳一戳后缀设置
        function showPokeSuffixSettings() {
            const chatSettings = getCurrentChatSettings();
            document.getElementById('my-poke-suffix').value = chatSettings.myPokeSuffix || '';
            document.getElementById('ai-poke-suffix').value = chatSettings.aiPokeSuffix || '';
            showModal('poke-suffix-modal');
        }
        
        // 显示聊天背景设置
        function showBackgroundSettings() {
            const backgroundPreview = document.getElementById('chat-background-preview');
            
            // 重置选择状态
            window.selectedChatBackground = undefined;
            
            // 使用currentChatCharacter.background而不是chatSettings.chatBackground
            if (currentChatCharacter && currentChatCharacter.background) {
                backgroundPreview.style.backgroundImage = `url(${currentChatCharacter.background})`;
                backgroundPreview.style.backgroundSize = 'cover';
                backgroundPreview.style.backgroundPosition = 'center';
                backgroundPreview.querySelector('.preview-text').style.display = 'none';
            } else {
                backgroundPreview.style.backgroundImage = 'none';
                backgroundPreview.querySelector('.preview-text').style.display = 'block';
                backgroundPreview.querySelector('.preview-text').textContent = '背景预览';
            }
            
            // 绑定背景上传事件
            document.getElementById('background-upload').onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        backgroundPreview.style.backgroundImage = `url(${event.target.result})`;
                        backgroundPreview.style.backgroundSize = 'cover';
                        backgroundPreview.style.backgroundPosition = 'center';
                        backgroundPreview.querySelector('.preview-text').style.display = 'none';
                        window.selectedChatBackground = event.target.result;
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            };
            
            showModal('background-settings-modal');
        }
        
        // 显示气泡样式设置
        function showBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 🔥【新增】检查是否为群聊，显示/隐藏群成员设置按钮
            const groupColorsBtn = document.getElementById('group-member-colors-btn');
            if (currentChatCharacter && currentChatCharacter.isGroup) {
                groupColorsBtn.style.display = 'block';
            } else {
                groupColorsBtn.style.display = 'none';
            }
            
            // 加载当前设置
            const currentStyle = chatSettings.bubbleStyle || 'default';
            document.getElementById('my-bubble-color').value = chatSettings.myBubbleColor || '#007AFF';
            document.getElementById('ai-bubble-color').value = chatSettings.aiBubbleColor || '#f0f0f0';
            
            // 加载分离的透明度设置
            document.getElementById('my-bubble-opacity').value = chatSettings.myBubbleOpacity || '1';
            document.getElementById('my-bubble-opacity-value').textContent = Math.round((chatSettings.myBubbleOpacity || 1) * 100) + '%';
            document.getElementById('ai-bubble-opacity').value = chatSettings.aiBubbleOpacity || '1';
            document.getElementById('ai-bubble-opacity-value').textContent = Math.round((chatSettings.aiBubbleOpacity || 1) * 100) + '%';
            
            // 设置当前选中的样式
            document.querySelectorAll('.bubble-style-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.style === currentStyle) {
                    option.classList.add('selected');
                }
            });
            
            // 绑定样式选择事件
            document.querySelectorAll('.bubble-style-option').forEach(option => {
                option.onclick = function() {
                    document.querySelectorAll('.bubble-style-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    this.classList.add('selected');
                    window.selectedBubbleStyle = this.dataset.style;
                };
            });
            
            // 绑定分离的透明度事件
            document.getElementById('my-bubble-opacity').oninput = function() {
                document.getElementById('my-bubble-opacity-value').textContent = Math.round(this.value * 100) + '%';
            };
            
            document.getElementById('ai-bubble-opacity').oninput = function() {
                document.getElementById('ai-bubble-opacity-value').textContent = Math.round(this.value * 100) + '%';
            };
            
            // 加载气泡大小设置
            document.getElementById('bubble-padding').value = chatSettings.bubblePadding || '12';
            updatePaddingValue(chatSettings.bubblePadding || '12');
            
            // 绑定气泡大小事件
            document.getElementById('bubble-padding').oninput = function() {
                updatePaddingValue(this.value);
            };
            
            window.selectedBubbleStyle = currentStyle;
            showModal('bubble-style-modal');
        }
        
        // 显示定时发布设置
        function showScheduleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            document.getElementById('schedule-enabled').checked = chatSettings.scheduleEnabled || false;
            document.getElementById('schedule-enabled').onchange = function() {
                document.getElementById('schedule-times-group').style.display = this.checked ? 'block' : 'none';
            };
            
            // 触发一次显示状态更新
            document.getElementById('schedule-times-group').style.display = 
                document.getElementById('schedule-enabled').checked ? 'block' : 'none';
            
            // 加载已有的时间点
            renderScheduleTimes();
            
            showModal('schedule-settings-modal');
        }
        
        // 异步函数，用于获取聊天窗口的专属设置
        async function getAsyncChatSettings(characterId = null) {
            // 1. 确定使用哪个角色ID
            const chatId = characterId || (currentChatCharacter ? currentChatCharacter.id : null);
            
            if (!chatId) {
                console.warn("无法获取设置：characterId 和 currentChatCharacter 都未定义，返回空设置");
                return {
                    historyCount: 30,
                    timestampEnabled: true,
                    timestampPosition: 'center',
                    bubbleStyle: 'default',
                    characterStatusEnabled: false
                };
            }
            
            // 2. 【性能优化】首先检查内存中是否已有该聊天的设置
            if (chatSettings[chatId]) {
                return chatSettings[chatId];
            }
            
            // 3. 【核心逻辑】如果内存中没有，则从 IndexedDB 数据库异步查询
                try {
                    const dbSettings = await db.chatSettings.get(chatId);
                    if (dbSettings && dbSettings.settings) {
                    // 查到了！存入内存并返回
                    console.log(`✅ 从数据库成功加载ID为 ${chatId} 的设置`);
                        chatSettings[chatId] = dbSettings.settings;
                    return dbSettings.settings;
                    }
                } catch (error) {
                console.error(`从数据库加载ID为 ${chatId} 的设置失败:`, error);
                // 即使数据库查询失败，也要继续执行，尝试创建默认设置
            }

            // 4. 【处理新聊天】如果数据库里也没有，说明这是一个全新的聊天窗口
            console.log(`🔧 ID为 ${chatId} 的聊天无历史设置，正在创建默认设置...`);
            
            // 定义一份干净的默认设置
            const defaultSettings = {
                        // 记忆相关设置（原本的全局设置改为每个聊天独立）
                historyCount: 30,
                        crossChatMemory: 3,
                        enableDynamicMemory: true,
                        enableMusicMemory: true,
                        memoryMountEnabled: false,
                        memoryMountCount: 3,
                        selectedMemoryChats: [],
                        // 时间感知设置
                        timeAwarenessEnabled: true,
                        // 通话设置
                        aiCallEnabled: true,
                        // 心率监测设置
                        aiHeartrateEnabled: false,
                        // 社交动态设置
                        socialEnabled: false,
                        socialFrequency: 'medium',
                        // 后台互动设置
                        backgroundInteractionEnabled: false,
                        backgroundChatEnabled: true,
                        backgroundMomentsEnabled: true,
                        backgroundChatFrequency: 'low',
                        backgroundMomentsFrequency: 'low',
                        scheduledMomentsEnabled: false,
                        scheduledMomentsTimes: [],
                        // 其他原有设置
                        timestampEnabled: true,
                timestampPosition: 'center',
                characterStatusEnabled: false,
                        // 🔥【新增】状态更新频率设置
                        statusUpdateFrequency: 'medium' 
            };

            // 5. 将新创建的默认设置存入内存
            chatSettings[chatId] = defaultSettings;

            // 6. 【重要】同时，立即将这份默认设置保存回数据库，为这个新聊天建立档案
            try {
                await db.chatSettings.put({
                    id: chatId,
                    chatId: chatId,
                    settings: defaultSettings
                });
                console.log(`✅ 已为新聊天 ${chatId} 在数据库中创建了默认设置档案`);
                } catch (error) {
                console.error(`为新聊天 ${chatId} 保存默认设置失败:`, error);
            }
            
            // 7. 返回这份全新的默认设置
            return defaultSettings;
        }
        
        // 兼容层 - 同步版本的getCurrentChatSettings
        // 注意：这个函数只会返回内存中的设置或默认设置，不会从数据库加载
        // 用于不方便修改为async/await的地方
        function getCurrentChatSettings() {
            if (!currentChatCharacter) return {};
            
            const chatId = currentChatCharacter.id;
            
            // 如果内存中有设置，直接返回
            if (chatSettings[chatId]) {
                return chatSettings[chatId];
            }
            
            // 如果内存中没有，创建一个默认设置
            // 注意：这里不会保存到数据库，只是临时使用
            // 下次调用异步版本的getCurrentChatSettings时会正确加载/创建设置
            console.warn(`⚠️ 使用了同步版本获取ID为 ${chatId} 的设置，但内存中没有缓存，返回临时默认设置`);
            
            const defaultSettings = {
                historyCount: 30,
                crossChatMemory: 3,
                enableDynamicMemory: true,
                enableMusicMemory: true,
                memoryMountEnabled: false,
                memoryMountCount: 3,
                selectedMemoryChats: [],
                timeAwarenessEnabled: true,
                aiCallEnabled: true,
                aiHeartrateEnabled: false,
                characterStatusEnabled: false,
                socialEnabled: false,
                socialFrequency: 'medium',
                backgroundInteractionEnabled: false,
                backgroundChatEnabled: true,
                backgroundMomentsEnabled: true,
                backgroundChatFrequency: 'low',
                backgroundMomentsFrequency: 'low',
                scheduledMomentsEnabled: false,
                scheduledMomentsTimes: [],
                timestampEnabled: true,
                timestampPosition: 'center',
                aiHeartrateEnabled: false,
                // 🔥【新增】状态更新频率设置
                statusUpdateFrequency: 'medium'
            };
            
            // 同时触发一个异步加载，以便后续使用
            getAsyncChatSettings().then(settings => {
                console.log(`✅ 后台异步加载ID为 ${chatId} 的设置完成`);
            }).catch(error => {
                console.error(`后台异步加载ID为 ${chatId} 的设置失败:`, error);
            });
            
            return defaultSettings;
        }
        
        // 保存当前聊天的设置 - 使用IndexedDB避免存储限制
        async function saveCurrentChatSettings(settings) {
            if (!currentChatCharacter) return;
            
            const chatId = currentChatCharacter.id;
            
            // 🔥【修复】同步更新全局chatSettings
            chatSettings[chatId] = settings;
            
            try {
                // 保存到IndexedDB
                await db.chatSettings.put({
                    id: chatId,
                    chatId: chatId,
                    settings: settings
                });
                
                console.log('聊天设置已保存到IndexedDB');
                
                // 🔥【压缩备份】只保存重要设置到localStorage作为备份
                const compressedSettings = {
                    // 只保存最重要的设置，减少存储占用
                    // 注意：头像数据不截断，因为会导致无效URL
                    selectedIdentityId: settings.selectedIdentityId, // 🔥【关键修复】保存身份选择
                    aiChatAvatar: settings.aiChatAvatar,
                    myChatAvatar: settings.myChatAvatar,
                    aiDynamicAvatar: settings.aiDynamicAvatar,
                    aiChatNickname: settings.aiChatNickname,
                    myChatNickname: settings.myChatNickname,
                    hideAvatars: settings.hideAvatars,
                    bubbleStyle: settings.bubbleStyle,
                    timestampEnabled: settings.timestampEnabled,
                    timestampPosition: settings.timestampPosition
                };
                
                // 移除undefined值
                Object.keys(compressedSettings).forEach(key => {
                    if (compressedSettings[key] === undefined) {
                        delete compressedSettings[key];
                    }
                });
                
                localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(compressedSettings));
                
            } catch (error) {
                console.error('保存聊天设置到IndexedDB失败，尝试localStorage:', error);
                
                // 如果IndexedDB失败，尝试保存压缩版本到localStorage
                try {
                    const essentialSettings = {
                        selectedIdentityId: settings.selectedIdentityId, // 🔥【关键修复】保存身份选择
                        aiChatNickname: settings.aiChatNickname,
                        myChatNickname: settings.myChatNickname,
                        hideAvatars: settings.hideAvatars,
                        bubbleStyle: settings.bubbleStyle,
                        timestampEnabled: settings.timestampEnabled,
                        timestampPosition: settings.timestampPosition
                    };
                    
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(essentialSettings));
                    console.log('重要设置已保存到localStorage');
                    
                } catch (localError) {
                    console.error('localStorage也存储失败:', localError);
                    alert('存储空间不足！请清理浏览器数据或删除一些聊天记录后重试。');
                }
            }
        }
        
        // 保存聊天模式设置
        async function saveChatModeSettings() {
            if (!currentChatCharacter) return;
            
            const chatSettings = await getAsyncChatSettings();
            
            // 获取选中的聊天模式
            const onlineRadio = document.getElementById('chat-mode-online');
            const offlineRadio = document.getElementById('chat-mode-offline');
            
            if (onlineRadio && offlineRadio) {
                chatSettings.chatMode = onlineRadio.checked ? 'online' : 'offline';
            }
            
            // 获取线下模式字数限制
            const maxLengthInput = document.getElementById('offline-mode-max-length');
            if (maxLengthInput) {
                chatSettings.offlineModeMaxLength = parseInt(maxLengthInput.value) || 100;
            }
            
            await saveCurrentChatSettings(chatSettings);
        }
        
        // 显示记忆挂载设置
        async function showMemoryMountSettings() {
            const chatSettings = await getAsyncChatSettings();
            // 加载当前设置
            document.getElementById('memory-mount-enabled').checked = chatSettings.memoryMountEnabled || false;
            document.getElementById('memory-mount-count').value = chatSettings.memoryMountCount || 3;
            document.getElementById('memory-mount-display').textContent = (chatSettings.memoryMountCount || 3) + '条';
            
            // 控制详细设置的显示
            toggleMemoryMountDetails();
            
            // 绑定事件
            document.getElementById('memory-mount-enabled').onchange = toggleMemoryMountDetails;
            document.getElementById('memory-mount-count').oninput = function() {
                document.getElementById('memory-mount-display').textContent = this.value + '条';
            };
            
            // 渲染聊天列表
            renderMemoryMountChatList();
            
            showModal('memory-mount-modal');
        }
        
        // 切换记忆挂载详细设置显示
        function toggleMemoryMountDetails() {
            const enabled = document.getElementById('memory-mount-enabled').checked;
            document.getElementById('memory-mount-details').style.display = enabled ? 'block' : 'none';
            document.getElementById('memory-mount-chats').style.display = enabled ? 'block' : 'none';
            
            // 更新主设置界面显示
            document.getElementById('current-memory-mount').textContent = enabled ? '已开启' : '已关闭';
        }
        
        // 渲染记忆挂载聊天列表
        async function renderMemoryMountChatList() {
            const container = document.getElementById('memory-mount-list');
            container.innerHTML = '';
            
            if (characters.length === 0 && groupChats.length === 0) {
                container.innerHTML = '<p class="empty-mount-chats">暂无可挂载的聊天</p>';
                return;
            }
            
            // 添加单人聊天
            characters.forEach(character => {
                if (currentChatCharacter && character.id === currentChatCharacter.id) return; // 不显示当前聊天
                
                const item = document.createElement('div');
                item.className = 'mount-item';
                item.innerHTML = `
                    <input type="checkbox" id="mount-${character.id}" value="${character.id}" class="mount-checkbox">
                    <div class="mount-avatar-small" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''} display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                        ${character.avatarUrl ? '' : character.name.charAt(0)}
                    </div>
                    <div>
                        <div class="mount-name">${character.name}</div>
                        <div class="mount-type">单聊</div>
                    </div>
                `;
                container.appendChild(item);
            });
            
            // 添加群聊
            groupChats.forEach(group => {
                if (currentChatCharacter && group.id === currentChatCharacter.id) return; // 不显示当前聊天
                
                const item = document.createElement('div');
                item.className = 'mount-item';
                item.innerHTML = `
                    <input type="checkbox" id="mount-${group.id}" value="${group.id}" class="mount-checkbox">
                    <div class="mount-avatar-group">
                        群
                    </div>
                    <div>
                        <div class="mount-name">${group.name}</div>
                                                    <div class="mount-type">群聊 (${group.members ? group.members.length + 1 : 1}人)</div>
                    </div>
                `;
                container.appendChild(item);
            });
            
            // 加载已选择的聊天
            const chatSettings = await getAsyncChatSettings();
            const selectedChats = chatSettings.selectedMemoryChats || [];
            selectedChats.forEach(chatId => {
                const checkbox = document.getElementById(`mount-${chatId}`);
                if (checkbox) checkbox.checked = true;
            });
        }
        
        // 保存记忆挂载设置
        async function saveMemoryMountSettings() {
            const chatSettings = await getAsyncChatSettings();
            chatSettings.memoryMountEnabled = document.getElementById('memory-mount-enabled').checked;
            chatSettings.memoryMountCount = parseInt(document.getElementById('memory-mount-count').value);
            
            // 获取选中的聊天
            const checkboxes = document.querySelectorAll('#memory-mount-list input[type="checkbox"]:checked');
            chatSettings.selectedMemoryChats = Array.from(checkboxes).map(cb => cb.value);
            
            // 更新主设置界面显示
            document.getElementById('current-memory-mount').textContent = chatSettings.memoryMountEnabled ? '已开启' : '已关闭';
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('memory-mount-modal');
            showToast('记忆挂载设置已保存', 'success');
        }
        
        // 保存聊天头像设置
        async function saveChatAvatarSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 保存隐藏头像设置
            const hideAvatarsCheckbox = document.getElementById('hide-avatars');
            if (hideAvatarsCheckbox) {
                chatSettings.hideAvatars = hideAvatarsCheckbox.checked;
            }
            
            // 🔥【压缩头像】在保存前压缩头像数据
            if (window.selectedMyChatAvatar) {
                chatSettings.myChatAvatar = await compressImage(window.selectedMyChatAvatar, 200, 0.7);
            }
            if (window.selectedAiChatAvatar) {
                chatSettings.aiChatAvatar = await compressImage(window.selectedAiChatAvatar, 200, 0.7);
            }
            
            try {
                await saveCurrentChatSettings(chatSettings);
                hideModal('avatar-settings-modal');
                
                // 刷新聊天界面以显示新头像
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                showToast('头像设置已保存', 'success');
            } catch (error) {
                console.error('保存头像设置失败:', error);
                showToast('保存失败，存储空间可能不足', 'error');
            }
        }
        
        // 保存昵称设置
        async function saveChatNicknameSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.myChatNickname = document.getElementById('my-chat-nickname').value.trim();
            chatSettings.aiChatNickname = document.getElementById('ai-chat-nickname').value.trim();
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('nickname-settings-modal');
            
            // 更新聊天界面标题
            if (currentChatCharacter) {
                const displayTitle = chatSettings.aiChatNickname || currentChatCharacter.name;
                document.getElementById('api-chat-title').textContent = displayTitle;
            }
            
            // 刷新聊天界面
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            // 🔥【修复】刷新消息列表和联系人列表以显示新昵称
            renderMessageList();
            renderContactList();
            
            showToast('昵称设置已保存', 'success');
        }
        
        // 保存戳一戳后缀设置
        async function savePokeSuffixSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.myPokeSuffix = document.getElementById('my-poke-suffix').value.trim();
            chatSettings.aiPokeSuffix = document.getElementById('ai-poke-suffix').value.trim();
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('poke-suffix-modal');
            showToast('戳一戳后缀设置已保存', 'success');
        }
        
        // 保存聊天背景设置
        async function saveChatBackgroundSettings() {
    // 1. 确保有当前聊天角色
    if (!currentChatCharacter) return;
            
    // 2. 根据用户的操作更新背景设置
    // window.selectedChatBackground 在你选择或移除背景时被赋值
    let backgroundToApply;
    
            if (window.selectedChatBackground === null) {
        // 用户点击了"移除背景"
        backgroundToApply = null;
            } else if (window.selectedChatBackground) {
        // 用户选择了新背景
        backgroundToApply = await compressImage(window.selectedChatBackground, 800, 0.8);
    } else {
        // 用户没做任何更改，保持原有设置不变
        backgroundToApply = currentChatCharacter.background;
    }

    // 3. [关键] 立即应用背景设置，这会自动更新currentChatCharacter.background并保存
    await applyChatBackground(backgroundToApply);
    
    // 4. 清理并关闭模态框
    hideModal('background-settings-modal');
    window.selectedChatBackground = undefined; // 清理临时变量
            showToast('聊天背景设置已保存', 'success');
        }
        
        // 移除背景
        function removeBackground() {
            const backgroundPreview = document.getElementById('chat-background-preview');
            backgroundPreview.style.backgroundImage = 'none';
            backgroundPreview.querySelector('.preview-text').style.display = 'block';
            backgroundPreview.querySelector('.preview-text').textContent = '已移除背景';
            window.selectedChatBackground = null;
        }

        // 更新气泡大小显示值
        function updatePaddingValue(value) {
            const paddingValue = document.getElementById('bubble-padding-value');
            if (paddingValue) {
                if (value <= 6) {
                    paddingValue.textContent = '超紧凑';
                } else if (value <= 10) {
                    paddingValue.textContent = '紧凑';
                } else if (value <= 14) {
                    paddingValue.textContent = '中等';
                } else {
                    paddingValue.textContent = '宽松';
                }
            }
        }

        // 保存气泡样式设置
        async function saveBubbleStyleSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 保存样式选择
            if (window.selectedBubbleStyle) {
                chatSettings.bubbleStyle = window.selectedBubbleStyle;
            }
            
            // 保存颜色设置
            chatSettings.myBubbleColor = document.getElementById('my-bubble-color').value;
            chatSettings.aiBubbleColor = document.getElementById('ai-bubble-color').value;
            
            // 保存分离的透明度设置
            chatSettings.myBubbleOpacity = document.getElementById('my-bubble-opacity').value;
            chatSettings.aiBubbleOpacity = document.getElementById('ai-bubble-opacity').value;
            
            // 保存气泡大小设置
            chatSettings.bubblePadding = document.getElementById('bubble-padding').value;
            
            await saveCurrentChatSettings(chatSettings);
            
            // 🔥【修复】立即更新气泡样式显示
            updateBubbleStyleDisplay();
            
            hideModal('bubble-style-modal');
            
            // 刷新聊天界面以应用新设置
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            showToast('气泡样式设置已保存', 'success');
        }

        // 显示时间戳设置
        function showTimestampSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 设置时间戳开关状态
            const timestampEnabled = document.getElementById('timestamp-modal-enabled');
            if (timestampEnabled) {
                timestampEnabled.checked = chatSettings.timestampEnabled !== false; // 默认为true
            }
            
            // 设置时间戳位置选项
            const timestampPosition = chatSettings.timestampPosition || 'center';
            const positionRadios = document.querySelectorAll('input[name="timestamp-position"]');
            positionRadios.forEach(radio => {
                radio.checked = radio.value === timestampPosition;
            });
            
            // 绑定时间戳开关变化事件
            if (timestampEnabled) {
                timestampEnabled.onchange = function() {
                    const optionsGroup = document.getElementById('timestamp-options-group');
                    if (optionsGroup) {
                        optionsGroup.style.display = this.checked ? 'block' : 'none';
                    }
                };
                
                // 触发一次显示状态更新
                const optionsGroup = document.getElementById('timestamp-options-group');
                if (optionsGroup) {
                    optionsGroup.style.display = timestampEnabled.checked ? 'block' : 'none';
                }
            }
            
            showModal('timestamp-settings-modal');
        }

        // 保存时间戳设置
        async function saveTimestampSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 获取时间戳开关状态
            const timestampEnabled = document.getElementById('timestamp-modal-enabled');
            if (timestampEnabled) {
                chatSettings.timestampEnabled = timestampEnabled.checked;
            }
            
            // 获取选中的时间戳位置
            const selectedPosition = document.querySelector('input[name="timestamp-position"]:checked');
            if (selectedPosition) {
                chatSettings.timestampPosition = selectedPosition.value;
            }
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('timestamp-settings-modal');
            
            // 重新渲染聊天消息以应用新的时间戳设置
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            showToast('时间戳设置已保存', 'success');
        }

        // 🔥【新增】群成员气泡颜色设置功能
        function showGroupMemberColorSettings() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) {
                showToast('只有群聊可以设置成员气泡颜色', 'warning');
                return;
            }
            
            // 🔥【新增】先关闭气泡样式设置窗口，避免层级遮挡
            hideModal('bubble-style-modal');
            
            const container = document.getElementById('group-member-colors-list');
            container.innerHTML = '';
            
            const chatSettings = getCurrentChatSettings();
            const memberColors = chatSettings.memberBubbleColors || {};
            
            // 获取群成员列表
            const group = groupChats.find(g => g.id === currentChatCharacter.id);
            console.log('当前群聊:', currentChatCharacter);
            console.log('找到的群聊:', group);
            console.log('群聊成员:', group?.members);
            
            if (!group || !group.members || group.members.length === 0) {
                container.innerHTML = '<p class="text-center-gray">该群聊暂无成员。请先在群聊信息中添加成员。</p>';
                showModal('group-member-colors-modal');
                return;
            }
            
            // 为每个群成员创建颜色设置项
            group.members.forEach(member => {
                // 兼容不同的成员数据结构
                const memberId = typeof member === 'string' ? member : member.id;
                const character = characters.find(c => c.id === memberId);
                if (!character) {
                    console.log('找不到角色:', memberId, '所有角色:', characters.map(c => ({id: c.id, name: c.name})));
                    return;
                }
                
                const memberColor = memberColors[memberId] || '#f0f0f0';
                
                const memberItem = document.createElement('div');
                memberItem.className = 'setting-item';
                memberItem.innerHTML = `
                    <div class="setting-left">
                        <div class="setting-label" style="display: flex; align-items: center; gap: 8px;">
                            <div class="character-avatar" style="width: 24px; height: 24px; background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''} display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px; border-radius: 50%;">
                                ${character.avatarUrl ? '' : character.name.charAt(0)}
                            </div>
                            ${character.name}
                        </div>
                        <div class="setting-desc">设置 ${character.name} 的专属气泡颜色</div>
                    </div>
                    <div class="setting-right">
                        <input type="color" id="member-color-${memberId}" class="color-input" value="${memberColor}" style="width: 40px; height: 30px;">
                    </div>
                `;
                
                container.appendChild(memberItem);
            });
            
            showModal('group-member-colors-modal');
        }
        
        function saveGroupMemberColors() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.memberBubbleColors) {
                chatSettings.memberBubbleColors = {};
            }
            
            // 获取群成员列表
            const group = groupChats.find(g => g.id === currentChatCharacter.id);
            if (!group || !group.members) return;
            
            // 保存每个成员的颜色设置
            group.members.forEach(member => {
                // 兼容不同的成员数据结构
                const memberId = typeof member === 'string' ? member : member.id;
                const colorInput = document.getElementById(`member-color-${memberId}`);
                if (colorInput) {
                    chatSettings.memberBubbleColors[memberId] = colorInput.value;
                }
            });
            
            saveCurrentChatSettings(chatSettings);
            hideModal('group-member-colors-modal');
            
            // 刷新聊天界面以应用新颜色
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
            
            showToast('群成员气泡颜色已保存', 'success');
        }
        
        // 头像上传处理函数
        function avatarUploadHandler(e) {
            console.log('avatar-upload change事件被触发');
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                
                console.log('选择了文件:', file.name, '大小:', file.size, 'bytes', '类型:', file.type);
                
                // 检查文件类型
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    e.target.value = ''; // 清空选择
                    return;
                }
                
                // 检查文件大小 (限制为5MB)
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    e.target.value = ''; // 清空选择
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const avatarPreview = document.getElementById('avatar-preview');
                        const avatarPreviewText = document.getElementById('avatar-preview-text');
                        
                        console.log('文件读取成功，开始设置预览');
                        
                        if (!avatarPreview) {
                            console.error('找不到avatar-preview元素');
                            alert('找不到头像预览元素');
                            return;
                        }
                        
                        // 添加has-image类来覆盖默认背景
                        avatarPreview.classList.add('has-image');
                        
                        // 强制设置背景图片并清除所有其他背景样式
                        avatarPreview.style.setProperty('background', `url(${event.target.result})`, 'important');
                        avatarPreview.style.setProperty('background-size', 'cover', 'important');
                        avatarPreview.style.setProperty('background-position', 'center', 'important');
                        avatarPreview.style.setProperty('background-repeat', 'no-repeat', 'important');
                        
                        // 隐藏文字
                        if (avatarPreviewText) {
                            avatarPreviewText.style.display = 'none';
                        }
                        
                        // 存储图片数据用于后续保存
                        window.selectedAvatarData = event.target.result;
                        
                        // 验证样式是否正确设置
                        console.log('头像预览UI更新完成，背景图片已设置');
                        console.log('当前avatar-preview的样式:', {
                            background: avatarPreview.style.background,
                            backgroundSize: avatarPreview.style.backgroundSize,
                            backgroundPosition: avatarPreview.style.backgroundPosition,
                            className: avatarPreview.className
                        });
                        
                        console.log('头像预览设置成功，图片数据已存储');
                    } catch (error) {
                        console.error('设置头像预览时发生错误:', error);
                        alert('设置头像预览失败，请重试: ' + error.message);
                    }
                };
                
                reader.onerror = function() {
                    console.error('文件读取失败');
                    alert('图片读取失败，请重试');
                    e.target.value = ''; // 清空选择
                };
                
                reader.readAsDataURL(file);
            } else {
                console.log('没有选择文件或files为空');
            }
        }
        
        // 加载自定义表情包 - 使用IndexedDB（包含数据迁移）
        async function loadCustomEmojis() {
            try {
                const savedCustomEmojis = await db.customEmojis.toArray();
                
                if (savedCustomEmojis.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localStorageData = localStorage.getItem('customEmojis');
                    if (localStorageData) {
                        console.log('检测到localStorage中的自定义表情包数据，开始迁移...');
                        const localEmojis = JSON.parse(localStorageData);
                        
                        if (localEmojis.length > 0) {
                            await db.customEmojis.bulkAdd(localEmojis);
                        }
                        
                        customEmojis = localEmojis;
                        console.log('自定义表情包迁移完成:', customEmojis);
                    } else {
                        customEmojis = [];
                    }
                } else {
                    customEmojis = savedCustomEmojis;
                    console.log('从IndexedDB加载自定义表情包:', customEmojis);
                }
                
                // 🔧【修复】recentEmojis也从IndexedDB加载，彻底解决localStorage问题
                const savedRecentEmojis = await db.recentEmojis.orderBy('lastUsed').reverse().toArray();
                if (savedRecentEmojis.length === 0) {
                    // IndexedDB中没有数据，尝试从localStorage迁移
                    const localRecentEmojis = localStorage.getItem('recentEmojis');
                    if (localRecentEmojis) {
                        console.log('检测到localStorage中的recentEmojis数据，开始迁移...');
                        const localRecents = JSON.parse(localRecentEmojis);
                        
                        if (localRecents.length > 0) {
                            // 限制为10个
                            const limitedRecents = localRecents.slice(0, 10);
                            const recentEmojisWithId = limitedRecents.map((emoji, index) => ({
                                id: index + 1,
                                url: emoji.url,
                                description: emoji.description || '表情包',
                                lastUsed: Date.now() - index * 1000
                            }));
                            await db.recentEmojis.bulkAdd(recentEmojisWithId);
                            recentEmojis = limitedRecents;
                            
                            // 清理localStorage
                            localStorage.removeItem('recentEmojis');
                            console.log('recentEmojis迁移完成并清理localStorage');
                        } else {
                            recentEmojis = [];
                        }
                    } else {
                        recentEmojis = [];
                    }
                } else {
                    // 从IndexedDB转换回原格式
                    recentEmojis = savedRecentEmojis.map(item => ({
                        url: item.url,
                        description: item.description
                    }));
                    console.log('从IndexedDB加载recentEmojis:', recentEmojis);
                }
            } catch (error) {
                console.error('加载自定义表情包失败:', error);
                // 如果IndexedDB失败，尝试从localStorage加载
                const localStorageData = localStorage.getItem('customEmojis');
                if (localStorageData) {
                    customEmojis = JSON.parse(localStorageData);
                    console.log('从localStorage备份加载自定义表情包:', customEmojis);
                } else {
                    customEmojis = [];
                }
                
                // 尝试从IndexedDB加载recentEmojis
                try {
                    const savedRecentEmojis = await db.recentEmojis.orderBy('lastUsed').reverse().toArray();
                    if (savedRecentEmojis.length > 0) {
                        recentEmojis = savedRecentEmojis.map(item => ({
                            url: item.url,
                            description: item.description
                        }));
                    } else {
                        recentEmojis = [];
                    }
                } catch (dbError) {
                    // 如果IndexedDB失败，尝试从localStorage加载
                    const localRecentEmojis = localStorage.getItem('recentEmojis');
                    if (localRecentEmojis) {
                        recentEmojis = JSON.parse(localRecentEmojis);
                    } else {
                        recentEmojis = [];
                    }
                }
            }
        }
        
        // 保存自定义表情包 - 使用IndexedDB
        async function saveCustomEmojis() {
            try {
                await db.customEmojis.clear();
                if (customEmojis.length > 0) {
                    await db.customEmojis.bulkAdd(customEmojis);
                }
                
                // 🔧【修复】将recentEmojis也迁移到IndexedDB，彻底解决localStorage问题
                try {
                    // 限制最近使用表情包数量为10个
                    const maxRecentEmojis = 10;
                    if (recentEmojis.length > maxRecentEmojis) {
                        recentEmojis = recentEmojis.slice(0, maxRecentEmojis);
                    }
                    
                    // 将recentEmojis也保存到IndexedDB
                    await db.recentEmojis.clear();
                    if (recentEmojis.length > 0) {
                        const recentEmojisWithId = recentEmojis.map((emoji, index) => ({
                            id: index + 1,
                            url: emoji.url,
                            description: emoji.description || '表情包',
                            lastUsed: Date.now() - index * 1000 // 确保顺序
                        }));
                        await db.recentEmojis.bulkAdd(recentEmojisWithId);
                    }
                    
                    // 清理localStorage中的旧数据（一次性迁移）
                    if (localStorage.getItem('recentEmojis')) {
                        localStorage.removeItem('recentEmojis');
                        console.log('已将recentEmojis迁移到IndexedDB并清理localStorage');
                    }
                } catch (dbError) {
                    console.error('IndexedDB存储失败:', dbError);
                    showToast('❌ 表情包数据存储失败', 'error');
                }
            } catch (error) {
                console.error('保存自定义表情包失败:', error);
                showToast('❌ 表情包保存失败', 'error');
            }
        }
        
        // 显示自定义表情包面板
        function showCustomEmojiPanel() {
            const panel = document.getElementById('custom-emoji-panel');
            const isVisible = panel.style.display === 'block';
            
            if (isVisible) {
                panel.style.display = 'none';
                document.removeEventListener('click', hideCustomEmojiPanel);
            } else {
                panel.style.display = 'block';
                renderEmojiGrid();
                
                // 点击其他地方关闭面板
                setTimeout(() => {
                    document.addEventListener('click', hideCustomEmojiPanel);
                }, 100);
            }
        }
        
        // 隐藏自定义表情包面板
        function hideCustomEmojiPanel(e) {
            const panel = document.getElementById('custom-emoji-panel');
            
            // 如果没有传递事件参数，直接隐藏面板
            if (!e) {
                if (panel) {
                    panel.style.display = 'none';
                    document.removeEventListener('click', hideCustomEmojiPanel);
                }
                return;
            }
            
            const emojiBtn = e.target.closest('.chat-action-btn');
            
            if (panel && !panel.contains(e.target) && !emojiBtn) {
                panel.style.display = 'none';
                document.removeEventListener('click', hideCustomEmojiPanel);
            }
        }
        
        // 渲染表情包网格
        function renderEmojiGrid() {
            const grid = document.getElementById('emoji-grid');
            grid.innerHTML = '';
            
            let emojisToShow = [];
            
            if (currentEmojiTab === 'recent') {
                emojisToShow = recentEmojis;
            } else if (currentEmojiTab === 'custom') {
                emojisToShow = customEmojis;
            }
            
            // 添加表情包
            emojisToShow.forEach((emoji, index) => {
                const emojiItem = document.createElement('div');
                emojiItem.className = 'custom-emoji-item';
                emojiItem.style.backgroundImage = emoji.url && emoji.url !== 'undefined' ? `url(${emoji.url})` : 'none';
                emojiItem.onclick = () => sendEmojiMessage(emoji);
                
                // 为自定义表情包和最近使用表情包添加删除按钮
                if (currentEmojiTab === 'custom' || currentEmojiTab === 'recent') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'emoji-delete-btn';
                    deleteBtn.innerHTML = '×';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (currentEmojiTab === 'custom') {
                        deleteCustomEmoji(index);
                        } else if (currentEmojiTab === 'recent') {
                            deleteRecentEmoji(index);
                        }
                    };
                    emojiItem.appendChild(deleteBtn);
                }
                
                grid.appendChild(emojiItem);
            });
            
            // 如果是自定义标签页，添加上传按钮
            if (currentEmojiTab === 'custom') {
                const uploadItem = document.createElement('div');
                uploadItem.className = 'custom-emoji-item placeholder';
                uploadItem.innerHTML = '+';
                uploadItem.onclick = () => document.getElementById('emoji-upload').click();
                grid.appendChild(uploadItem);
            }
            
            // 如果没有表情包，显示提示
            if (emojisToShow.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'empty-emoji-grid';
                
                                                if (currentEmojiTab === 'recent') {
                                    emptyMsg.textContent = '还没有使用过表情包';
                                } else {
                                    emptyMsg.textContent = '还没有表情包，点击+号添加';
                                }
                
                grid.appendChild(emptyMsg);
            }
        }
        
        // 发送表情包消息
        function sendEmojiMessage(emoji) {
            console.log('🎭 发送表情包:', emoji);
            
            if (!currentChatCharacter) return;
            
            // 添加到最近使用
            addToRecentEmojis(emoji);
            
            // 🔥【修复】表情包消息只显示图片，不显示文字内容
            const messageId = Date.now().toString();
            const emojiMessage = {
                id: messageId,
                sender: 'sent',
                content: '', // 表情包消息不显示文字内容
                image: emoji.url,
                isEmoji: true,
                emojiDescription: emoji.description || '自定义表情包',
                timestamp: Date.now()
            };
            
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            chatMessages[currentChatCharacter.id].push(emojiMessage);
            saveChatMessages();
            
            // 渲染消息
            renderChatMessages(currentChatCharacter.id);
            
            // 🔥【新增】触发角色状态更新
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);
            
            // 隐藏表情包面板
            hideCustomEmojiPanel();
            
            // 设置待回复消息，支持智能回复按钮
            pendingUserMessage = emojiMessage;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
            
            // 注释掉自动回复，改为手动回复模式
            // setTimeout(() => {
            //     sendAIEmojiResponse(emoji);
            // }, 1000 + Math.random() * 2000);
        }
        
        // 添加到最近使用的表情包
        async function addToRecentEmojis(emoji) {
            // 移除已存在的相同表情包
            recentEmojis = recentEmojis.filter(e => e.url !== emoji.url);
            
            // 添加到开头
            recentEmojis.unshift(emoji);
            
            // 限制最近使用数量为20个
            if (recentEmojis.length > 20) {
                recentEmojis = recentEmojis.slice(0, 20);
            }
            
            await saveCustomEmojis();
        }
        
        // 检测当前模型是否支持视觉功能
        function isVisionModelSupported() {
            // 支持视觉的模型列表
            const visionModels = [
                // OpenAI GPT系列
                'gpt-4-vision',
                'gpt-4o',
                'gpt-4-turbo',
                'gpt-4o-mini',
                
                // Google Gemini系列
                'gemini-1.5-pro',
                'gemini-1.5-flash',
                'gemini-2.0-flash',
                'gemini-2.5-pro',
                'gemini-2.5-flash',
                'gemini-exp',
                'gemini-pro-vision',
                
                // Anthropic Claude系列
                'claude-3-opus',
                'claude-3-sonnet',
                'claude-3-haiku',
                'claude-3.5-sonnet',
                'claude-3.5-haiku',
                
                // 国产模型
                'qwen-vl',
                'qwen2-vl',
                'yi-vision',
                'glm-4v',
                'internvl',
                'cogvlm',
                
                // 其他模型
                'llava',
                'moondream',
                'phi-3-vision'
            ];
            
            const currentModel = apiSettings.model?.toLowerCase() || '';
            
            // 检查当前模型是否包含任何支持视觉的模型名称
            const isVisionSupported = visionModels.some(model => currentModel.includes(model.toLowerCase()));
            
            // 输出调试信息
            console.log('当前模型:', currentModel);
            console.log('是否支持视觉:', isVisionSupported);
            
            return isVisionSupported;
        }
        
        // 注释：AI对表情包的自动回复功能已移除，现在使用手动回复模式
        // 表情包和图片都通过智能回复按钮来触发AI回复
        
        // 删除自定义表情包
        function deleteCustomEmoji(index) {
            if (confirm('确定要删除这个表情包吗？')) {
                customEmojis.splice(index, 1);
                saveCustomEmojis();
                renderEmojiGrid();
            }
        }
        
        // 删除最近使用的表情包
        function deleteRecentEmoji(index) {
            if (confirm('确定要从最近使用中删除这个表情包吗？')) {
                recentEmojis.splice(index, 1);
                saveCustomEmojis(); // 🔧【修复】现在使用IndexedDB保存
                renderEmojiGrid();
            }
        }
        
        // 初始化表情包上传功能
        function initializeEmojiUpload() {
            const emojiInput = document.getElementById('emoji-upload');
            if (emojiInput) {
                emojiInput.addEventListener('change', handleEmojiUpload);
            }
            
            // 绑定标签页切换事件
            document.querySelectorAll('.emoji-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    // 移除所有active类
                    document.querySelectorAll('.emoji-tab').forEach(t => t.classList.remove('active'));
                    // 添加当前active类
                    this.classList.add('active');
                    
                    // 切换当前标签页
                    currentEmojiTab = this.dataset.tab;
                    renderEmojiGrid();
                });
            });
        }
        
        // 切换工具面板显示/隐藏
        function toggleToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            const emojiPanel = document.getElementById('custom-emoji-panel');
            
            if (!panel || !toggleBtn) return;
            
            const isVisible = panel.style.display === 'block';
            
            if (isVisible) {
                // 隐藏工具面板
                hideToolsPanel();
            } else {
                // 显示工具面板
                showToolsPanel();
                
                // 隐藏表情包面板
                if (emojiPanel) {
                    emojiPanel.style.display = 'none';
                }
                
                // 点击其他地方关闭面板
                setTimeout(() => {
                    document.addEventListener('click', handleToolsPanelOutsideClick);
                }, 100);
            }
        }
        
        // 显示工具面板
        function showToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            
            if (panel) {
                panel.style.display = 'block';
                panel.style.animation = 'toolsPanelSlideUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
            }
            
            if (toggleBtn) {
                toggleBtn.classList.add('active');
            }
        }
        
        // 隐藏工具面板
        function hideToolsPanel() {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            
            if (panel) {
                panel.style.display = 'none';
            }
            
            if (toggleBtn) {
                toggleBtn.classList.remove('active');
            }
            
            // 移除点击外部关闭的事件监听器
            document.removeEventListener('click', handleToolsPanelOutsideClick);
        }
        
        // 处理工具面板外部点击事件
        function handleToolsPanelOutsideClick(e) {
            const panel = document.getElementById('tools-panel');
            const toggleBtn = document.getElementById('toggle-tools-btn');
            
            // 如果点击的是工具面板内部或触发按钮，不关闭面板
            if (panel && !panel.contains(e.target) && 
                toggleBtn && !toggleBtn.contains(e.target)) {
                hideToolsPanel();
            }
        }
        
        // 处理表情包上传
        function handleEmojiUpload(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            Array.from(files).forEach(file => {
                if (!file.type.startsWith('image/')) {
                    alert('请选择图片文件');
                    return;
                }
                
                // 检查GIF格式，提醒用户可能的问题
                if (file.type === 'image/gif') {
                    const confirmed = confirm('检测到GIF格式的表情包！\n\n⚠️ 注意事项：\n• AI可以发送这个GIF动图\n• 但Gemini API无法识别GIF内容\n• 重新生成功能可能失效\n• 建议使用静态图片格式\n\n是否仍要上传这个GIF表情包？');
                    if (!confirmed) {
                        return;
                    }
                }
                
                if (file.size > 5 * 1024 * 1024) {
                    alert('图片文件过大，请选择小于5MB的图片');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    // 弹出描述输入框
                    const description = prompt('请为这个表情包添加描述（推荐！帮助AI更好地理解表情包内容）:\n\n例如：\n• "笑哭的表情"\n• "握拳加油的动作"\n• "写着OMG的表情包"\n• "愤怒的猫咪图片"', '');
                    
                    const emoji = {
                        id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                        url: event.target.result,
                        description: description || '表情包',
                        addedAt: new Date().toISOString()
                    };
                    
                    customEmojis.push(emoji);
                    saveCustomEmojis();
                    
                    // 如果当前在自定义标签页，重新渲染
                    if (currentEmojiTab === 'custom') {
                        renderEmojiGrid();
                    }
                };
                
                reader.readAsDataURL(file);
            });
            
            // 清空文件输入
            e.target.value = '';
        }
        
        // 判断颜色是否为浅色
        function isLightColor(color) {
            // 将颜色转换为RGB值
            let r, g, b;
            
            if (color.startsWith('#')) {
                // 十六进制颜色
                const hex = color.slice(1);
                if (hex.length === 3) {
                    r = parseInt(hex[0] + hex[0], 16);
                    g = parseInt(hex[1] + hex[1], 16);
                    b = parseInt(hex[2] + hex[2], 16);
                } else {
                    r = parseInt(hex.substr(0, 2), 16);
                    g = parseInt(hex.substr(2, 2), 16);
                    b = parseInt(hex.substr(4, 2), 16);
                }
            } else if (color.startsWith('rgb')) {
                // RGB颜色
                const matches = color.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    r = parseInt(matches[0]);
                    g = parseInt(matches[1]);
                    b = parseInt(matches[2]);
                }
            } else {
                // 默认为深色
                return false;
            }
            
            // 计算亮度
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128;
        }
        
        // 更新气泡预览
        function updateBubblePreview() {
            const myColor = document.getElementById('my-bubble-color')?.value || '#007AFF';
            const aiColor = document.getElementById('ai-bubble-color')?.value || '#f0f0f0';
            const myOpacity = document.getElementById('my-bubble-opacity')?.value || '1';
            const aiOpacity = document.getElementById('ai-bubble-opacity')?.value || '1';
            
            // 更新预览气泡
            const demoMyBubble = document.getElementById('demo-my-bubble');
            const demoAiBubble = document.getElementById('demo-ai-bubble');
            
            if (demoMyBubble) {
                // 使用rgba背景色而不是opacity
                const transparentMyColor = convertColorWithOpacity(myColor, myOpacity);
                demoMyBubble.style.backgroundColor = transparentMyColor;
                demoMyBubble.style.color = isLightColor(myColor) ? '#333' : '#fff';
            }
            
            if (demoAiBubble) {
                // 使用rgba背景色而不是opacity
                const transparentAiColor = convertColorWithOpacity(aiColor, aiOpacity);
                demoAiBubble.style.backgroundColor = transparentAiColor;
                demoAiBubble.style.color = isLightColor(aiColor) ? '#333' : '#fff';
            }
            
            // 更新颜色预览
            const myPreview = document.getElementById('my-bubble-preview');
            const aiPreview = document.getElementById('ai-bubble-preview');
            
            if (myPreview) {
                // 使用rgba背景色而不是opacity
                const transparentMyColor = convertColorWithOpacity(myColor, myOpacity);
                myPreview.style.backgroundColor = transparentMyColor;
                myPreview.textContent = '我的气泡';
            }
            
            if (aiPreview) {
                // 使用rgba背景色而不是opacity
                const transparentAiColor = convertColorWithOpacity(aiColor, aiOpacity);
                aiPreview.style.backgroundColor = transparentAiColor;
                aiPreview.textContent = '对方气泡';
            }
        }
        
        // 绑定头像上传事件
        function bindAvatarUploadEvents() {
            // 我的头像上传
            const myAvatarUpload = document.getElementById('my-chat-avatar-upload');
            if (myAvatarUpload) {
                myAvatarUpload.onchange = function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('my-chat-avatar-preview');
                            if (preview) {
                                preview.style.backgroundImage = `url(${event.target.result})`;
                                preview.style.backgroundSize = 'cover';
                                preview.style.backgroundPosition = 'center';
                                preview.innerHTML = '';
                                window.selectedMyChatAvatar = event.target.result;
                            }
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                };
            }
            
            // AI头像上传
            const aiAvatarUpload = document.getElementById('ai-chat-avatar-upload');
            if (aiAvatarUpload) {
                aiAvatarUpload.onchange = function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('ai-chat-avatar-preview');
                            if (preview) {
                                preview.style.backgroundImage = `url(${event.target.result})`;
                                preview.style.backgroundSize = 'cover';
                                preview.style.backgroundPosition = 'center';
                                preview.innerHTML = '';
                                window.selectedAiChatAvatar = event.target.result;
                            }
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                };
            }
        }
        
        // 初始化头像上传功能
        function initializeAvatarUpload() {
            const avatarInput = document.getElementById('avatar-upload');
            if (!avatarInput) {
                console.error('找不到avatar-upload元素');
                return;
            }
            
            // 移除旧的事件监听器
            avatarInput.removeEventListener('change', avatarUploadHandler);
            
            // 添加新的事件监听器
            avatarInput.addEventListener('change', avatarUploadHandler);
            console.log('头像上传事件监听器已绑定');
        }
        
        // 更新聊天设置界面的显示状态
        async function updateChatSettingsDisplay() {
            if (!currentChatCharacter) {
                console.log("更新聊天设置界面显示：无当前聊天角色，跳过操作");
                return;
            }
            
            const chatSettings = await getAsyncChatSettings();
            
            // 更新历史消息数显示
            const historyCountElement = document.getElementById('current-history-count');
            if (historyCountElement) {
                historyCountElement.textContent = chatSettings.historyCount + '回合';
            }
            
            // 更新记忆挂载显示
            const memoryMountElement = document.getElementById('current-memory-mount');
            if (memoryMountElement) {
                memoryMountElement.textContent = chatSettings.memoryMountEnabled ? '已开启' : '已关闭';
            }
            
            // 更新世界书挂载显示
            updateWorldbookMountDisplay();
            
            // 更新时间感知开关
            const timeAwarenessCheckbox = document.getElementById('time-awareness-enabled');
            if (timeAwarenessCheckbox) {
                timeAwarenessCheckbox.checked = chatSettings.timeAwarenessEnabled;
            }
            
            // 更新通话设置
            const aiCallCheckbox = document.querySelector('.ai-call-enabled-checkbox');
            if (aiCallCheckbox) {
                aiCallCheckbox.checked = chatSettings.aiCallEnabled;
            }
            
            // 更新心率监测设置
            const aiHeartrateCheckbox = document.getElementById('ai-heartrate-enabled');
            if (aiHeartrateCheckbox) {
                aiHeartrateCheckbox.checked = chatSettings.aiHeartrateEnabled;
            }
            
            // 更新角色状态显示设置
            const characterStatusCheckbox = document.getElementById('character-status-enabled');
            if (characterStatusCheckbox) {
                characterStatusCheckbox.checked = chatSettings.characterStatusEnabled || false;
                // 🔥【新增】控制状态更新频率设置的显示
                const statusFrequencySetting = document.getElementById('status-frequency-setting');
                if (statusFrequencySetting) {
                    statusFrequencySetting.style.display = chatSettings.characterStatusEnabled ? 'flex' : 'none';
                }
            }
            
            // 🔥【新增】更新状态更新频率设置
            const statusUpdateFrequencySelect = document.getElementById('status-update-frequency');
            if (statusUpdateFrequencySelect) {
                statusUpdateFrequencySelect.value = chatSettings.statusUpdateFrequency || 'medium';
            }
            

            
            // 更新后台互动设置
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.checked = chatSettings.backgroundInteractionEnabled;
                // 控制详细设置显示
                const backgroundSettings = document.getElementById('background-interaction-settings');
                if (backgroundSettings) {
                    backgroundSettings.style.display = chatSettings.backgroundInteractionEnabled ? 'block' : 'none';
                }
            }
            
            const backgroundChatFrequencySelect = document.getElementById('background-chat-frequency');
            if (backgroundChatFrequencySelect) {
                backgroundChatFrequencySelect.value = chatSettings.backgroundChatFrequency || 'low';
            }
            
            const backgroundChatEnabledCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatEnabledCheckbox) {
                backgroundChatEnabledCheckbox.checked = chatSettings.backgroundChatEnabled !== false;
                // 控制频率设置显示
                const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                if (chatFrequencySetting) {
                    chatFrequencySetting.style.display = chatSettings.backgroundChatEnabled !== false ? 'block' : 'none';
                }
            }
            
            const backgroundMomentsEnabledCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsEnabledCheckbox) {
                backgroundMomentsEnabledCheckbox.checked = chatSettings.backgroundMomentsEnabled !== false;
                // 控制相关设置显示
                const momentsEnabled = chatSettings.backgroundMomentsEnabled !== false;
                const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                const testPublishSetting = document.getElementById('test-publish-setting');
                
                if (momentsFrequencySetting) {
                    momentsFrequencySetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
                if (scheduledMomentsSetting) {
                    scheduledMomentsSetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
                if (testPublishSetting) {
                    testPublishSetting.style.display = momentsEnabled ? 'flex' : 'none';
                }
            }
            
            const backgroundMomentsFrequencySelect = document.getElementById('background-moments-frequency');
            if (backgroundMomentsFrequencySelect) {
                backgroundMomentsFrequencySelect.value = chatSettings.backgroundMomentsFrequency || 'low';
            }
            
            const scheduledMomentsEnabledCheckbox = document.getElementById('scheduled-moments-enabled');
            if (scheduledMomentsEnabledCheckbox) {
                scheduledMomentsEnabledCheckbox.checked = chatSettings.scheduledMomentsEnabled || false;
                // 控制时间设置按钮显示
                const scheduledTimesButton = document.querySelector('button[onclick="showScheduleTimesModal()"]');
                if (scheduledTimesButton) {
                    scheduledTimesButton.style.display = chatSettings.scheduledMomentsEnabled ? 'inline-block' : 'none';
                }
            }
            
            // 更新定时发布时间显示
            updateScheduleTimesDisplay();
            
            // 更新时间戳设置
            const timestampCheckbox = document.getElementById('timestamp-enabled');
            if (timestampCheckbox) {
                timestampCheckbox.checked = chatSettings.timestampEnabled;
            }
            
            // 绑定事件监听器来保存设置变化
            bindChatSettingsEvents();
        }
        
        // 绑定聊天设置的事件监听器
        function bindChatSettingsEvents() {
            // 时间感知开关
            const timeAwarenessCheckbox = document.getElementById('time-awareness-enabled');
            if (timeAwarenessCheckbox) {
                timeAwarenessCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.timeAwarenessEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                };
            }
            
            // 通话设置
            const aiCallCheckboxes = document.querySelectorAll('.ai-call-enabled-checkbox');
            aiCallCheckboxes.forEach(checkbox => {
                checkbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.aiCallEnabled = this.checked;
                    
                    // 同步所有相关复选框的状态
                    aiCallCheckboxes.forEach(cb => {
                        if (cb !== this) {
                            cb.checked = this.checked;
                        }
                    });
                    
                    await saveCurrentChatSettings(chatSettings);
                };
            });
            
            // 心率监测设置
            const aiHeartrateCheckbox = document.getElementById('ai-heartrate-enabled');
            if (aiHeartrateCheckbox) {
                aiHeartrateCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.aiHeartrateEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 立即更新心率显示状态
                    if (currentChatCharacter) {
                        updateAiHeartrate();
                    }
                    
                    showToast(`角色心率监测已${this.checked ? '开启' : '关闭'}`, 'success');
                };
            }
            

            
            // 后台互动设置
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundInteractionEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    // 显示/隐藏详细设置
                    const backgroundSettings = document.getElementById('background-interaction-settings');
                    if (backgroundSettings) {
                        backgroundSettings.style.display = this.checked ? 'block' : 'none';
                    }
                };
            }
            
            const backgroundChatFrequencySelect = document.getElementById('background-chat-frequency');
            if (backgroundChatFrequencySelect) {
                backgroundChatFrequencySelect.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundChatFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);
                };
            }
            
            const backgroundChatEnabledCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatEnabledCheckbox) {
                backgroundChatEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundChatEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 控制频率设置显示
                    const chatFrequencySetting = document.getElementById('chat-frequency-setting');
                    if (chatFrequencySetting) {
                        chatFrequencySetting.style.display = this.checked ? 'block' : 'none';
                    }
                    
                    // 重新初始化后台互动系统
                    initBackgroundInteractionSystem();
                };
            }
            
            const backgroundMomentsEnabledCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsEnabledCheckbox) {
                backgroundMomentsEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundMomentsEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 控制相关设置显示
                    const momentsFrequencySetting = document.getElementById('moments-frequency-setting');
                    const scheduledMomentsSetting = document.getElementById('scheduled-moments-setting');
                    const testPublishSetting = document.getElementById('test-publish-setting');
                    
                    if (momentsFrequencySetting) {
                        momentsFrequencySetting.style.display = this.checked ? 'flex' : 'none';
                    }
                    if (scheduledMomentsSetting) {
                        scheduledMomentsSetting.style.display = this.checked ? 'flex' : 'none';
                    }
                    if (testPublishSetting) {
                        testPublishSetting.style.display = this.checked ? 'flex' : 'none';
                    }
                    
                    // 重新初始化后台互动系统
                    initBackgroundInteractionSystem();
                };
            }
            
            const backgroundMomentsFrequencySelect = document.getElementById('background-moments-frequency');
            if (backgroundMomentsFrequencySelect) {
                backgroundMomentsFrequencySelect.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.backgroundMomentsFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 重新初始化后台互动系统
                    initBackgroundInteractionSystem();
                };
            }
            
            const scheduledMomentsEnabledCheckbox = document.getElementById('scheduled-moments-enabled');
            if (scheduledMomentsEnabledCheckbox) {
                scheduledMomentsEnabledCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.scheduledMomentsEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 控制时间设置按钮显示
                    const scheduledTimesButton = document.querySelector('button[onclick="showScheduleTimesModal()"]');
                    if (scheduledTimesButton) {
                        scheduledTimesButton.style.display = this.checked ? 'inline-block' : 'none';
                    }
                    
                    // 重新初始化定时发布系统
                    initScheduledMomentsSystem();
                };
            }
            
            // 时间戳设置
            const timestampCheckbox = document.getElementById('timestamp-enabled');
            if (timestampCheckbox) {
                timestampCheckbox.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.timestampEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    // 重新渲染聊天消息
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                };
            }
            
            // 角色状态显示设置
            const characterStatusCheckbox = document.getElementById('character-status-enabled');
            if (characterStatusCheckbox) {
                characterStatusCheckbox.onchange = async function() {
                    console.log('状态显示开关被点击:', this.checked);
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.characterStatusEnabled = this.checked;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 🔥【新增】控制状态更新频率设置的显示
                    const statusFrequencySetting = document.getElementById('status-frequency-setting');
                    if (statusFrequencySetting) {
                        statusFrequencySetting.style.display = this.checked ? 'flex' : 'none';
                    }
                    
                    // 重新渲染聊天界面以显示/隐藏状态
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                        // 更新聊天标题区域的状态显示
                        const headerContainer = document.querySelector('#api-chat-screen .header');
                        if (headerContainer) {
                            renderCharacterStatus(currentChatCharacter.id, headerContainer);
                        }
                    }
                    
                    // 🔥【新增】重启状态更新定时器以应用新设置
                    restartCharacterStatusTimer();
                    
                    showToast(`角色状态显示已${this.checked ? '开启' : '关闭'}`, 'success');
                };
            } else {
                console.warn('找不到character-status-enabled元素');
            }
            
            // 🔥【新增】状态更新频率设置
            const statusUpdateFrequencySelect = document.getElementById('status-update-frequency');
            if (statusUpdateFrequencySelect) {
                statusUpdateFrequencySelect.onchange = async function() {
                    const chatSettings = getCurrentChatSettings();
                    chatSettings.statusUpdateFrequency = this.value;
                    await saveCurrentChatSettings(chatSettings);
                    
                    // 重启状态更新定时器以应用新频率
                    restartCharacterStatusTimer();
                    
                    const frequencyNames = {
                        'high': '高频',
                        'medium-high': '中高频',
                        'medium': '中频',
                        'medium-low': '中低频',
                        'low': '低频'
                    };
                    
                    showToast(`状态更新频率已设置为${frequencyNames[this.value]}`, 'success');
                };
            }
        }

        // 初始化聊天设置界面
        async function initializeChatSettings() {
            console.log("开始初始化聊天设置界面");
            
            // 初始化UI相关事件
            initChatSettingsUIEvents();
            
            // 如果没有currentChatCharacter，只初始化UI事件，不加载设置
            if (!currentChatCharacter) {
                console.log("初始化聊天设置界面：无当前聊天角色，只初始化UI事件");
                return;
            }
            
            // 更新身份显示
            await updateChatIdentityDisplay();
            
            // 更新气泡样式显示
            await updateBubbleStyleDisplay();
            
            // 更新所有设置显示状态
            await updateChatSettingsDisplay();
            
            // 加载当前聊天的设置
            if (currentChatCharacter) {
                const chatSettings = await getAsyncChatSettings();
                
                // 设置聊天模式
                const chatMode = chatSettings.chatMode || 'online';
                const onlineRadio = document.getElementById('chat-mode-online');
                const offlineRadio = document.getElementById('chat-mode-offline');
                
                if (onlineRadio && offlineRadio) {
                    if (chatMode === 'online') {
                        onlineRadio.checked = true;
                    } else {
                        offlineRadio.checked = true;
                    }
                    
                    // 显示/隐藏线下模式字数控制
                    const offlineLengthControl = document.getElementById('offline-length-control');
                    if (offlineLengthControl) {
                        offlineLengthControl.style.display = chatMode === 'offline' ? 'flex' : 'none';
                    }
                    
                    // 设置线下模式字数限制
                    const maxLengthInput = document.getElementById('offline-mode-max-length');
                    if (maxLengthInput) {
                        maxLengthInput.value = chatSettings.offlineModeMaxLength || 100;
                    }
                    }
                }
            }
            
        // 初始化聊天设置UI相关事件
        function initChatSettingsUIEvents() {
            // 绑定聊天模式切换事件
            const chatModeRadios = document.querySelectorAll('input[name="chat-mode"]');
            chatModeRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    const offlineLengthControl = document.getElementById('offline-length-control');
                    if (offlineLengthControl) {
                        offlineLengthControl.style.display = this.value === 'offline' ? 'flex' : 'none';
                    }
                    
                    // 保存聊天模式设置
                    if (currentChatCharacter) {
                    saveChatModeSettings();
                    }
                });
            });
            
            // 绑定线下模式字数限制变化事件
            const maxLengthInput = document.getElementById('offline-mode-max-length');
            if (maxLengthInput) {
                maxLengthInput.addEventListener('change', saveChatModeSettings);
            }
            

            
            // 绑定后台互动开关事件
            const backgroundInteractionCheckbox = document.getElementById('background-interaction-enabled');
            if (backgroundInteractionCheckbox) {
                backgroundInteractionCheckbox.addEventListener('change', function() {
                    const backgroundSettings = document.getElementById('background-interaction-settings');
                    if (backgroundSettings) {
                        backgroundSettings.style.display = this.checked ? 'block' : 'none';
                    }
                    
                    // 如果关闭后台互动，清除所有定时器
                    if (!this.checked) {
                        clearAllBackgroundTimers();
                    } else {
                        // 如果开启后台互动，重新初始化系统
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // 绑定主动聊天开关事件
            const backgroundChatCheckbox = document.getElementById('background-chat-enabled');
            if (backgroundChatCheckbox) {
                backgroundChatCheckbox.addEventListener('change', function() {
                    const frequencySetting = document.getElementById('chat-frequency-setting');
                    if (frequencySetting) {
                        frequencySetting.style.display = this.checked ? 'block' : 'none';
                    }
                    
                    // 重新初始化后台互动系统
                    if (currentChatCharacter) {
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // 绑定主动发动态开关事件
            const backgroundMomentsCheckbox = document.getElementById('background-moments-enabled');
            if (backgroundMomentsCheckbox) {
                backgroundMomentsCheckbox.addEventListener('change', function() {
                    const frequencySetting = document.getElementById('moments-frequency-setting');
                    if (frequencySetting) {
                        frequencySetting.style.display = this.checked ? 'flex' : 'none';
                    }
                    
                    // 重新初始化后台互动系统
                    if (currentChatCharacter) {
                        initBackgroundInteractionSystem();
                    }
                });
            }
            
            // 绑定主动拨打电话开关事件
            const aiCallEnabledCheckboxes = document.querySelectorAll('.ai-call-enabled-checkbox');
            aiCallEnabledCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    // 保存设置
                    if (currentChatCharacter) {
                        const chatSettings = getCurrentChatSettings();
                        chatSettings.aiCallEnabled = this.checked;
                        
                        // 同步所有相关复选框的状态
                        aiCallEnabledCheckboxes.forEach(cb => {
                            if (cb !== this) {
                                cb.checked = this.checked;
                            }
                        });
                        
                        saveChatSettings();
                    }
                });
            });
            
            // 绑定戳一戳功能开关事件
            const pokeEnabledCheckbox = document.getElementById('poke-enabled');
            if (pokeEnabledCheckbox) {
                pokeEnabledCheckbox.addEventListener('change', function() {
                    const pokeSuffixSettings = document.getElementById('poke-suffix-settings');
                    if (pokeSuffixSettings) {
                        pokeSuffixSettings.style.display = this.checked ? 'block' : 'none';
                    }
                });
            }
            
            // 绑定选择模式按钮事件
            const selectionCancelBtn = document.getElementById('selection-cancel-btn');
            const selectionDeleteBtn = document.getElementById('selection-delete-btn');
            
            if (selectionCancelBtn) {
                selectionCancelBtn.addEventListener('click', exitMessageSelectionMode);
            }
            
            if (selectionDeleteBtn) {
                selectionDeleteBtn.addEventListener('click', function() {
                    if (selectedMessages.size === 0) return;
                    
                    deleteSelectedMessages();
                });
            }
        }
        
        // 戳一戳功能
        function pokeCharacter(characterId) {
            if (!currentChatCharacter || currentChatCharacter.id !== characterId) {
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const pokeSuffix = chatSettings.myPokeSuffix || '';
            const characterName = chatSettings.aiChatNickname || currentChatCharacter.name;
            
            // 创建戳一戳系统消息
            const pokeMessage = {
                id: Date.now().toString(),
                sender: 'system',
                content: `你戳了戳${characterName}${pokeSuffix}`,
                timestamp: Date.now(),
                isPoke: true
            };
            
            // 添加到聊天记录
            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }
            
            chatMessages[characterId].push(pokeMessage);
            saveChatMessages();
            
            // 渲染消息
            renderChatMessages(characterId);
            
            // 模拟角色回应（40%概率）
            if (Math.random() < 0.4) {
                setTimeout(() => {
                    const aiPokeSuffix = chatSettings.aiPokeSuffix || '';
                    const aiPokeMessage = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `${characterName}戳了戳你${aiPokeSuffix}`,
                        timestamp: Date.now(),
                        isPoke: true
                    };
                    
                    chatMessages[characterId].push(aiPokeMessage);
                    saveChatMessages();
                    renderChatMessages(characterId);
                }, 1000 + Math.random() * 2000);
            }
        }
        
        // 显示聊天选项
        function showChatOptions() {
            showModal('chat-options-modal');
        }
        
        // 显示单聊身份选择（第一步）
        function showSingleChatSelector() {
            hideModal('chat-options-modal');
            showPersonaSelectionForSingleChat();
        }
        
        // 显示单聊身份选择
        function showPersonaSelectionForSingleChat() {
            const modalHTML = `
                <div class="modal" id="persona-selection-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">选择身份</h3>
                            <button class="modal-close" onclick="hidePersonaSelectionModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">请选择你在这次对话中使用的身份面具</p>
                            <div class="persona-selection-list" id="persona-selection-list">
                                ${personas.map(persona => `
                                    <div class="persona-selection-item" data-persona-id="${persona.id}">
                                        <div class="persona-selection-avatar" style="${persona.avatarUrl ? `background-image: url(${persona.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                                            ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                                        </div>
                                        <div class="persona-selection-info">
                                            <div class="persona-selection-name">${persona.name}</div>
                                            <div class="persona-selection-desc">${truncateText(persona.description || '暂无描述', 100)}</div>
                                        </div>
                                        <div class="persona-selection-check">
                                            <i class="fas fa-check"></i>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hidePersonaSelectionModal()">取消</button>
                            <button class="modal-primary" id="confirm-persona-btn" onclick="confirmPersonaAndShowCharacters()" disabled>下一步：选择角色</button>
                        </div>
                    </div>
                </div>
            `;
            
            // 移除已存在的模态框
            const existingModal = document.getElementById('persona-selection-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            // 绑定点击事件
            document.querySelectorAll('.persona-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.persona-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    window.selectedPersonaForChat = this.dataset.personaId;
                    document.getElementById('confirm-persona-btn').disabled = false;
                });
            });
        }
        
        // 隐藏身份选择模态框
        function hidePersonaSelectionModal() {
            const modal = document.getElementById('persona-selection-modal');
            if (modal) {
                modal.remove();
            }
            window.selectedPersonaForChat = null;
        }
        
        // 确认身份选择并显示角色选择
        function confirmPersonaAndShowCharacters() {
            if (!window.selectedPersonaForChat) return;
            
            hidePersonaSelectionModal();
            showCharacterSelectionForSingleChat();
        }
        
        // 显示单聊角色选择（第二步）
        function showCharacterSelectionForSingleChat() {
            // 🔥【修复】保存当前选中的身份ID，防止在后续流程中丢失
            const savedPersonaId = window.selectedPersonaForChat;
            console.log('=== showCharacterSelectionForSingleChat ===');
            console.log('保存的身份ID:', savedPersonaId);
            
            const modalBody = document.getElementById('single-chat-body');
            modalBody.innerHTML = '';
            
            if (characters.length === 0) {
                modalBody.innerHTML = '<p class="empty-mount-chats">还没有角色，请先创建角色</p>';
            } else {
                characters.forEach(character => {
                    const chatOption = document.createElement('div');
                    // 🔥【新增】检查角色是否已存在对话，添加不同的CSS类
                    const hasExistingChat = contacts.includes(character.id);
                    chatOption.className = `chat-option-item ${hasExistingChat ? 'has-existing-chat' : ''}`;
                    
                    chatOption.onclick = () => {
                        // 🔥【修复】使用保存的身份ID而不是全局变量
                        console.log('=== 角色选择点击事件 ===');
                        console.log('选中的角色:', character.name);
                        console.log('使用的身份ID:', savedPersonaId);
                        
                        hideModal('single-chat-modal');
                        // 设置选择的身份并开始聊天
                        startChatWithPersona(character, savedPersonaId);
                        
                        // 清理临时变量
                        window.selectedPersonaForChat = null;
                    };
                    
                    // 🔥【新增】为已存在对话的角色添加状态提示
                    const statusIndicator = hasExistingChat ? `
                        <div class="chat-status-indicator">
                            <i class="fas fa-comments"></i>
                            <span>已有对话</span>
                        </div>
                    ` : '';
                    
                    chatOption.innerHTML = `
                        <div class="chat-option-icon" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url(${character.avatarUrl}); background-size: cover; background-position: center;` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="chat-option-text">
                            <div class="chat-option-title">${character.name}${hasExistingChat ? ' <span class="chat-exists-badge">已有对话</span>' : ''}</div>
                            <div class="chat-option-desc">${truncateText(character.bio || '暂无描述', 80)}</div>
                        </div>
                        ${statusIndicator}
                    `;
                    
                    modalBody.appendChild(chatOption);
                });
            }
            
            showModal('single-chat-modal');
        }
        
        async function startChatWithPersona(character, personaId) {
            console.log('✅[修复] startChatWithPersona 被调用');
            
            // 🔥【新增】检查该角色是否已存在对话
            if (contacts.includes(character.id)) {
                // 角色已存在对话，询问用户是否要继续或取消
                const existingSettings = chatSettings[character.id] || {};
                const existingPersona = personas.find(p => p.id === existingSettings.selectedIdentityId);
                const existingIdentityName = existingPersona ? existingPersona.name : '未知身份';
                
                const confirmed = confirm(
                    `角色「${character.name}」已存在对话！\n` +
                    `当前对话使用的身份：${existingIdentityName}\n\n` +
                    `选择「确定」：继续使用现有对话\n` +
                    `选择「取消」：放弃本次操作`
                );
                
                if (confirmed) {
                    // 用户选择继续使用现有对话，直接开始聊天
                    startChat(character);
                    return;
                } else {
                    // 用户选择取消，不进行任何操作
                    return;
                }
            }
            
            // 🔥【新增身份设置逻辑】角色不存在对话，创建新对话并设置身份
            if (personaId) {
                // 获取或创建此聊天的专属设置
                let settings = chatSettings[character.id] || {};
                settings.selectedIdentityId = personaId;
                const selectedPersona = personas.find(p => p.id === personaId);
                if (selectedPersona) {
                    settings.myChatAvatar = selectedPersona.avatarUrl || '';
                    settings.myChatNickname = selectedPersona.name || '';
                    chatSettings[character.id] = settings;
                    await saveCurrentChatSettings(settings);
                }
            }
            
            // 添加到联系人列表
            console.log('✅[修复] 发现新联系人，正在同步保存...');
            contacts.push(character.id);
            // 使用 await 确保保存操作完成后再继续
            await saveContacts();
            console.log('✅[修复] 新联系人保存成功，内存中的 contacts 列表:', contacts);
            // 保存成功后，立即刷新一次消息列表的后台数据
            renderMessageList();
            
            // 开始聊天
            startChat(character);
        }
        
        
        // 切换群聊成员选择
        function toggleGroupMemberSelection(characterId) {
            const index = selectedGroupMembers.indexOf(characterId);
            const checkbox = document.getElementById(`checkbox-${characterId}`);
            const memberItem = checkbox.closest('.group-member-item');
            
            if (index > -1) {
                selectedGroupMembers.splice(index, 1);
                checkbox.classList.remove('checked');
                checkbox.innerHTML = '';
                memberItem.classList.remove('selected');
            } else {
                if (selectedGroupMembers.length >= 8) {
                    alert('最多只能选择8个成员');
                    return;
                }
                selectedGroupMembers.push(characterId);
                checkbox.classList.add('checked');
                checkbox.innerHTML = '<i class="fas fa-check"></i>';
                memberItem.classList.add('selected');
            }
        }
        
 // --- 请从这里开始，完整复制所有代码 ---

// 1. 显示聊天选项（入口函数，保持不变）
        function showGroupChatSelector() {
            hideModal('chat-options-modal');
            showPersonaSelectionForGroupChat();
        }
        
// 2. 显示群聊身份选择
        function showPersonaSelectionForGroupChat() {
            const modalHTML = `
                <div class="modal" id="persona-selection-group-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">选择身份</h3>
                            <button class="modal-close" onclick="hidePersonaSelectionGroupModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">请选择你在这个群聊中使用的身份面具</p>
                            <div class="persona-selection-list" id="persona-selection-group-list">
                                ${personas.map(persona => `
                                    <div class="persona-selection-item" data-persona-id="${persona.id}">
                                <div class="persona-selection-avatar" style="${persona.avatarUrl ? `background-image: url('${persona.avatarUrl}'); background-size: cover; background-position: center;` : ''}">
                                            ${persona.avatarUrl ? '' : persona.name.charAt(0)}
                                        </div>
                                        <div class="persona-selection-info">
                                            <div class="persona-selection-name">${persona.name}</div>
                                            <div class="persona-selection-desc">${truncateText(persona.description || '暂无描述', 100)}</div>
                                        </div>
                                <div class="persona-selection-check"><i class="fas fa-check"></i></div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hidePersonaSelectionGroupModal()">取消</button>
                    <button class="modal-primary" id="confirm-group-persona-btn" disabled>下一步：设置群聊</button>
                        </div>
                    </div>
                </div>
            `;
            
            const existingModal = document.getElementById('persona-selection-group-modal');
    if (existingModal) existingModal.remove();
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
    let selectedPersonaId = null;

            document.querySelectorAll('#persona-selection-group-modal .persona-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('#persona-selection-group-modal .persona-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
            selectedPersonaId = this.dataset.personaId;
                    document.getElementById('confirm-group-persona-btn').disabled = false;
                    console.log('✅ 选择了身份:', selectedPersonaId, '身份名称:', this.querySelector('.persona-selection-name').textContent);
                });
            });

    // 关键修复：让“下一步”按钮的点击事件直接调用下一步函数，并把ID传过去
    document.getElementById('confirm-group-persona-btn').onclick = () => {
        console.log('✅ 点击下一步按钮，当前selectedPersonaId值为:', selectedPersonaId);
        if (selectedPersonaId) {
            console.log('✅ 准备调用confirmPersonaAndShowGroupSettings，传递ID:', selectedPersonaId);
            confirmPersonaAndShowGroupSettings(selectedPersonaId);
        } else {
            console.error('❌ 未选择身份就点击了下一步');
            alert('请先选择一个身份面具');
        }
    };
}

// 3. 隐藏身份选择模态框的函数
        function hidePersonaSelectionGroupModal() {
            const modal = document.getElementById('persona-selection-group-modal');
    if (modal) modal.remove();
}

// 4. 确认身份并显示群成员选择
function confirmPersonaAndShowGroupSettings(personaId) {
    console.log('✅ confirmPersonaAndShowGroupSettings被调用，接收到的personaId:', personaId);
            hidePersonaSelectionGroupModal();
    showGroupChatMemberSelection(personaId); // 将选择的ID作为参数传递给下一步
        }
        
// 5. 显示群成员选择 (已恢复简介显示)
function showGroupChatMemberSelection(personaId) {
    console.log('✅ showGroupChatMemberSelection被调用，接收到的personaId:', personaId);
    
    // 立即将personaId存储到全局变量中，确保不会丢失
    window.currentGroupPersonaId = personaId;
            document.getElementById('group-chat-name').value = '';
            selectedGroupMembers = [];
            
            const membersContainer = document.getElementById('group-chat-members');
            membersContainer.innerHTML = '';
            
            if (characters.length < 2) {
                membersContainer.innerHTML = '<p class="empty-mount-chats">至少需要2个角色才能创建群聊</p>';
            } else {
                characters.forEach(character => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'group-member-item';
                    memberItem.onclick = () => toggleGroupMemberSelection(character.id);
            // 关键修复：恢复了显示角色简介的HTML代码
                    memberItem.innerHTML = `
                <div class="group-member-checkbox" id="checkbox-${character.id}"></div>
                <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url('${character.avatarUrl}');` : ''}">
                            ${character.avatarUrl ? '' : character.name.charAt(0)}
                        </div>
                        <div class="chat-option-text">
                            <div class="chat-option-title">${character.name}</div>
                    <div class="chat-option-desc">${truncateText(character.bio || '暂无简介', 80)}</div>
                </div>`;
                    membersContainer.appendChild(memberItem);
                });
            }

    // 关键修复：将 personaId 绑定到最终的“创建群聊”按钮上
    console.log('✅ 在第一个位置绑定创建按钮，personaId:', personaId);
    const createBtn = document.getElementById('group-chat-modal').querySelector('.modal-primary');
    createBtn.onclick = () => {
        console.log('✅ 第一个位置的创建群聊按钮被点击，直接使用参数personaId:', personaId);
        createGroupChat(personaId);
    }; // 绑定带参数的创建函数
            
            showModal('group-chat-modal');
        }
        
// 6. 切换群成员选择状态 (无修改，但为了完整性包含在此)
        function toggleGroupMemberSelection(characterId) {
            const index = selectedGroupMembers.indexOf(characterId);
            const checkbox = document.getElementById(`checkbox-${characterId}`);
            const memberItem = checkbox.closest('.group-member-item');
            
            if (index > -1) {
                selectedGroupMembers.splice(index, 1);
                checkbox.classList.remove('checked');
                checkbox.innerHTML = '';
                memberItem.classList.remove('selected');
            } else {
                if (selectedGroupMembers.length >= 8) {
                    alert('最多只能选择8个成员');
                    return;
                }
                selectedGroupMembers.push(characterId);
                checkbox.classList.add('checked');
                checkbox.innerHTML = '<i class="fas fa-check"></i>';
                memberItem.classList.add('selected');
            }
        }
        

// 7. 创建群聊（最终版本）
async function createGroupChat(personaId) {
    console.log(`✅ createGroupChat被调用，身份ID: ${personaId}`);

    const groupName = document.getElementById('group-chat-name').value.trim();
    if (!groupName) return alert('请输入群聊名称');
    if (selectedGroupMembers.length < 2) return alert('至少需要选择2个成员');



            const memberDetails = selectedGroupMembers.map(memberId => {
                const character = characters.find(c => c.id === memberId);
        return { id: character.id, name: character.name, bio: character.bio, avatarUrl: character.avatarUrl, color: character.color };
    });

            const groupChat = {
                id: 'group_' + Date.now().toString(),
                name: groupName,
                members: memberDetails,
                isGroup: true,
                createdAt: new Date().toISOString()
            };
            
    // 只有在 personaId 存在时才保存身份设置
    if (personaId) {
        const selectedPersona = personas.find(p => p.id === personaId);
                if (selectedPersona) {
                    const chatSettings = {
                selectedIdentityId: personaId,
                        myChatAvatar: selectedPersona.avatarUrl,
                        myChatNickname: selectedPersona.name,
                selectedPersonaData: { ...selectedPersona }
            };
                    // 确保 window.chatSettings 已初始化
                    if (!window.chatSettings) {
                        window.chatSettings = {};
                    }
                    window.chatSettings[groupChat.id] = chatSettings;
            await db.chatSettings.put({ id: groupChat.id, chatId: groupChat.id, settings: chatSettings });
            console.log('✅ 群聊身份设置已成功保存');
                } else {
            console.error('❌ 创建群聊时未找到ID为 ' + personaId + ' 的身份。');
                }
            }
            
            if (!groupChats) groupChats = [];
            groupChats.push(groupChat);
            await saveGroupChats();
            hideModal('group-chat-modal');
            renderMessageList();
            alert(`群聊"${groupName}"创建成功！`);
        }

// --- 请复制到这里结束 ---
        
        // 保存群聊数据 - 使用IndexedDB
        async function saveGroupChats() {
            try {
                console.log('保存群聊数据到IndexedDB:', groupChats);
                
                // 检查数据完整性
                if (!groupChats || !Array.isArray(groupChats)) {
                    console.error('群聊数据无效:', groupChats);
                    groupChats = [];
                }
                
                // 验证每个群聊对象的完整性
                const validGroupChats = groupChats.filter(chat => {
                    if (!chat || !chat.id || !chat.name) {
                        console.warn('发现无效的群聊对象:', chat);
                        return false;
                    }
                    return true;
                });
                
                // 如果有无效数据，更新数组
                if (validGroupChats.length !== groupChats.length) {
                    groupChats = validGroupChats;
                    console.log('已过滤无效数据，有效群聊数量:', groupChats.length);
                }
                
                // 使用事务来确保数据一致性
                await db.transaction('rw', db.groupChats, async () => {
                // 清空现有数据
                await db.groupChats.clear();
                
                    // 逐个插入数据以避免批量插入的ID冲突问题
                    for (const chat of groupChats) {
                        try {
                            await db.groupChats.add(chat);
                        } catch (addError) {
                            console.warn('插入群聊失败，尝试更新:', chat.id, addError);
                            // 如果添加失败，尝试更新
                            await db.groupChats.put(chat);
                        }
                    }
                });
                
                console.log('群聊数据保存成功到IndexedDB');
                
                // 同时保存到localStorage作为备份
                try {
                    localStorage.setItem('groupChats', JSON.stringify(groupChats));
                    console.log('群聊数据备份到localStorage成功');
                } catch (storageError) {
                    console.warn('localStorage备份失败:', storageError);
                    // localStorage失败不应该阻止IndexedDB的成功保存
                }
                
            } catch (error) {
                console.error('保存群聊到IndexedDB失败:', error);
                console.error('错误详情:', error.name, error.message);
                
                // 如果IndexedDB失败，回退到localStorage
                try {
                    localStorage.setItem('groupChats', JSON.stringify(groupChats || []));
                    console.log('群聊数据回退保存到localStorage成功');
                    showToast('群聊已保存到本地存储', 'info');
                } catch (localError) {
                    console.error('localStorage保存也失败:', localError);
                    console.error('localStorage错误详情:', localError.name, localError.message);
                    
                    // 检查是否是存储空间不足
                    if (localError.name === 'QuotaExceededError') {
                        alert('存储空间不足，请清理一些数据后重试');
                    } else {
                        alert('保存群聊失败，请尝试刷新页面重新操作');
                    }
                    
                    // 恢复到之前的状态
                    groupChats.pop(); // 移除刚添加的群聊
                    throw localError;
                }
            }
        }
        
        // 渲染定时发布时间点
        function renderScheduleTimes() {
            const container = document.getElementById('schedule-times-container');
            if (!container) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduleTimes || [];
            
            container.innerHTML = '';
            
            scheduleTimes.forEach((time, index) => {
                const timeItem = document.createElement('div');
                timeItem.className = 'schedule-time-item';
                timeItem.innerHTML = `
                    <input type="time" value="${time}" onchange="updateScheduleTime(${index}, this.value)">
                    <button onclick="removeScheduleTime(${index})">×</button>
                `;
                container.appendChild(timeItem);
            });
        }
        
        // 添加定时发布时间点
        async function addScheduleTime() {
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduleTimes) {
                chatSettings.scheduleTimes = [];
            }
            
            if (chatSettings.scheduleTimes.length >= 10) {
                alert('最多只能设置10个时间点');
                return;
            }
            
            chatSettings.scheduleTimes.push('09:00');
            await saveCurrentChatSettings(chatSettings);
            renderScheduleTimes();
        }
        
        // 更新定时发布时间点
        async function updateScheduleTime(index, newTime) {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduleTimes && chatSettings.scheduleTimes[index] !== undefined) {
                chatSettings.scheduleTimes[index] = newTime;
                await saveCurrentChatSettings(chatSettings);
            }
        }
        
        // 移除定时发布时间点
        async function removeScheduleTime(index) {
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduleTimes && chatSettings.scheduleTimes[index] !== undefined) {
                chatSettings.scheduleTimes.splice(index, 1);
                await saveCurrentChatSettings(chatSettings);
                renderScheduleTimes();
            }
        }
        
        // 保存定时发布设置
        async function saveScheduleSettings() {
            const chatSettings = getCurrentChatSettings();
            chatSettings.scheduleEnabled = document.getElementById('schedule-enabled').checked;
            
            await saveCurrentChatSettings(chatSettings);
            hideModal('schedule-settings-modal');
            showToast('定时发布设置已保存', 'success');
        }
        
        // 显示世界书挂载设置
        function showWorldbookMountSettings() {
            const chatSettings = getCurrentChatSettings();
            
            // 加载当前设置
            document.getElementById('worldbook-mount-enabled').checked = chatSettings.worldbookMountEnabled || false;
            
            // 控制详细设置的显示
            toggleWorldbookMountDetails();
            
            // 绑定事件
            document.getElementById('worldbook-mount-enabled').onchange = toggleWorldbookMountDetails;
            
            // 渲染世界书列表
            renderWorldbookMountList();
            
            showModal('worldbook-mount-modal');
        }
        
        // 切换世界书挂载详细设置显示
        function toggleWorldbookMountDetails() {
            const enabled = document.getElementById('worldbook-mount-enabled').checked;
            document.getElementById('worldbook-mount-details').style.display = enabled ? 'block' : 'none';
            
            // 更新主设置界面显示
            updateWorldbookMountDisplay();
        }
        
        // 更新世界书挂载显示状态
        function updateWorldbookMountDisplay() {
            // 如果没有当前聊天角色，跳过
            if (!currentChatCharacter) {
                console.log("更新世界书挂载显示：无当前聊天角色，跳过操作");
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const displayElement = document.getElementById('current-worldbook-mount');
            
            if (!displayElement) {
                console.log("更新世界书挂载显示：无显示元素，跳过操作");
                return;
            }
            
            if (!chatSettings.worldbookMountEnabled) {
                displayElement.textContent = '未挂载';
                return;
            }
            
            const selectedWorldbooks = chatSettings.selectedWorldbooks || [];
            if (selectedWorldbooks.length === 0) {
                displayElement.textContent = '已启用但未选择';
            } else if (selectedWorldbooks.length === 1) {
                const worldbook = worldbooks.find(w => w.id === selectedWorldbooks[0]);
                displayElement.textContent = worldbook ? `已挂载: ${worldbook.title}` : '已挂载: 1个';
            } else {
                displayElement.textContent = `已挂载: ${selectedWorldbooks.length}个`;
            }
        }
        
        // 渲染世界书挂载列表
        function renderWorldbookMountList() {
            const container = document.getElementById('worldbook-mount-list');
            container.innerHTML = '';
            
            // 过滤掉全局世界书，只显示局部世界书
            const localWorldbooks = worldbooks.filter(w => !w.isGlobal);
            
            if (localWorldbooks.length === 0) {
                container.innerHTML = '<p class="empty-mount-chats">暂无局部世界书，请先在世界书应用中创建</p>';
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const selectedWorldbooks = chatSettings.selectedWorldbooks || [];
            
            localWorldbooks.forEach(worldbook => {
                const item = document.createElement('div');
                item.className = 'mount-item worldbook-mount-item';
                
                const isSelected = selectedWorldbooks.includes(worldbook.id);
                
                item.innerHTML = `
                    <input type="checkbox" id="worldbook-${worldbook.id}" value="${worldbook.id}" ${isSelected ? 'checked' : ''} class="worldbook-checkbox">
                    <div class="worldbook-content-flex">
                        <div class="worldbook-title-text">
                            ${worldbook.title}
                        </div>
                        <div class="worldbook-desc-text">
                            ${worldbook.content.length > 100 ? worldbook.content.substring(0, 100) + '...' : worldbook.content}
                        </div>
                        <div class="worldbook-date-text">
                            创建于: ${new Date(worldbook.createdAt).toLocaleDateString('zh-CN')} | 
                            字数: ${worldbook.content.length}
                        </div>
                    </div>
                `;
                
                // 点击整个条目也能切换选择状态
                item.onclick = (e) => {
                    if (e.target.type !== 'checkbox') {
                        const checkbox = item.querySelector('input[type="checkbox"]');
                        checkbox.checked = !checkbox.checked;
                    }
                };
                
                container.appendChild(item);
            });
            
            // 添加提示说明全局世界书自动应用
            const globalInfo = document.createElement('div');
            globalInfo.className = 'worldbook-global-info';
            globalInfo.innerHTML = '<p class="global-worldbook-note">注意：全局世界书已自动应用于所有聊天，无需手动挂载。</p>';
            container.appendChild(globalInfo);
        }
        
        // 保存世界书挂载设置
        function saveWorldbookMountSettings() {
            const chatSettings = getCurrentChatSettings();
            
            chatSettings.worldbookMountEnabled = document.getElementById('worldbook-mount-enabled').checked;
            
            // 获取选中的世界书
            const checkboxes = document.querySelectorAll('#worldbook-mount-list input[type="checkbox"]:checked');
            chatSettings.selectedWorldbooks = Array.from(checkboxes).map(cb => cb.value);
            
            saveCurrentChatSettings(chatSettings);
            updateWorldbookMountDisplay();
            hideModal('worldbook-mount-modal');
            
            const selectedCount = chatSettings.selectedWorldbooks ? chatSettings.selectedWorldbooks.length : 0;
            if (chatSettings.worldbookMountEnabled && selectedCount > 0) {
                showToast(`世界书挂载设置已保存，已挂载 ${selectedCount} 个世界书`, 'success');
            } else if (chatSettings.worldbookMountEnabled) {
                showToast('世界书挂载已启用，但未选择任何世界书', 'info');
            } else {
                showToast('世界书挂载已关闭', 'info');
            }
        }
        
        // 身份选择器功能已移除，身份在创建对话时选择
        
        // 压缩图片以减少存储空间
        function compressImage(dataUrl, maxWidth = 300, quality = 0.8) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // 计算新的尺寸，保持宽高比
                    let { width, height } = img;
                    if (width > height) {
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxWidth) {
                            width = (width * maxWidth) / height;
                            height = maxWidth;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // 绘制并压缩
                    ctx.drawImage(img, 0, 0, width, height);
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    
                    console.log(`图片压缩：${Math.round(dataUrl.length/1024)}KB -> ${Math.round(compressedDataUrl.length/1024)}KB`);
                    resolve(compressedDataUrl);
                };
                img.src = dataUrl;
            });
        }
        

        
        // 🔥【紧急修复】恢复设置并刷新界面
        function recoverAndRefreshSettings() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天窗口', 'warning');
                return;
            }
            
            const chatId = currentChatCharacter.id;
            console.log(`开始恢复聊天设置: ${chatId}`);
            console.log('当前设置状态:', JSON.stringify(chatSettings[chatId], null, 2));
            
            // 显示恢复进度
            showToast('正在尝试恢复设置...', 'info');
            
            // 🔥【直接恢复方法】强制从localStorage恢复，不通过getCurrentChatSettings
            const savedLocalStorage = localStorage.getItem(`chatSettings_${chatId}`);
            if (savedLocalStorage) {
                try {
                    const recoveredSettings = JSON.parse(savedLocalStorage);
                    console.log('从localStorage恢复的设置:', JSON.stringify(recoveredSettings, null, 2));
                    
                    // 直接覆盖全局设置
                    chatSettings[chatId] = recoveredSettings;
                    
                    // 立即刷新当前界面的显示（如果在设置界面）
                    if (document.getElementById('api-chat-settings-screen').style.display !== 'none') {
                        updateChatSettingsDisplay();
                    }
                    
                    // 刷新聊天消息界面
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                    
                    showToast('设置恢复成功！', 'success');
                    console.log('设置恢复完成，当前设置:', JSON.stringify(chatSettings[chatId], null, 2));
                    return;
                } catch (error) {
                    console.error('解析localStorage设置失败:', error);
                }
            }
            
            // 如果localStorage失败，尝试从IndexedDB恢复
            db.chatSettings.get(chatId).then(dbSettings => {
                if (dbSettings && dbSettings.settings) {
                    console.log('从IndexedDB恢复的设置:', JSON.stringify(dbSettings.settings, null, 2));
                    
                    // 直接覆盖全局设置
                    chatSettings[chatId] = dbSettings.settings;
                    
                    // 同步到localStorage
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(dbSettings.settings));
                    
                    // 立即刷新界面
                    if (document.getElementById('api-chat-settings-screen').style.display !== 'none') {
                        updateChatSettingsDisplay();
                    }
                    
                    if (currentChatCharacter) {
                        renderChatMessages(currentChatCharacter.id);
                    }
                    
                    showToast('从备份数据恢复设置成功！', 'success');
                    console.log('从IndexedDB恢复设置成功:', JSON.stringify(dbSettings.settings, null, 2));
                } else {
                    showToast('未找到备份数据，设置可能已永久丢失', 'error');
                    console.log('未找到任何备份数据');
                }
            }).catch(error => {
                console.error('从IndexedDB恢复设置失败:', error);
                showToast('恢复设置失败，请联系技术支持', 'error');
            });
        }
        
        // 🔥【紧急修复】尝试恢复被覆盖的聊天设置
        function recoverChatSettings() {
            if (!currentChatCharacter) return false;
            
            const chatId = currentChatCharacter.id;
            console.log('尝试恢复聊天设置...');
            
            // 尝试从localStorage恢复
            const savedSettings = localStorage.getItem(`chatSettings_${chatId}`);
            if (savedSettings) {
                try {
                    const userSettings = JSON.parse(savedSettings);
                    chatSettings[chatId] = userSettings;
                    console.log('从localStorage恢复聊天设置成功:', userSettings);
                    return true;
                } catch (error) {
                    console.error('从localStorage恢复设置失败:', error);
                }
            }
            
            // 尝试从IndexedDB恢复
            db.chatSettings.get(chatId).then(dbSettings => {
                if (dbSettings && dbSettings.settings) {
                    chatSettings[chatId] = dbSettings.settings;
                    console.log('从IndexedDB恢复聊天设置成功:', dbSettings.settings);
                    // 同步到localStorage
                    localStorage.setItem(`chatSettings_${chatId}`, JSON.stringify(dbSettings.settings));
                    return true;
                }
            }).catch(error => {
                console.error('从IndexedDB恢复设置失败:', error);
            });
            
            return false;
        }
        
        // 强制刷新所有头像显示
        function forceRefreshAvatars() {
            const chatSettings = getCurrentChatSettings();
            const currentAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || currentChatCharacter.avatarUrl;
            
            console.log('强制刷新头像显示，当前头像:', currentAvatar ? currentAvatar.substring(0, 50) + '...' : '无头像');
            
            // 刷新聊天界面中所有角色头像
            const messageAvatars = document.querySelectorAll('.message-avatar');
            messageAvatars.forEach(avatar => {
                // 检查是否是当前角色的头像（通过点击事件判断）
                const onclickAttr = avatar.getAttribute('onclick');
                if (onclickAttr && onclickAttr.includes(`'${currentChatCharacter.id}'`)) {
                    if (currentAvatar && currentAvatar !== 'undefined') {
                        avatar.style.backgroundImage = `url(${currentAvatar})`;
                        avatar.style.backgroundSize = 'cover';
                        avatar.style.backgroundPosition = 'center';
                        avatar.innerHTML = '';
                    } else {
                        avatar.style.backgroundImage = 'none';
                        avatar.innerHTML = currentChatCharacter.name.charAt(0);
                    }
                }
            });
            
            // 如果当前在头像设置界面，也刷新预览
            const aiAvatarPreview = document.getElementById('ai-chat-avatar-preview');
            if (aiAvatarPreview && currentAvatar && currentAvatar !== 'undefined') {
                aiAvatarPreview.style.backgroundImage = `url(${currentAvatar})`;
                aiAvatarPreview.style.backgroundSize = 'cover';
                aiAvatarPreview.style.backgroundPosition = 'center';
                aiAvatarPreview.innerHTML = '';
                
                // 更新提示信息
                if (chatSettings.aiDynamicAvatar) {
                    aiAvatarPreview.title = '当前显示动态头像（角色在聊天中更换的）';
                } else {
                    aiAvatarPreview.title = '当前显示聊天设置头像';
                }
            }
        }
        
        // 📊 计算存储空间使用情况
        async function calculateStorageUsage() {
            try {
                let chatSize = 0;
                let characterSize = 0;
                let settingsSize = 0;
                let emojiSize = 0;

                // 计算聊天记录大小
                const chatMessagesData = await db.chatMessages.toArray();
                chatSize = JSON.stringify(chatMessagesData).length;

                // 计算角色数据大小
                const charactersData = await db.characters.toArray();
                characterSize = JSON.stringify(charactersData).length;

                // 计算聊天设置大小
                const chatSettingsData = await db.chatSettings.toArray();
                settingsSize = JSON.stringify(chatSettingsData).length;

                // 计算表情包大小
                const emojisData = await db.customEmojis.toArray();
                emojiSize = JSON.stringify(emojisData).length;

                const total = chatSize + characterSize + settingsSize + emojiSize;

                // 更新显示
                document.getElementById('chat-storage-size').textContent = formatBytes(chatSize);
                document.getElementById('character-storage-size').textContent = formatBytes(characterSize);
                document.getElementById('settings-storage-size').textContent = formatBytes(settingsSize);
                document.getElementById('emoji-storage-size').textContent = formatBytes(emojiSize);
                document.getElementById('total-storage-size').textContent = formatBytes(total);

                return { chatSize, characterSize, settingsSize, emojiSize, total };
            } catch (error) {
                console.error('计算存储使用情况失败:', error);
                return null;
            }
        }

        // 格式化字节数为可读格式
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 🧹 压缩所有图片
        async function compressAllImages() {
            if (!confirm('将压缩所有头像和背景图片，这可能需要一些时间。确定继续吗？')) {
                return;
            }

            showToast('正在压缩图片...', 'info');
            let compressedCount = 0;

            try {
                // 压缩角色头像
                for (const character of characters) {
                    if (character.avatarUrl && character.avatarUrl.length > 50000) {
                        character.avatarUrl = await compressImage(character.avatarUrl, 150, 0.6);
                        compressedCount++;
                    }
                }
                await saveCharacters();

                // 压缩聊天设置中的头像
                for (const chatId of Object.keys(chatSettings)) {
                    const settings = chatSettings[chatId];
                    if (settings) {
                        if (settings.aiChatAvatar && settings.aiChatAvatar.length > 50000) {
                            settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                            compressedCount++;
                        }
                        if (settings.myChatAvatar && settings.myChatAvatar.length > 50000) {
                            settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                            compressedCount++;
                        }
                        if (settings.chatBackground && settings.chatBackground.length > 100000) {
                            settings.chatBackground = await compressImage(settings.chatBackground, 800, 0.7);
                            compressedCount++;
                        }
                    }
                }
                await saveChatSettings();

                // 更新存储使用情况
                calculateStorageUsage();

                showToast(`图片压缩完成！共处理了 ${compressedCount} 张图片`, 'success');
            } catch (error) {
                console.error('压缩图片失败:', error);
                showToast('压缩过程中出现错误', 'error');
            }
        }

        // 🧹 旧版清理存储空间（保留兼容性）
        async function cleanupStorageSpace() {
            if (!confirm('将清理以下数据以释放存储空间：\n\n• 所有角色的动态头像\n• localStorage中的过期数据\n• 压缩现有头像数据\n\n确定要继续吗？')) {
                return;
            }
            
            showToast('正在清理存储空间...', 'info');
            let cleanedSize = 0;
            let cleanedItems = 0;
            
            try {
                // 1. 清除所有动态头像
                Object.keys(chatSettings).forEach(chatId => {
                    if (chatSettings[chatId] && chatSettings[chatId].aiDynamicAvatar) {
                        delete chatSettings[chatId].aiDynamicAvatar;
                        cleanedItems++;
                    }
                });
                
                // 2. 清理localStorage中的过期chatSettings
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('chatSettings_')) {
                        const value = localStorage.getItem(key);
                        if (value) {
                            cleanedSize += value.length;
                            localStorage.removeItem(key);
                            cleanedItems++;
                        }
                    }
                }
                
                // 3. 压缩所有现有头像数据
                for (const chatId of Object.keys(chatSettings)) {
                    const settings = chatSettings[chatId];
                    if (settings) {
                        if (settings.aiChatAvatar && settings.aiChatAvatar.length > 50000) {
                            settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                            cleanedItems++;
                        }
                        if (settings.myChatAvatar && settings.myChatAvatar.length > 50000) {
                            settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                            cleanedItems++;
                        }
                    }
                }
                
                // 4. 重新保存压缩后的设置到IndexedDB
                await saveChatSettings();
                
                // 5. 刷新当前界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                const sizeKB = Math.round(cleanedSize / 1024);
                showToast(`清理完成！释放了约 ${sizeKB}KB 空间，处理了 ${cleanedItems} 项数据`, 'success');
                
            } catch (error) {
                console.error('清理存储空间失败:', error);
                showToast('清理过程中出现错误，请重试', 'error');
            }
        }
        
        // 清除AI动态头像
        function clearAiDynamicAvatar() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.aiDynamicAvatar) {
                delete chatSettings.aiDynamicAvatar;
                saveCurrentChatSettings(chatSettings);
                
                // 刷新聊天界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                showToast('动态头像已清除，恢复为聊天设置头像', 'success');
            } else {
                showToast('当前没有动态头像', 'info');
            }
        }
        
        // 保存聊天身份选择
        function saveChatIdentity() {
            if (!window.selectedChatIdentityId) {
                alert('请选择一个身份');
                return;
            }
            
            const chatSettings = getCurrentChatSettings();
            const selectedPersona = personas.find(p => p.id === window.selectedChatIdentityId);
            
            if (selectedPersona) {
                chatSettings.selectedIdentityId = selectedPersona.id;
                
                // 如果选中的身份有头像，自动设置为聊天头像（如果当前没有设置的话）
                if (selectedPersona.avatarUrl && !chatSettings.myChatAvatar) {
                    chatSettings.myChatAvatar = selectedPersona.avatarUrl;
                }
                
                // 如果选中的身份有名称，自动设置为聊天昵称（如果当前没有设置的话）
                if (selectedPersona.name && !chatSettings.myChatNickname) {
                    chatSettings.myChatNickname = selectedPersona.name;
                }
                
                saveCurrentChatSettings(chatSettings);
                
                // 更新显示
                updateChatIdentityDisplay();
                
                // 刷新聊天界面
                if (currentChatCharacter) {
                    renderChatMessages(currentChatCharacter.id);
                }
                
                hideModal('identity-selector-modal');
                showToast(`已选择身份"${selectedPersona.name}"`, 'success');
            }
        }
        
        // 更新聊天身份显示
        async function updateChatIdentityDisplay() {
            // 如果没有当前聊天角色，就不执行后续操作
            if (!currentChatCharacter) {
                console.log("更新聊天身份显示：无当前聊天角色，跳过操作");
                return;
            }
            
            const chatSettings = await getAsyncChatSettings();
            const selectedIdentityId = chatSettings.selectedIdentityId || 'default';
            const selectedPersona = personas.find(p => p.id === selectedIdentityId);
            
            const displayElement = document.getElementById('current-chat-identity');
            if (displayElement && selectedPersona) {
                displayElement.textContent = selectedPersona.name;
            }
        }
        
        // 更新气泡样式显示
        async function updateBubbleStyleDisplay() {
            // 如果没有当前聊天角色，就不执行后续操作
            if (!currentChatCharacter) {
                console.log("更新气泡样式显示：无当前聊天角色，跳过操作");
                return;
            }
            
            const chatSettings = await getAsyncChatSettings();
            const styleNames = {
                'default': '默认样式',
                'glass': '毛玻璃',
                'shadow': '经典阴影',
                'tail': '经典气泡',
                'gradient': '渐变样式',
                'minimal': '极简样式',
                'neon': '霓虹样式',
                'paper': '纸张样式'
            };
            
            const displayElement = document.getElementById('current-bubble-style');
            if (displayElement) {
                const currentStyle = chatSettings.bubbleStyle || 'default';
                displayElement.textContent = styleNames[currentStyle] || '默认样式';
            }
        }
        
        // 全局头像上传处理函数
        function handleAvatarUploadClick() {
            console.log('点击了上传头像按钮');
            const input = document.getElementById('avatar-upload');
            if (input) {
                console.log('找到了input元素，准备触发点击');
                input.click();
            } else {
                console.error('找不到avatar-upload元素');
                alert('找不到文件上传元素，请刷新页面重试');
            }
        }
        
        // 该函数已被删除，使用上面的异步IndexedDB版本
        
        // 🔥【修复】添加消息长按监听器 - 支持手机端菜单操作
        function addMessageLongPressListener(messageContainer, messageId) {
            let pressTimer = null;
            let isLongPress = false;
            
            // 检测是否为移动设备
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                             'ontouchstart' in window || 
                             navigator.maxTouchPoints > 0;
            
            const startLongPress = (e) => {
                if (isMessageSelectionMode) {
                    // 在选择模式下，只处理点击选择，不处理长按
                    return;
                }
                isLongPress = false;
                pressTimer = setTimeout(() => {
                    isLongPress = true;
                    
                    // 🔥【新增】手机端显示操作菜单，桌面端进入多选模式
                    if (isMobile) {
                        showMobileMessageMenu(messageId, e);
                    } else {
                    enterMessageSelectionMode(messageId);
                    }
                    e.preventDefault();
                }, 500);
            };
            
            const cancelLongPress = () => {
                clearTimeout(pressTimer);
                // 重置长按标记，延迟重置以避免立即触发点击
                setTimeout(() => {
                    isLongPress = false;
                }, 50);
            };
            
            const handleClick = (e) => {
                // 在选择模式下，所有消息都可以点击切换选择状态
                if (isMessageSelectionMode) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleMessageSelection(messageId);
                    return;
                }
                
                // 如果是长按触发后的点击，不处理
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
            };
            
            // 触摸事件
            messageContainer.addEventListener('touchstart', startLongPress, { passive: false });
            messageContainer.addEventListener('touchend', cancelLongPress);
            messageContainer.addEventListener('touchmove', cancelLongPress);
            
            // 鼠标事件（用于桌面端测试）
            messageContainer.addEventListener('mousedown', startLongPress);
            messageContainer.addEventListener('mouseup', cancelLongPress);
            messageContainer.addEventListener('mouseleave', cancelLongPress);
            
            // 点击事件 - 使用捕获阶段确保优先处理
            messageContainer.addEventListener('click', handleClick, true);
        }
        
        // 🔥【新增】显示手机端消息操作菜单
        function showMobileMessageMenu(messageId, event) {
            selectedMessageId = messageId;
            
            // 检查消息是否是用户发送的（只有用户消息可以撤回）
            const messages = chatMessages[currentChatCharacter.id] || [];
            const message = messages.find(msg => msg.id === messageId);
            const isUserMessage = message && message.sender === 'sent';
            
            // 隐藏已存在的菜单
            hideMobileMessageMenu();
            
            // 创建移动端菜单
            const menu = document.createElement('div');
            menu.id = 'mobile-message-menu';
            menu.className = 'mobile-message-menu';
            
            const menuItems = [
                { text: '引用', action: 'replyToMessage(selectedMessageId)', icon: '↩️', className: 'reply-btn' },
                { text: '复制', action: 'copyMessage()', icon: '📋', className: 'copy-btn' },
                { text: '编辑', action: 'showEditMessageModal(selectedMessageId)', icon: '✏️', className: 'edit-btn' },
                { text: '选择', action: 'enterMessageSelectionMode(selectedMessageId)', icon: '☑️', className: 'select-btn' }
            ];
            
            // 如果是用户消息，添加撤回选项
            if (isUserMessage) {
                menuItems.splice(3, 0, { text: '撤回', action: 'deleteMessage()', icon: '🗑️', className: 'recall-btn', danger: true });
            }
            
            menu.innerHTML = `
                <div class="mobile-menu-overlay" onclick="hideMobileMessageMenu()"></div>
                <div class="mobile-menu-content">
                    <div class="mobile-menu-header">消息操作</div>
                    ${menuItems.map(item => `
                        <div class="mobile-menu-item ${item.className || ''} ${item.danger ? 'danger' : ''}" onclick="${item.action}; hideMobileMessageMenu();">
                            <span class="menu-icon">${item.icon}</span>
                            <span class="menu-text">${item.text}</span>
                        </div>
                    `).join('')}
                    <div class="mobile-menu-item cancel-btn" onclick="hideMobileMessageMenu()">
                        <span class="menu-icon">❌</span>
                        <span class="menu-text">取消</span>
                    </div>
                </div>
            `;
            
            document.body.appendChild(menu);
            
            // 添加显示动画
            setTimeout(() => {
                menu.classList.add('show');
            }, 10);
        }
        
        // 🔥【新增】隐藏手机端消息操作菜单
        function hideMobileMessageMenu() {
            const menu = document.getElementById('mobile-message-menu');
            if (menu) {
                menu.classList.remove('show');
                setTimeout(() => {
                    if (menu.parentNode) {
                        menu.parentNode.removeChild(menu);
                    }
                }, 300);
            }
        }
        
        // 进入消息选择模式
        function enterMessageSelectionMode(initialMessageId) {
            if (isMessageSelectionMode) {
                return;
            }
            
            isMessageSelectionMode = true;
            selectedMessages.clear();
            selectedMessages.add(initialMessageId);
            
            // 添加选择模式CSS类
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.add('selection-mode');
            }
            
            updateMessageSelectionUI();
        }
        
        // 切换消息选择状态
        function toggleMessageSelection(messageId) {
            if (!isMessageSelectionMode) return;
            
            if (selectedMessages.has(messageId)) {
                selectedMessages.delete(messageId);
            } else {
                selectedMessages.add(messageId);
            }
            
            updateMessageSelectionUI();
            
            // 如果没有选中的消息，退出选择模式
            if (selectedMessages.size === 0) {
                exitMessageSelectionMode();
            }
        }
        
        // 退出消息选择模式
        function exitMessageSelectionMode() {
            if (!isMessageSelectionMode) return;
            
            isMessageSelectionMode = false;
            
            // 移除选择模式CSS类
            const chatScreen = document.getElementById('api-chat-screen');
            if (chatScreen) {
                chatScreen.classList.remove('selection-mode');
            }
            
            // 🔥【修复】清除所有选中状态，包括撤回消息
            const selectedContainers = document.querySelectorAll('[data-message-id].selected');
            selectedContainers.forEach(container => {
                container.classList.remove('selected');
            });
            
            selectedMessages.clear();
            updateMessageSelectionUI();
        }
        

        
        // 更新消息选择UI
        function updateMessageSelectionUI() {
            // 🔥【修复】查找所有带有messageId的容器，包括撤回消息
            const allContainers = document.querySelectorAll('[data-message-id]');
            
            allContainers.forEach(container => {
                const messageId = container.dataset.messageId;
                if (messageId) {
                    if (selectedMessages.has(messageId)) {
                        container.classList.add('selected');
                    } else {
                        container.classList.remove('selected');
                    }
                }
            });
            
            // 更新选择计数显示
            const countElement = document.getElementById('selection-count');
            if (countElement) {
                countElement.textContent = `已选 ${selectedMessages.size} 条`;
            }
        }
        
        // 删除选中的消息
        function deleteSelectedMessages() {
            if (selectedMessages.size === 0) return;
            
            if (!currentChatCharacter) return;
            
            if (confirm(`确定要删除选中的 ${selectedMessages.size} 条消息吗？此操作不可恢复！`)) {
                const characterId = currentChatCharacter.id;
                
                if (chatMessages[characterId]) {
                    // 🔥【修复】过滤掉选中的消息，同时删除相关的撤回提示
                    const messagesToDelete = new Set(selectedMessages);
                    
                    // 查找所有要删除的消息内容，用于匹配相关的撤回提示
                    const deleteContentSet = new Set();
                    chatMessages[characterId].forEach(message => {
                        if (selectedMessages.has(message.id) && message.content) {
                            deleteContentSet.add(message.content);
                        }
                    });
                    
                    // 过滤消息：删除选中消息 + 相关的撤回提示
                    chatMessages[characterId] = chatMessages[characterId].filter(message => {
                        // 删除选中的消息
                        if (selectedMessages.has(message.id)) {
                            return false;
                        }
                        
                        // 删除相关的撤回提示（系统消息类型，且原文匹配要删除的消息）
                        if (message.sender === 'system' && message.type === 'recalled_message' && message.originalContent) {
                            if (deleteContentSet.has(message.originalContent)) {
                                console.log('删除相关的撤回提示:', message.content);
                                return false;
                            }
                        }
                        
                        return true;
                    });
                    
                    saveChatMessages();
                    renderChatMessages(characterId);
                    renderMessageList(); // 更新消息列表
                }
                
                // 退出选择模式
                exitMessageSelectionMode();
            }
        }

        // 悬浮按钮功能
        // 变量控制等待回复状态
        let isWaitingForReply = false;
        let pendingUserMessage = null;

      // 用这段新代码，完整替换掉旧的 regenerateLastResponse 函数
        async function regenerateLastResponse() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            // 防止重复调用
            if (window._isRegenerating) {
                console.log('重新生成正在进行中，忽略重复调用');
                return;
            }
            window._isRegenerating = true;

            const characterId = currentChatCharacter.id;
            const messages = chatMessages[characterId] || [];
            
            // 找到最后一条AI消息及其对应的用户消息
            let lastAiMessageIndex = -1;
            let lastUserMessageIndex = -1;
            
            for (let i = messages.length - 1; i >= 0; i--) {
                if (messages[i].sender === 'received' && lastAiMessageIndex === -1) {
                    lastAiMessageIndex = i;
                }
                if (lastAiMessageIndex !== -1 && messages[i].sender === 'sent' && lastUserMessageIndex === -1) {
                    lastUserMessageIndex = i;
                    break;
                }
            }
            
            if (lastAiMessageIndex === -1) {
                alert('没有找到AI回复可以重新生成');
                return;
            }
            
            if (lastUserMessageIndex === -1) {
                alert('没有找到对应的用户消息');
                return;
            }

            const userMessage = messages[lastUserMessageIndex];
            
            // 删除从最后一条用户消息后的所有AI消息
            chatMessages[characterId] = messages.slice(0, lastUserMessageIndex + 1);
    await saveChatMessages(); // 使用 await 确保保存完成
            renderChatMessages(characterId);
            
            showTypingIndicator();
            
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));
            
            try {
                let response;
                
                // 🔥【核心修复】使用新的多模态处理逻辑
                if (Array.isArray(userMessage.content)) {
                    // 这是多模态消息（图文）
                    response = await callChatAPI(userMessage.content, currentChatCharacter);
                } else if (userMessage.image) {
                    // 兼容旧的图片消息格式
                    const messageContent = [
                        { type: 'text', text: userMessage.content || "" },
                        { type: 'image_url', image_url: { url: userMessage.image } }
                    ];
                    response = await callChatAPI(messageContent, currentChatCharacter);
                    } else {
                    // 普通文本消息
                    response = await callChatAPI(userMessage.content, currentChatCharacter);
                }
                const aiMessages = parseAiResponse(response);
                
                hideTypingIndicator();
                
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
                    let aiMessage;
                    
            if (typeof msgData === 'object' && msgData !== null) {
                if (msgData.type === 'voice_message') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'voice_message', content: msgData.content, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'ai_image') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'ai_image', content: '', image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AI描述的图片]</text></svg>')}`, imageDescription: msgData.description, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'transfer') {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'transfer', amount: msgData.amount, note: msgData.note, timestamp: Date.now() + i * 100 };
                } else if (msgData.type === 'emoji') {
                    const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                    if (matchingEmoji) {
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '', image: matchingEmoji.url, isEmoji: true, emojiDescription: matchingEmoji.description, timestamp: Date.now() + i * 100 };
                        addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                    } else {
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: `[表情包"${msgData.description}"不存在]`, timestamp: Date.now() + i * 100 };
                    }
                } else if (msgData.type === 'change_avatar') {
                        if (msgData.avatar_url) {
                            const isValidAvatar = await validateAvatarSource(msgData.avatar_url);
                            if (isValidAvatar) {
                                const success = await changeCharacterAvatarByAI(msgData.avatar_url, msgData.reason || '心情变化');
                            if (success) continue; 
                            else aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[头像更换失败]', timestamp: Date.now() + i * 100 };
                                } else {
                            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无效的头像来源，头像更换失败]', timestamp: Date.now() + i * 100 };
                                }
                            } else {
                        continue;
                    }
                } else if (msgData.name && msgData.message) {
                    // 这是群聊的特殊格式
                    let senderId = null;
                    if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                        const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                        if (member) senderId = member.id;
                    }

                    // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
                    if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                        // 如果消息内容是一个语音消息对象
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'voice_message', // 在外层消息上设置正确的类型
                            name: msgData.name,
                            senderId: senderId,
                            content: msgData.message.content, // 提取真正的语音文字内容
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData.message === 'object' && msgData.message.type === 'transfer') {
                        // 🔥【修复】如果消息内容是一个转账对象
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'transfer', // 在外层消息上设置正确的类型
                            name: msgData.name,
                            senderId: senderId,
                            amount: msgData.message.amount, // 提取转账金额
                            note: msgData.message.note, // 提取转账备注
                            timestamp: Date.now() + i * 100
                        };
                    } else {
                        // 对于普通的文本消息
                        aiMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,
                            senderId: senderId,
                            content: msgData.message, // 内容本身是字符串
                            timestamp: Date.now() + i * 100
                        };
                    }
                    // --- 修复结束 ---
                        } else {
                    // 🔥【关键修复】检查是否是特殊类型对象但未被上面的条件捕获
                    if (typeof msgData === 'object' && msgData !== null) {
                        if (msgData.type === 'transfer') {
                            // 转账对象被遗漏了，重新处理
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                type: 'transfer', 
                                amount: msgData.amount, 
                                note: msgData.note, 
                                timestamp: Date.now() + i * 100 
                            };
                        } else if (msgData.type === 'voice_message') {
                            // 语音消息对象被遗漏了，重新处理
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                type: 'voice_message', 
                                content: msgData.content, 
                                timestamp: Date.now() + i * 100 
                            };
                        } else if (msgData.type === 'ai_image') {
                            // AI图片对象被遗漏了，重新处理
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                type: 'ai_image', 
                                content: '', 
                                image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AI描述的图片]</text></svg>')}`, 
                                imageDescription: msgData.description, 
                                timestamp: Date.now() + i * 100 
                            };
                        } else if (msgData.type === 'emoji') {
                            // 表情包对象被遗漏了，重新处理
                            const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                            if (matchingEmoji) {
                                aiMessage = { 
                                    id: (Date.now() + i).toString(), 
                                    sender: 'received', 
                                    content: '', 
                                    image: matchingEmoji.url, 
                                    isEmoji: true, 
                                    emojiDescription: matchingEmoji.description, 
                                    timestamp: Date.now() + i * 100 
                                };
                                addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                            } else {
                                aiMessage = { 
                                    id: (Date.now() + i).toString(), 
                                    sender: 'received', 
                                    content: `[表情包"${msgData.description}"不存在]`, 
                                    timestamp: Date.now() + i * 100 
                                };
                            }
                        } else {
                            // 其他对象类型，尝试提取文本内容
                            const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[不支持的消息格式]';
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                        }
                                            } else {
                        // 普通字符串或其他基本类型
                        const displayContent = String(msgData);
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                    }
                        }
                                            } else {
                // 🔥【关键修复 - regenerateLastResponse版本】检查是否是特殊类型对象但未被上面的条件捕获
                if (typeof msgData === 'object' && msgData !== null) {
                    if (msgData.type === 'transfer') {
                        // 转账对象被遗漏了，重新处理
                        aiMessage = { 
                            id: (Date.now() + i).toString(), 
                            sender: 'received', 
                            type: 'transfer', 
                            amount: msgData.amount, 
                            note: msgData.note, 
                            timestamp: Date.now() + i * 100 
                        };
                    } else if (msgData.type === 'voice_message') {
                        // 语音消息对象被遗漏了，重新处理
                        aiMessage = { 
                            id: (Date.now() + i).toString(), 
                            sender: 'received', 
                            type: 'voice_message', 
                            content: msgData.content, 
                            timestamp: Date.now() + i * 100 
                        };
                    } else if (msgData.type === 'ai_image') {
                        // AI图片对象被遗漏了，重新处理
                        aiMessage = { 
                            id: (Date.now() + i).toString(), 
                            sender: 'received', 
                            type: 'ai_image', 
                            content: '', 
                            image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AI描述的图片]</text></svg>')}`, 
                            imageDescription: msgData.description, 
                            timestamp: Date.now() + i * 100 
                        };
                    } else if (msgData.type === 'emoji') {
                        // 表情包对象被遗漏了，重新处理
                        const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                        if (matchingEmoji) {
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                content: '', 
                                image: matchingEmoji.url, 
                                isEmoji: true, 
                                emojiDescription: matchingEmoji.description, 
                                timestamp: Date.now() + i * 100 
                            };
                            addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                        } else {
                            aiMessage = { 
                                id: (Date.now() + i).toString(), 
                                sender: 'received', 
                                content: `[表情包"${msgData.description}"不存在]`, 
                                timestamp: Date.now() + i * 100 
                            };
                        }
                    } else {
                        // 其他对象类型，尝试提取文本内容
                        const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[不支持的消息格式]';
                        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                    }
                } else if (typeof msgData === 'string') {
                    // 普通字符串
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: msgData, timestamp: Date.now() + i * 100 };
                } else {
                    // 其他基本类型
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: String(msgData), timestamp: Date.now() + i * 100 };
                }
                    }
                    
                    chatMessages[characterId].push(aiMessage);
            await saveChatMessages();
                    renderChatMessages(characterId);
                    
                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }
            } catch (error) {
                console.error('重新生成失败:', error);
                hideTypingIndicator();
                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[重新生成失败: ${error.message}]`,
                    timestamp: Date.now()
                };
                chatMessages[characterId].push(errorMessage);
        await saveChatMessages();
                renderChatMessages(characterId);
            } finally {
                // 重置重新生成标志
                window._isRegenerating = false;
            }
            
            updateFloatingButtonsVisibility();
        }

        // 智能回复功能
        function triggerSmartReply() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            if (isWaitingForReply) {
                // 🔥【修复】不使用弹窗，改为显示按钮状态提示
                return;
            }

            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // 找到最后一条用户消息
            let lastUserMessage = null;
            let hasUnrepliedUserMessage = false;
            
            for (let i = messages.length - 1; i >= 0; i--) {
                if (messages[i].sender === 'sent') {
                    lastUserMessage = messages[i];
                    
                    // 检查这条用户消息后是否有AI回复
                    hasUnrepliedUserMessage = true;
                    for (let j = i + 1; j < messages.length; j++) {
                        if (messages[j].sender === 'received') {
                            hasUnrepliedUserMessage = false;
                            break;
                        }
                    }
                    break;
                }
            }
            
            // 情况1：有未回复的用户消息
            if (lastUserMessage && hasUnrepliedUserMessage) {
                pendingUserMessage = lastUserMessage;
            processAIReply();
                return;
            }
            
            // 情况2：最后的用户消息已有AI回复，需要AI续写
            if (lastUserMessage && !hasUnrepliedUserMessage) {
                // 检查从最后一条用户消息后的AI回复轮数
                let aiReplyRounds = 0;
                let lastUserMessageIndex = -1;
                
                // 找到最后一条用户消息的索引
                for (let i = messages.length - 1; i >= 0; i--) {
                    if (messages[i].sender === 'sent') {
                        lastUserMessageIndex = i;
                        break;
                    }
                }
                
                // 计算从最后一条用户消息后的AI回复轮数
                // 一轮 = 连续的AI消息直到下一个断点
                if (lastUserMessageIndex !== -1) {
                    let inAIReplyRound = false;
                    
                    for (let i = lastUserMessageIndex + 1; i < messages.length; i++) {
                        if (messages[i].sender === 'received') {
                            if (!inAIReplyRound) {
                                // 开始新的AI回复轮
                                aiReplyRounds++;
                                inAIReplyRound = true;
                            }
                            // 继续当前回合（多条连续AI消息算一轮）
                        } else {
                            // 如果有其他类型消息，结束当前回合
                            inAIReplyRound = false;
                        }
                    }
                }
                
                // AI回复逻辑：
                // aiReplyRounds = 0: 没有回复用户消息，不应该到这里
                // aiReplyRounds = 1: 已回复用户消息1轮，现在是第1次续写（第2轮）
                // aiReplyRounds = 2: 已回复+续写1轮，现在是第2次续写（第3轮）
                // aiReplyRounds >= 3: 已回复+续写2轮，提示用户发消息
                
                if (aiReplyRounds >= 3) {
                    const characterName = currentChatCharacter.name;
                    alert(`${characterName}已经说了很多话了，先和${characterName}说说话吧~`);
                    return;
                }
                
                // 🔥【修复】在续写前也要检查是否有未处理的转账
                const lastUserTransfer = messages.slice().reverse().find(msg => 
                    msg.sender === 'sent' && msg.type === 'transfer' && !msg.status);
                if (lastUserTransfer) {
                    // 如果有未处理的转账，先设置为待处理，然后处理回复
                    pendingUserMessage = lastUserTransfer;
                    processAIReply();
                    return;
                }
                
                // AI续写对话（第1次或第2次续写）
                processAIContinuation();
                return;
            }
            
            // 情况3：没有用户消息
            alert('请先发送一条消息，然后点击此按钮来获取AI回复');
        }

                // 处理AI续写对话
        async function processAIContinuation() {
            if (!currentChatCharacter) return;
            
            // 防止重复调用
            if (isWaitingForReply) {
                console.log('AI正在续写中，忽略重复调用');
                return;
            }
            
            // 🔥【关键修复】记录当前聊天角色ID，确保AI续写消息归属到正确的聊天窗口
            const continuingCharacterId = currentChatCharacter.id;

            isWaitingForReply = true;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = true;
                smartReplyBtn.style.opacity = '0.65';
                smartReplyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            // 显示正在输入提示
            showTypingIndicator();
            
            // 添加随机延迟
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));

            try {
                // 获取AI最后的消息内容，以便基于此续写
                const messages = chatMessages[continuingCharacterId] || [];
                let lastAIMessage = "";
                
                // 找到最后一条AI消息
                for (let i = messages.length - 1; i >= 0; i--) {
                    if (messages[i].sender === 'received') {
                        lastAIMessage = messages[i].content || "";
                        break;
                    }
                }
                
                // 构建续写提示词，基于AI自己最后的话来续写
                let continuationPrompt = "你刚才说了：\"" + lastAIMessage + "\"\n\n";
                continuationPrompt += "现在请基于你刚才说的话，主动继续这个话题或者自然地转到相关话题。就像真实聊天中，你想要继续表达更多想法，或者询问对方的看法，或者分享相关的内容。请自然地继续对话，不要重复之前说过的话。";
                continuationPrompt += "\n\n🚨 重要提醒：请严格遵守JSON格式，每条消息必须分开发送，绝对不能将多条消息合并在一个元素中！正确格式：[\"消息1\", \"消息2\"]，错误格式：[\"消息1\\n消息2\"]";
                
                const response = await callChatAPI(continuationPrompt, currentChatCharacter);
                const aiMessages = parseAiResponse(response);
                
                // 🔥【修复】在续写时也要检查是否有转账需要处理
                const chatHistory = chatMessages[continuingCharacterId] || [];
                const lastUserMessage = chatHistory.slice().reverse().find(msg => 
                    msg.sender === 'sent' && msg.type === 'transfer' && !msg.status);
                if (lastUserMessage) {
                    console.log('🔥 [续写] 检测到用户转账消息，开始处理转账:', {
                        lastUserMessage,
                        aiMessages,
                        characterName: currentChatCharacter?.name
                    });
                    await processUserTransfer(lastUserMessage, aiMessages);
                }
                
                hideTypingIndicator();
                
                // 逐条发送消息
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
                    let aiMessage;
                    
                    if (typeof msgData === 'object' && msgData.type === 'voice_message') {
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'voice_message', 
                            content: msgData.content, 
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'ai_image') {
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'ai_image', 
                            content: '',
                            image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AI描述的图片]</text></svg>')}`,
                            imageDescription: msgData.description,
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'transfer') {
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            type: 'transfer', 
                            amount: msgData.amount, 
                            note: msgData.note, 
                            timestamp: Date.now() + i * 100
                        };
                    } else if (typeof msgData === 'object' && msgData.type === 'emoji') {
                        // 处理AI发送的表情包 - 从本地表情包库中查找
                        const matchingEmoji = customEmojis.find(emoji => 
                            emoji.description === msgData.description
                        );
                        
                        if (matchingEmoji) {
                            aiMessage = { 
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: '',
                                image: matchingEmoji.url,
                                isEmoji: true,
                                emojiDescription: matchingEmoji.description,
                                timestamp: Date.now() + i * 100
                            };
                            
                            // 将表情包添加到最近使用
                            addToRecentEmojis({
                                id: matchingEmoji.id,
                                url: matchingEmoji.url,
                                description: matchingEmoji.description
                            });
                        } else {
                            // 如果找不到表情包，显示错误信息
                            aiMessage = { 
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: `[表情包"${msgData.description}"不存在]`,
                                timestamp: Date.now() + i * 100
                            };
                        }
                    } else if (typeof msgData === 'object' && msgData.type === 'change_avatar') {
                        // 🔥【新增】处理头像更换对象
                        console.log('处理头像更换消息(续写):', msgData);
                        if (msgData.avatar_url) {
                            // 验证头像URL是否来自用户发送的图片或世界书中的URL
                            const isValidAvatar = await validateAvatarSource(msgData.avatar_url);
                            console.log('头像来源验证结果(续写):', isValidAvatar, '头像URL:', msgData.avatar_url);
                            
                            if (isValidAvatar) {
                                // 执行头像更换
                                const success = await changeCharacterAvatarByAI(msgData.avatar_url, msgData.reason || '心情变化');
                                console.log('头像更换执行结果(续写):', success);
                                if (success) {
                                    // 跳过这条消息，只执行头像更换，系统消息已在changeCharacterAvatarByAI中添加
                                    continue;
                                } else {
                                    aiMessage = { 
                                        id: (Date.now() + i).toString(),
                                        sender: 'received',
                                        content: '[头像更换失败]', 
                                        timestamp: Date.now() + i * 100
                                    };
                                }
                            } else {
                                aiMessage = { 
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: '[无效的头像来源，头像更换失败]', 
                                    timestamp: Date.now() + i * 100
                                };
                            }
                        } else {
                            console.log('头像更换消息缺少avatar_url(续写)');
                            continue; // 如果没有有效的头像URL，跳过此消息
                        }
                    } else if (typeof msgData === 'object' && msgData !== null && msgData.name && msgData.message) {
                        // 🔥【群聊消息关键修复】群聊消息格式: {name: "角色名", message: "消息内容"}
                        console.log('🔥 [修复continuation] 发现群聊消息:', msgData);
                        
                        // 查找群成员ID
                        let senderId = null;
                        if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                            const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                            if (member) {
                                senderId = member.id;
                            }
                        }
                        
                        // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
                        if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                            // 如果消息内容是一个语音消息对象
                            aiMessage = {
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                type: 'voice_message', // 在外层消息上设置正确的类型
                                name: msgData.name,
                                senderId: senderId,
                                content: msgData.message.content, // 提取真正的语音文字内容
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // 对于普通的文本消息
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            name: msgData.name,          // 保存发言者名字
                            senderId: senderId,          // 保存发言者ID
                            content: msgData.message,    // 使用message字段作为内容
                            timestamp: Date.now() + i * 100
                        };
                        }
                        // --- 修复结束 ---
                        console.log('✅ [修复continuation] 群聊消息已正确解析:', aiMessage);
                                            } else {
                        // 🔥【关键修复 - 续写版本】检查是否是特殊类型对象但未被上面的条件捕获
                        if (typeof msgData === 'object' && msgData !== null) {
                            if (msgData.type === 'transfer') {
                                // 转账对象被遗漏了，重新处理
                                aiMessage = { 
                                    id: (Date.now() + i).toString(), 
                                    sender: 'received', 
                                    type: 'transfer', 
                                    amount: msgData.amount, 
                                    note: msgData.note, 
                                    timestamp: Date.now() + i * 100 
                                };
                            } else if (msgData.type === 'voice_message') {
                                // 语音消息对象被遗漏了，重新处理
                                aiMessage = { 
                                    id: (Date.now() + i).toString(), 
                                    sender: 'received', 
                                    type: 'voice_message', 
                                    content: msgData.content, 
                                    timestamp: Date.now() + i * 100 
                                };
                            } else if (msgData.type === 'ai_image') {
                                // AI图片对象被遗漏了，重新处理
                                aiMessage = { 
                                    id: (Date.now() + i).toString(), 
                                    sender: 'received', 
                                    type: 'ai_image', 
                                    content: '', 
                                    image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AI描述的图片]</text></svg>')}`, 
                                    imageDescription: msgData.description, 
                                    timestamp: Date.now() + i * 100 
                                };
                            } else if (msgData.type === 'emoji') {
                                // 表情包对象被遗漏了，重新处理
                                const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                                if (matchingEmoji) {
                                    aiMessage = { 
                                        id: (Date.now() + i).toString(), 
                                        sender: 'received', 
                                        content: '', 
                                        image: matchingEmoji.url, 
                                        isEmoji: true, 
                                        emojiDescription: matchingEmoji.description, 
                                        timestamp: Date.now() + i * 100 
                                    };
                                    addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                                } else {
                                    aiMessage = { 
                                        id: (Date.now() + i).toString(), 
                                        sender: 'received', 
                                        content: `[表情包"${msgData.description}"不存在]`, 
                                        timestamp: Date.now() + i * 100 
                                    };
                                }
                            } else {
                                // 其他对象类型，尝试提取文本内容
                                const displayContent = msgData.content || msgData.message || msgData.text || msgData.reply || '[不支持的消息格式]';
                                aiMessage = { 
                                    id: (Date.now() + i).toString(),
                                    sender: 'received',
                                    content: displayContent, 
                                    timestamp: Date.now() + i * 100
                                };
                            }
                        } else if (typeof msgData === 'string') {
                            // 普通字符串
                            aiMessage = { 
                                id: (Date.now() + i).toString(),
                                sender: 'received',
                                content: msgData, 
                                timestamp: Date.now() + i * 100
                            };
                        } else {
                            // 其他基本类型
                        aiMessage = { 
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: String(msgData), 
                            timestamp: Date.now() + i * 100
                        };
                        }
                    }
                    
                    chatMessages[continuingCharacterId].push(aiMessage);
                    saveChatMessages();
                    addMessageWithAnimation(aiMessage, continuingCharacterId);
                    
                    // 🔥【新增】为续写的每条消息创建推送通知
                    if (typeof msgData === 'string' || 
                        (typeof msgData === 'object' && (msgData.type || (msgData.name && msgData.message)))) {
                        console.log('🔥 [推送通知] 续写消息，创建推送通知:', msgData);
                        createPushNotification(currentChatCharacter, msgData, i * 500);
                    }
                    
                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        
                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }
            } catch (error) {
                console.error('AI续写失败:', error);
                hideTypingIndicator();
                
                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[续写失败: ${error.message}]`,
                    timestamp: Date.now()
                };
                
                chatMessages[continuingCharacterId].push(errorMessage);
                saveChatMessages();
                addMessageWithAnimation(errorMessage, continuingCharacterId);
            } finally {
                // 重置状态
                isWaitingForReply = false;
                pendingUserMessage = null;
                
                // 恢复智能回复按钮
                if (smartReplyBtn) {
                    smartReplyBtn.disabled = false;
                    smartReplyBtn.style.opacity = '';
                    smartReplyBtn.style.animation = 'none';
                    smartReplyBtn.classList.remove('waiting');
                    smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                    smartReplyBtn.title = '获取AI回复';
                }
                
                // 更新按钮显示状态
                updateFloatingButtonsVisibility();
            }
        }

        // 处理AI回复
        async function processAIReply() {
            if (!currentChatCharacter) return;
            
            // 防止重复调用
            if (isWaitingForReply) {
                console.log('AI正在回复中，忽略重复调用');
                return;
            }
            
            // 🔥【关键修复】记录当前聊天角色ID，确保AI回复归属到正确的聊天窗口
            const replyingCharacterId = currentChatCharacter.id;
            
            // 智能选择最佳的用户消息（优先图片消息）
            const messages = chatMessages[replyingCharacterId] || [];
            const userMessages = messages.filter(msg => msg.sender === 'sent');
            
            // 优先查找最近的包含图片的消息（5条消息内）
            const recentMessages = userMessages.slice(-5);
            const imageMessage = recentMessages.reverse().find(msg => 
                Array.isArray(msg.content) || msg.image
            );
            
            if (imageMessage) {
                pendingUserMessage = imageMessage;
            } else if (!pendingUserMessage) {
                // 如果没有图片消息且没有待回复消息，使用最后一条用户消息
                const lastUserMessage = userMessages.pop();
                if (lastUserMessage) {
                    pendingUserMessage = lastUserMessage;
                } else {
                    return;
                }
            }

            isWaitingForReply = true;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = true;
                smartReplyBtn.style.opacity = '0.65';
                smartReplyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            }

            // 显示正在输入提示
            showTypingIndicator();
            
            // 添加随机延迟
            const delay = Math.random() * 2000 + 1000;
            await new Promise(resolve => setTimeout(resolve, delay));

            try {
                // 调用API，支持图片和表情包
                // 🔥【核心修复】正确处理多模态消息
                let response;
                

                
                // 核心修复：直接将 pendingUserMessage.content (可能是数组) 传递给 callChatAPI
                if (Array.isArray(pendingUserMessage.content)) {
                    // 这是多模态消息（图文）
                    response = await callChatAPI(pendingUserMessage.content, currentChatCharacter);
                } else if (pendingUserMessage.image) {
                    // 兼容旧的图片消息格式
                    const messageContent = [
                        { type: 'text', text: pendingUserMessage.content || "" },
                        { type: 'image_url', image_url: { url: pendingUserMessage.image } }
                    ];
                    response = await callChatAPI(messageContent, currentChatCharacter);
                        } else {
                    // 普通文本消息、位置消息、语音消息等
                    response = await callChatAPI(pendingUserMessage.content, currentChatCharacter);
                }
                
                const aiMessages = parseAiResponse(response);
                
                for (const msgData of aiMessages) {
    // 检查是否是拉黑指令对象
    if (typeof msgData === 'object' && msgData !== null && msgData.type === 'block_user') {
        console.log('🚫 检测到AI拉黑指令对象:', msgData);
        // 使用指令中的 reason 作为拉黑理由
        await aiBlockUser(currentChatCharacter.id, msgData.reason || '对方未说明理由');
        // 拉黑后，通常不需要再显示后续消息，直接跳出循环
        break; 
    }
}
                
                // 🔥【修复转账处理】如果用户发的是转账消息，需要分析AI的回复来处理转账
                if (pendingUserMessage && pendingUserMessage.type === 'transfer') {
                    console.log('🔥 检测到用户转账消息，开始处理转账:', {
                        pendingUserMessage,
                        aiMessages,
                        characterName: currentChatCharacter?.name
                    });
                    await processUserTransfer(pendingUserMessage, aiMessages);
                }
                
                // 🔥【紧急修复】无论如何，每次AI回复后都检查是否有未处理的转账
                console.log('🔥 [紧急修复] AI回复完成，检查未处理转账');
                const allMessages = chatMessages[replyingCharacterId] || [];
                const unprocessedTransfer = allMessages.slice().reverse().find(msg => 
                    msg.sender === 'sent' && msg.type === 'transfer' && !msg.status);
                if (unprocessedTransfer) {
                    console.log('🔥 [紧急修复] 发现未处理转账，立即处理:', unprocessedTransfer);
                    await processUserTransfer(unprocessedTransfer, aiMessages);
                }
                
                // 🔥【移除关键词触发机制】现在AI会根据自己的判断主动发起通话，不再需要外部触发逻辑
                
                // 🔥【新增】为AI的每条回复创建推送通知
                console.log('🔔 [推送通知] AI回复完成，准备创建推送通知，消息数量:', aiMessages.length);
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
                    console.log('🔔 [推送通知] 处理消息', i, ':', msgData);
                    if (typeof msgData === 'string' || 
                        (typeof msgData === 'object' && (msgData.type || (msgData.name && msgData.message)))) {
                        createPushNotification(currentChatCharacter, msgData, i * 500);
                    }
                }
                
// --- 请用这段全新的代码替换 ---
                hideTypingIndicator();
                
                for (let i = 0; i < aiMessages.length; i++) {
                    const msgData = aiMessages[i];
    let aiMessage; // 先声明变量

    // 🔥【修复】跳过拉黑指令对象，避免显示"不支持的消息格式"
    if (typeof msgData === 'object' && msgData !== null && msgData.type === 'block_user') {
        console.log('🚫 跳过拉黑指令对象，不显示为消息:', msgData);
        continue;
    }

    if (typeof msgData === 'object' && msgData !== null) {
        if (msgData.type === 'voice_message') {
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'voice_message', content: msgData.content, timestamp: Date.now() + i * 100 };
        } else if (msgData.type === 'ai_image') {
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'ai_image', content: '', image: `data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150"><rect width="200" height="150" fill="#f0f0f0"/><text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">[AI描述的图片]</text></svg>')}`, imageDescription: msgData.description, timestamp: Date.now() + i * 100 };
        } else if (msgData.type === 'ai_photo') {
            // 角色发送的"伪照片"
            console.log('处理角色照片消息:', msgData);
            // 确保我们有一个有效的描述
            const photoDesc = msgData.description || msgData.content || msgData.photoDescription || '角色发送的照片';
            console.log('照片描述:', photoDesc);
            aiMessage = { 
                id: (Date.now() + i).toString(), 
                sender: 'received', 
                type: 'user_photo', // 使用与用户照片相同的类型以便复用渲染逻辑
                content: photoDesc,
                photoDescription: photoDesc,
                timestamp: Date.now() + i * 100 
            };
        } else if (msgData.type === 'location') {
            // 角色发送的位置信息
            console.log('处理角色位置消息:', msgData);
            // 确保我们有一个有效的位置名称
            const locationName = msgData.locationName || msgData.name || '未知位置';
            console.log('位置名称:', locationName, '坐标:', msgData.coordinates || '未知坐标');
            aiMessage = { 
                id: (Date.now() + i).toString(), 
                sender: 'received', 
                type: 'location', // 保持类型为location
                locationName: locationName,
                coordinates: msgData.coordinates || '未知坐标',
                content: `[角色分享了位置信息：${locationName}]`,
                timestamp: Date.now() + i * 100 
            };
        } else if (msgData.type === 'transfer') {
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', type: 'transfer', amount: msgData.amount, note: msgData.note, timestamp: Date.now() + i * 100 };
        } else if (msgData.type === 'emoji') {
            const matchingEmoji = customEmojis.find(emoji => emoji.description === msgData.description);
                        if (matchingEmoji) {
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '', image: matchingEmoji.url, isEmoji: true, emojiDescription: matchingEmoji.description, timestamp: Date.now() + i * 100 };
                addToRecentEmojis({ id: matchingEmoji.id, url: matchingEmoji.url, description: matchingEmoji.description });
                        } else {
                aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: `[表情包"${msgData.description}"不存在]`, timestamp: Date.now() + i * 100 };
            }
        } else if (msgData.type === 'change_avatar') {
                        if (msgData.avatar_url) {
                            const isValidAvatar = await validateAvatarSource(msgData.avatar_url);
                            if (isValidAvatar) {
                                const success = await changeCharacterAvatarByAI(msgData.avatar_url, msgData.reason || '心情变化');
                    if (success) continue; 
                    else aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[头像更换失败]', timestamp: Date.now() + i * 100 };
                                } else {
                    aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: '[无效的头像来源，头像更换失败]', timestamp: Date.now() + i * 100 };
                                }
                            } else {
                continue;
            }
        } else if (msgData.type === 'voice_call') {
            // 🔥【新增】处理AI主动发起语音通话
            console.log('🔔 AI请求发起语音通话:', msgData);
            setTimeout(() => {
                initiateAICall(currentChatCharacter, msgData.reason || '想和你聊聊');
            }, 100 + Math.random() * 200); // 进一步减少延迟到0.1-0.3秒
            continue; // 跳过消息显示，因为这是一个动作指令
        } else if (msgData.name && msgData.message) {
            // 这是群聊的特殊格式
            let senderId = null;
            if (currentChatCharacter && currentChatCharacter.isGroup && currentChatCharacter.members) {
                const member = currentChatCharacter.members.find(m => m.name === msgData.name);
                if (member) senderId = member.id;
            }

            // --- 关键修复：检查群聊消息内容是否为特殊类型 ---
            if (typeof msgData.message === 'object' && msgData.message.type === 'voice_message') {
                // 如果消息内容是一个语音消息对象
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'voice_message', // 在外层消息上设置正确的类型
                    name: msgData.name,
                    senderId: senderId,
                    content: msgData.message.content, // 提取真正的语音文字内容
                    timestamp: Date.now() + i * 100
                };
            } else if (typeof msgData.message === 'object' && msgData.message.type === 'transfer') {
                // 🔥【修复】如果消息内容是一个转账对象
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    type: 'transfer', // 在外层消息上设置正确的类型
                    name: msgData.name,
                    senderId: senderId,
                    amount: msgData.message.amount, // 提取转账金额
                    note: msgData.message.note, // 提取转账备注
                    timestamp: Date.now() + i * 100
                };
            } else {
                // 对于普通的文本消息
                aiMessage = {
                    id: (Date.now() + i).toString(),
                    sender: 'received',
                    name: msgData.name,
                    senderId: senderId,
                    content: msgData.message, // 内容本身是字符串
                    timestamp: Date.now() + i * 100
                };
            }
            // --- 修复结束 ---
                    } else {
            // 其他所有未知对象的处理 - 修复[object Object]问题
            let displayContent;
            if (msgData.content && typeof msgData.content === 'string') {
                displayContent = msgData.content;
            } else if (msgData.message && typeof msgData.message === 'string') {
                displayContent = msgData.message;
            } else if (msgData.text && typeof msgData.text === 'string') {
                displayContent = msgData.text;
            } else if (msgData.reply && typeof msgData.reply === 'string') {
                displayContent = msgData.reply;
            } else if (typeof msgData === 'string') {
                displayContent = msgData;
            } else {
                // 对于其他复杂对象，提取有用信息或显示类型提示
                console.warn('未处理的对象类型:', msgData);
                displayContent = '[不支持的消息格式]';
            }
            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: displayContent, timestamp: Date.now() + i * 100 };
                            }
                        } else if (typeof msgData === 'string') {
                            // 普通字符串
                            aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: msgData, timestamp: Date.now() + i * 100 };
                        } else {
                            // 其他类型，强制转换为字符串
        aiMessage = { id: (Date.now() + i).toString(), sender: 'received', content: String(msgData), timestamp: Date.now() + i * 100 };
                    }
                    
                    chatMessages[replyingCharacterId].push(aiMessage);
    await saveChatMessages();
                    addMessageWithAnimation(aiMessage, replyingCharacterId);
                    
                    // 🔥【新增】触发角色状态更新
                    triggerStatusUpdateAfterMessage(replyingCharacterId);
                    
                    if (i < aiMessages.length - 1) {
                        const delay = Math.random() * 1000 + 500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        if (i < aiMessages.length - 1) {
                            showTypingIndicator();
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                            hideTypingIndicator();
                        }
                    }
                }
            } catch (error) {
                console.error('AI回复失败:', error);
                hideTypingIndicator();
                
                const errorMessage = {
                    id: Date.now().toString(),
                    sender: 'received',
                    content: `[回复失败: ${error.message}]`,
                    timestamp: Date.now()
                };
                
                chatMessages[replyingCharacterId].push(errorMessage);
                saveChatMessages();
                addMessageWithAnimation(errorMessage, replyingCharacterId);
            } finally {
                // 重置状态
                isWaitingForReply = false;
                pendingUserMessage = null;
                
                // 恢复智能回复按钮
                if (smartReplyBtn) {
                    smartReplyBtn.disabled = false;
                    smartReplyBtn.style.opacity = '';
                    smartReplyBtn.style.animation = 'none';
                    smartReplyBtn.classList.remove('waiting');
                    smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                    smartReplyBtn.title = '获取AI回复';
                }
                
                // 更新按钮显示状态
                updateFloatingButtonsVisibility();
            }
        }

        // 重置悬浮按钮状态
        function resetFloatingButtonsState() {
            // 重置待回复消息
            pendingUserMessage = null;
            isWaitingForReply = false;
            
            // 重置智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.disabled = false;
                smartReplyBtn.style.opacity = '';
                smartReplyBtn.style.animation = 'none';
                smartReplyBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
                smartReplyBtn.title = '获取AI回复';
                smartReplyBtn.classList.remove('waiting');
            }
            
            // 更新按钮显示状态
            updateFloatingButtonsVisibility();
        }

        // 更新悬浮按钮的显示状态
        function updateFloatingButtonsVisibility() {
            if (!currentChatCharacter) return;
            
            const regenerateBtn = document.getElementById('regenerate-btn');
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // 检查是否有AI消息可以重新生成
            const hasAIMessages = messages.some(msg => msg.sender === 'received');
            
            if (regenerateBtn) {
                if (hasAIMessages) {
                    regenerateBtn.classList.remove('hidden');
                } else {
                    regenerateBtn.classList.add('hidden');
                }
            }
            
            if (smartReplyBtn) {
                // 智能回复按钮总是显示
                smartReplyBtn.classList.remove('hidden');
            }
        }

        // 🔥【新增】@成员功能实现
        let mentionSelectedIndex = -1;
        let isShowingMentions = false;

        // 处理@输入
        function handleMentionInput(e) {
            const input = e.target;
            const value = input.value;
            const cursorPos = input.selectionStart;
            
            // 查找@符号的位置
            const beforeCursor = value.substring(0, cursorPos);
            const atIndex = beforeCursor.lastIndexOf('@');
            
            if (atIndex !== -1) {
                const query = beforeCursor.substring(atIndex + 1);
                // 如果@后面有空格，隐藏下拉框
                if (query.includes(' ') || query.includes('\n')) {
                    hideMentionDropdown();
                    return;
                }
                showMentionDropdown(query, atIndex);
            } else {
                hideMentionDropdown();
            }
        }

        // 处理键盘事件
        function handleMentionKeydown(e) {
            if (!isShowingMentions) return;
            
            const dropdown = document.getElementById('mention-dropdown');
            const items = dropdown.querySelectorAll('.mention-item');
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                mentionSelectedIndex = Math.min(mentionSelectedIndex + 1, items.length - 1);
                updateMentionSelection(items);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                mentionSelectedIndex = Math.max(mentionSelectedIndex - 1, -1);
                updateMentionSelection(items);
            } else if (e.key === 'Enter' && mentionSelectedIndex >= 0) {
                e.preventDefault();
                items[mentionSelectedIndex].click();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                hideMentionDropdown();
            }
        }

        // 显示@选择下拉框
        function showMentionDropdown(query, atIndex) {
            const dropdown = document.getElementById('mention-dropdown');
            if (!dropdown) return;
            
            // 获取群成员列表
            const members = getGroupMembers();
            if (!members || members.length === 0) {
                hideMentionDropdown();
                return;
            }
            
            // 过滤匹配的成员
            const filteredMembers = members.filter(member => 
                member.name.toLowerCase().includes(query.toLowerCase())
            );
            
            if (filteredMembers.length === 0) {
                hideMentionDropdown();
                return;
            }
            
            // 构建HTML
            dropdown.innerHTML = filteredMembers.map(member => `
                <div class="mention-item" data-id="${member.id}" data-name="${member.name}" data-at-index="${atIndex}">
                    <div class="mention-avatar" style="${member.avatar ? `background-image: url(${member.avatar})` : ''}">
                        ${!member.avatar ? member.name.charAt(0) : ''}
                    </div>
                    <span class="mention-name">${member.name}</span>
                </div>
            `).join('');
            
            // 添加点击事件
            dropdown.querySelectorAll('.mention-item').forEach((item, index) => {
                item.addEventListener('click', () => selectMention(item));
            });
            
            dropdown.style.display = 'block';
            isShowingMentions = true;
            mentionSelectedIndex = -1;
        }

        // 隐藏@选择下拉框
        function hideMentionDropdown() {
            const dropdown = document.getElementById('mention-dropdown');
            if (dropdown) {
                dropdown.style.display = 'none';
                dropdown.innerHTML = '';
            }
            isShowingMentions = false;
            mentionSelectedIndex = -1;
        }

        // 更新选择状态
        function updateMentionSelection(items) {
            items.forEach((item, index) => {
                item.classList.toggle('selected', index === mentionSelectedIndex);
            });
        }

        // 选择@成员
        function selectMention(item) {
            const input = document.getElementById('api-chat-input');
            const memberId = item.dataset.id;
            const memberName = item.dataset.name;
            const atIndex = parseInt(item.dataset.atIndex);
            
            const value = input.value;
            const cursorPos = input.selectionStart;
            const beforeAt = value.substring(0, atIndex);
            const afterCursor = value.substring(cursorPos);
            
            // 插入@成员标记
            const mentionText = `@${memberName} `;
            const newValue = beforeAt + mentionText + afterCursor;
            
            input.value = newValue;
            
            // 设置光标位置
            const newCursorPos = atIndex + mentionText.length;
            input.setSelectionRange(newCursorPos, newCursorPos);
            
            hideMentionDropdown();
            input.focus();
        }

        // 获取群成员列表
        function getGroupMembers() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) {
                return [];
            }
            
            if (!currentChatCharacter.members) {
                return [];
            }
            
            // 支持不同的数据结构
            return currentChatCharacter.members.map(member => {
                if (typeof member === 'string') {
                    // 如果是字符串ID，查找对应角色
                    const character = characters.find(char => char.id === member);
                    return character ? {
                        id: character.id,
                        name: character.name,
                        avatar: character.avatar
                    } : null;
                } else if (member && member.id) {
                    // 如果是对象
                    return {
                        id: member.id,
                        name: member.name || member.id,
                        avatar: member.avatar
                    };
                }
                return null;
            }).filter(Boolean);
        }

        // 修改消息渲染函数，支持@样式
        function renderMentionText(text) {
            if (!text) return text;
            
            // 将@提及转换为带样式的HTML
            return text.replace(/@([^\s@]+)/g, '<span class="mention-text">@$1</span>');
        }

        // 修改原来的sendApiMessage函数，使其只发送消息到界面，不触发AI回复
        async function sendApiMessage() {
            const input = document.getElementById('api-chat-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            // 🔥【新增】检查是否被拉黑，阻止发送消息
            if (isBlocked(currentChatCharacter.id, 'user')) {
                showToast('你被对方拉黑了，无法发送消息', 'warning');
                return;
            }

            // 防止重复发送
            if (input._isProcessing) return;
            input._isProcessing = true;

            try {
            // 添加用户消息
            const messageId = Date.now().toString();
            const userMessage = {
                id: messageId,
                sender: 'sent',
                content: message,
                timestamp: Date.now(),
                // 如果有引用消息，添加引用信息
                replyTo: currentReplyTo ? {
                    id: currentReplyTo.id,
                    content: currentReplyTo.content,
                    senderName: currentReplyTo.senderName
                } : null
            };
            
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            chatMessages[currentChatCharacter.id].push(userMessage);
            saveChatMessages();
            
            // 清空输入框
            input.value = '';
            
            // 清除引用状态
            cancelReply();
            
            // 🔥【新增】调整心率（用户发消息）
            adjustHeartrateForMessage(message, true);
            
            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(userMessage, currentChatCharacter.id);
            
            // 设置待回复消息
            pendingUserMessage = userMessage;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
                }
            } finally {
                // 确保处理完成后重置标志
                setTimeout(() => {
                    input._isProcessing = false;
                }, 100);
            }
        }

        // 语音录音相关变量
        let isRecording = false;
        let recordingStartTime = 0;

        // 处理语音录音
        async function handleVoiceRecording() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }

            // 🔥【修复】移除对不存在按钮的依赖，直接显示语音输入对话框
                try {
                    const voiceText = await showVoiceInputDialog();
                    if (voiceText && voiceText.trim()) {
                        sendVoiceMessage(voiceText.trim());
                        console.log('语音消息发送成功');
                    }
                } catch (error) {
                    // 只有在真正取消时才显示取消消息
                    if (error.message === '用户取消') {
                        console.log('用户取消了语音输入');
                    } else {
                        console.error('语音消息发送失败:', error);
                    }
            }
        }

        // 重置录音状态 - 🔥【修复】移除对不存在按钮的依赖
        function resetRecordingState() {
            isRecording = false;
            // 不再需要操作按钮状态，因为我们使用的是工具面板中的语音按钮
        }

        // 显示语音输入对话框
        function showVoiceInputDialog() {
            return new Promise((resolve, reject) => {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    padding: 20px;
                    width: 280px;
                    max-width: 90%;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                `;

                dialog.innerHTML = `
                    <div style="text-align: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; color: #333;">语音转文字</h3>
                        <p style="margin: 8px 0 0 0; color: #666; font-size: 14px;">请输入您想说的内容：</p>
                    </div>
                    <textarea id="voice-text-input" placeholder="在这里输入语音内容..." style="
                        width: 100%;
                        height: 80px;
                        border: 1px solid #ddd;
                        border-radius: 8px;
                        padding: 10px;
                        font-size: 14px;
                        resize: none;
                        box-sizing: border-box;
                        outline: none;
                    "></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button id="voice-cancel-btn" style="
                            flex: 1;
                            padding: 10px;
                            border: 1px solid #ddd;
                            background: white;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                        ">取消</button>
                        <button id="voice-send-btn" style="
                            flex: 1;
                            padding: 10px;
                            border: none;
                            background: #4a84c1;
                            color: white;
                            border-radius: 8px;
                            cursor: pointer;
                            font-size: 14px;
                        ">发送</button>
                    </div>
                `;

                overlay.appendChild(dialog);
                document.body.appendChild(overlay);

                const textInput = dialog.querySelector('#voice-text-input');
                const cancelBtn = dialog.querySelector('#voice-cancel-btn');
                const sendBtn = dialog.querySelector('#voice-send-btn');

                // 自动聚焦到输入框
                setTimeout(() => textInput.focus(), 100);

                // 取消按钮
                cancelBtn.onclick = () => {
                    document.body.removeChild(overlay);
                    reject(new Error('用户取消'));
                };

                // 发送按钮
                sendBtn.onclick = () => {
                    const text = textInput.value.trim();
                    if (text) {
                        console.log('语音输入对话框：用户点击发送，内容:', text);
                        document.body.removeChild(overlay);
                        resolve(text);
                    } else {
                        console.log('语音输入对话框：内容为空，聚焦输入框');
                        textInput.focus();
                    }
                };

                // 点击遮罩关闭
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                        reject(new Error('用户取消'));
                    }
                };

                // 支持回车发送
                textInput.onkeydown = (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        console.log('语音输入框：用户按回车键发送');
                        sendBtn.click();
                    }
                };
            });
        }

                 // 发送语音消息
        function sendVoiceMessage(text) {
            console.log('开始发送语音消息:', text);
            
            // 🔥【新增】检查是否被拉黑，阻止发送消息
            if (currentChatCharacter && isBlocked(currentChatCharacter.id, 'user')) {
                showToast('你被对方拉黑了，无法发送消息', 'warning');
                return;
            }
            
            const messageId = Date.now().toString();
            const duration = Math.max(1, Math.ceil(text.length / 8)); // 根据文字长度计算"语音"时长
            
            const voiceMessage = {
                id: messageId,
                sender: 'sent',
                type: 'voice',
                content: text,
                duration: duration,
                timestamp: Date.now()
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }

            chatMessages[currentChatCharacter.id].push(voiceMessage);
            console.log('语音消息已添加到聊天记录');
            
            saveChatMessages();
            console.log('聊天记录已保存');

            // 🔥【新增】调整心率（用户发语音消息）
            adjustHeartrateForMessage(text, true);

            // 添加语音消息到界面
            addMessageWithAnimation(voiceMessage, currentChatCharacter.id);
            console.log('语音消息已添加到界面');
            
            // 🔥【新增】触发角色状态更新
            triggerStatusUpdateAfterMessage(currentChatCharacter.id);

            // 设置待回复消息
            pendingUserMessage = voiceMessage;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
            
            console.log('语音消息发送流程完成');
        }

        // 切换语音文本显示
        function toggleVoiceText(voiceElement) {
            const container = voiceElement.closest('.voice-message-container') || voiceElement.closest('.message-container');
            if (!container) return;

            const textContent = container.querySelector('.voice-text-content');
            if (!textContent) {
                // 如果没有文本容器，创建一个
                const text = voiceElement.getAttribute('data-text');
                if (!text) return;

                const newTextContent = document.createElement('div');
                newTextContent.className = 'voice-text-content';
                newTextContent.textContent = text;
                
                // 根据消息类型决定插入位置
                if (container.classList.contains('voice-message-container')) {
                    container.appendChild(newTextContent);
                } else {
                    // 为旧格式创建语音容器
                    const voiceContainer = document.createElement('div');
                    voiceContainer.className = container.classList.contains('sent') ? 'voice-message-container sent' : 'voice-message-container received';
                    
                    // 移动现有的消息气泡到语音容器中
                    const bubble = container.querySelector('.message-bubble');
                    if (bubble) {
                        container.removeChild(bubble);
                        voiceContainer.appendChild(bubble);
                        voiceContainer.appendChild(newTextContent);
                        container.appendChild(voiceContainer);
                    }
                }
                
                // 显示文本
                setTimeout(() => {
                    newTextContent.classList.add('visible');
                }, 10);
                
                return;
            }

            // 切换文本显示/隐藏
            if (textContent.classList.contains('visible')) {
                textContent.classList.remove('visible');
                setTimeout(() => {
                    textContent.style.display = 'none';
                }, 300);
            } else {
                textContent.style.display = 'block';
                setTimeout(() => {
                    textContent.classList.add('visible');
                }, 10);
            }
        }
        
        // 加载动态
        async function loadMoments() {
            try {
                    const momentsList = document.getElementById('moments-list');
                if (!momentsList) return;
                    
                        // 清空现有的动态
                        momentsList.innerHTML = '';
                        
                // 从数据库加载动态数据
                const momentsData = await db.moments.orderBy('timestamp').reverse().toArray();
                
                if (momentsData.length > 0) {
                    for (const momentData of momentsData) {
                        // 获取点赞数
                        const likesCount = await db.momentLikes.where('momentId').equals(momentData.id).count();
                        
                        // 获取评论数
                        const commentsCount = await db.momentComments.where('momentId').equals(momentData.id).count();
                        
                        // 获取评论列表
                        const comments = await db.momentComments.where('momentId').equals(momentData.id).toArray();
                        comments.sort((a, b) => a.timestamp - b.timestamp); // 按时间戳排序
                        
                            // 🔥【修复】验证并处理头像
                            let avatarToUse = null;
                            if (momentData.avatar && isValidAvatarUrl(momentData.avatar)) {
                                avatarToUse = momentData.avatar;
                            } else {
                                // 🔥【修复】使用await获取默认头像
                                avatarToUse = await getDefaultAvatar();
                                // 如果数据库中存储的头像无效，更新数据库记录
                                if (momentData.avatar && !isValidAvatarUrl(momentData.avatar)) {
                                    console.log(`清理动态 ${momentData.id} 的无效头像`);
                                    try {
                                        await db.moments.update(momentData.id, { avatar: avatarToUse });
                                    } catch (error) {
                                        console.error('更新动态头像失败:', error);
                                    }
                                }
                            }
                        
                            const momentElement = createMomentElement({
                            id: momentData.id,
                                nickname: momentData.nickname,
                                avatar: avatarToUse,
                                text: momentData.text,
                                images: momentData.images || [],
                                time: momentData.time,
                            timestamp: momentData.timestamp,
                            likes: likesCount,
                            comments: comments
                            });
                            
                            // 添加到动态列表
                            momentsList.appendChild(momentElement);
                            
                            // 更新点赞显示
                        updateMomentLikeDisplay(momentData.id);
                            
                            // 显示已有评论
                        if (comments && comments.length > 0) {
                            comments.forEach(comment => {
                                // 确保评论有time字段，如果没有就从timestamp生成
                                if (!comment.time && comment.timestamp) {
                                    comment.time = formatTime(new Date(comment.timestamp));
                                }
                                displayCommentUnderMoment(momentData.id, comment);
                                });
                            }
                    }
                        
                        console.log('成功加载', momentsData.length, '条动态');
                } else {
                    console.log('没有找到保存的动态数据');
                }
                
                // 启动时间更新
                startTimeUpdater();
            } catch (error) {
                console.error('加载动态失败:', error);
            }
        }
        
        // 发布动态相关变量
        let momentImages = [];
        
        // 显示发布动态界面
        function showPublishMoment() {
            showApp('publish-moment-screen');
            // 重置表单
            document.getElementById('moment-text').value = '';
            momentImages = [];
            updateMomentImagesGrid();
            
            // 重置发布按钮状态
            const publishBtn = document.querySelector('.publish-btn');
            if (publishBtn) {
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';
            }
        }
        
        // 隐藏发布动态界面
        function hidePublishMoment() {
            showApp('chat-screen');
                                    // 切换回动态标签
            switchChatTab('moments-page');
            // 不需要重新加载，动态已经在数据库中
        }
        
        // 添加图片到动态
        function addMomentImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.multiple = true;
            input.onchange = function(event) {
                const files = Array.from(event.target.files);
                files.forEach(file => {
                    if (momentImages.length < 9) { // 最多9张图片
                        const reader = new FileReader();
                        reader.onload = async function(e) {
                            try {
                                // 压缩图片
                                const compressedImage = await compressImage(e.target.result, 800, 0.8);
                                momentImages.push(compressedImage);
                                updateMomentImagesGrid();
                            } catch (error) {
                                showToast("图片处理失败，请重试");                                console.error("压缩图片失败:", error);
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            };
            input.click();
        }
        
        // 删除图片
        function removeMomentImage(index) {
            momentImages.splice(index, 1);
            updateMomentImagesGrid();
        }
        
        // 更新图片网格显示
        function updateMomentImagesGrid() {
            const grid = document.getElementById('moment-images-grid');
            grid.innerHTML = '';
            
            momentImages.forEach((imageData, index) => {
                const imageItem = document.createElement('div');
                imageItem.className = 'moment-image-item';
                imageItem.innerHTML = `
                    <img src="${imageData}" alt="动态图片">
                    <button class="remove-image-btn" onclick="removeMomentImage(${index})">×</button>
                `;
                grid.appendChild(imageItem);
            });
        }
        
        // 发布动态
        
        // 获取默认头像 - 修复异步问题
        async function getDefaultAvatar() {
            try {
                // 🔥【修复】使用await获取动态头像，确保异步操作正确完成
                const momentsAvatar = await getMomentsImage("avatarImage");
                if (momentsAvatar && isValidAvatarUrl(momentsAvatar)) {
                    console.log('使用动态页面设置的头像');
                    return momentsAvatar;
                }
                
                // 尝试获取用户头像，但要验证其有效性
                if (window.userAvatar && isValidAvatarUrl(window.userAvatar)) {
                    console.log('使用全局用户头像');
                    return window.userAvatar;
                }
                
                // 清理无效的用户头像数据
                if (window.userAvatar && !isValidAvatarUrl(window.userAvatar)) {
                    console.log('清理无效的用户头像数据');
                    window.userAvatar = null;
                }
                
                // 清理无效的动态头像数据
                if (momentsAvatar && !isValidAvatarUrl(momentsAvatar)) {
                    console.log('清理无效的动态头像数据');
                    // 这里需要调用清理函数，但由于getMomentsImage的存储机制，我们先跳过
                }
                
                console.log('使用默认生成的头像');
                // 返回默认头像（使用CSS生成的简单头像）
                return "data:image/svg+xml;base64," + btoa(`<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg"><rect width="50" height="50" fill="#f0f0f0"/><circle cx="25" cy="20" r="8" fill="#999"/><circle cx="25" cy="40" r="12" fill="#999"/></svg>`);
            } catch (error) {
                console.error('获取默认头像失败:', error);
                return "data:image/svg+xml;base64," + btoa(`<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg"><rect width="50" height="50" fill="#f0f0f0"/><circle cx="25" cy="20" r="8" fill="#999"/><circle cx="25" cy="40" r="12" fill="#999"/></svg>`);
            }
        }        async function publishMoment() {
            const text = document.getElementById('moment-text').value.trim();
            const publishBtn = document.querySelector('.publish-btn');
            
            if (!text && momentImages.length === 0) {
                showToast('请输入文字或选择图片');
                return;
            }
            
            // 禁用发布按钮，防止重复提交
            publishBtn.disabled = true;
            publishBtn.textContent = '发布中...';
            
            // 获取当前用户昵称
            const nickname = document.getElementById('moments-username')?.textContent || '我';
            
            // 🔥【修复】使用await获取用户头像
            const userAvatar = await getDefaultAvatar();
            
            // 创建新动态
            const now = new Date();
            const newMoment = {
                id: Date.now(),
                authorId: 'user',
                nickname: nickname,
                avatar: userAvatar,
                text: text,
                images: [...momentImages],
                time: formatTime(now),
                timestamp: now.getTime()
            };
            
            try {
                // 保存到数据库
                await db.moments.add(newMoment);
                
                // 恢复发布按钮状态
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';
                
                // 显示成功提示
                showToast('发布成功！');
                
                // 清空表单
                document.getElementById('moment-text').value = '';
                momentImages = [];
                updateMomentImagesGrid();
                
                // 返回动态页面
                    hidePublishMoment();
                
                // 直接添加到动态列表（避免重新加载整个列表）
                addMomentToList(newMoment);
                
                // 启动时间更新器
                startTimeUpdater();
                
                // 延迟触发AI角色的互动
                setTimeout(() => {
                    triggerAIInteractions(newMoment.id, 'like');
                }, 1000);
                setTimeout(() => {
                    triggerAIInteractions(newMoment.id, 'comment');
                }, 3000);
                
            } catch (error) {
                console.error('发布动态失败:', error);
                showToast('发布失败，请重试');
                
                // 恢复发布按钮
                publishBtn.disabled = false;
                publishBtn.textContent = '发表';
            }
        }
        
        // 格式化时间
        function formatTime(date) {
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) { // 小于1分钟
                return '刚刚';
            } else if (diff < 3600000) { // 小于1小时
                return Math.floor(diff / 60000) + '分钟前';
            } else if (diff < 86400000) { // 小于1天
                return Math.floor(diff / 3600000) + '小时前';
            } else if (diff < 604800000) { // 小于1周
                return Math.floor(diff / 86400000) + '天前';
            } else {
                return date.toLocaleDateString();
            }
        }
        
        // 添加动态到列表
        function addMomentToList(moment) {
            const momentsList = document.getElementById('moments-list');
            const momentElement = createMomentElement(moment);
            
            // 插入到列表最前面
            if (momentsList.firstChild) {
                momentsList.insertBefore(momentElement, momentsList.firstChild);
            } else {
                momentsList.appendChild(momentElement);
            }
        }
        
        // 创建动态元素
        function createMomentElement(moment) {
            const momentDiv = document.createElement('div');
            momentDiv.className = 'moment-item';
            
            // 设置动态ID和时间戳
            momentDiv.setAttribute('data-moment-id', moment.id);
            if (moment.timestamp) {
                momentDiv.setAttribute('data-timestamp', moment.timestamp);
            }
            
            let imagesHtml = '';
            if (moment.images && moment.images.length > 0) {
                imagesHtml = `
                    <div class="moment-images">
                        ${moment.images.map(img => `<img src="${img}" alt="动态图片" onclick="previewImage('${img}')">`).join('')}
                    </div>
                `;
            }
            // 🔥【修复】正确获取角色头像
            let finalAvatar = null;
            if (moment.authorId === 'user') {
                // 用户动态：直接使用保存的头像（已在发布时正确设置）
                finalAvatar = moment.avatar;
            } else {
                // 角色动态：优先动态头像，然后角色卡头像
                finalAvatar = moment.avatar;
                if (!finalAvatar && moment.characterId) {
                    const character = characters.find(c => c.id === moment.characterId);
                    if (character && character.avatarUrl) {
                        finalAvatar = character.avatarUrl;
                    }
                }
            }
            
            momentDiv.innerHTML = `
                <div class="moment-avatar">
                    ${finalAvatar ? 
                        `<img src="${finalAvatar}" alt="头像" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'width: 40px; height: 40px; background-color: #ddd; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 14px;\\'>${moment.nickname ? moment.nickname.charAt(0) : '?'}</div>'">` :
                        `<div style="width: 40px; height: 40px; background-color: #ddd; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: #666; font-size: 14px;">${moment.nickname ? moment.nickname.charAt(0) : '?'}</div>`
                    }
                </div>
                <div class="moment-content">
                    <div class="moment-username">${moment.nickname}</div>
                    <div class="moment-text">${formatMomentText(moment.text)}</div>
                    ${imagesHtml}
                    <div class="moment-time-actions" style="margin-top: 8px; padding: 8px 0; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;">
                        <div class="moment-time">${moment.time}</div>
                        <div class="moment-actions" style="display: flex;">
                        <button class="moment-action-btn" onclick="toggleMomentLike('${moment.id}')" style="margin-right: 8px;">
                            <i class="far fa-heart"></i>
                            <span>${moment.likes || 0}</span>
                        </button>
                        <button class="moment-action-btn" onclick="showMomentComments('${moment.id}')">
                            <i class="far fa-comment"></i>
                            <span>${moment.comments ? moment.comments.length : 0}</span>
                        </button>
                    </div>
                    </div>
                    <div class="moment-footer" style="display: none;">
                    </div>
                </div>
            `;
            
            // 添加长按监听器
            addLongPressListener(momentDiv, moment.id);
            
            // 异步检查并设置用户点赞状态
            (async () => {
                try {
                    const userLike = await db.momentLikes
                        .where('[momentId+authorId]')
                        .equals([moment.id, 'user'])
                        .first();
                    
                    if (userLike) {
                    const likeBtn = momentDiv.querySelector('.moment-action-btn');
                    const likeIcon = likeBtn.querySelector('i');
                    likeIcon.classList.remove('far');
                    likeIcon.classList.add('fas');
                    likeBtn.classList.add('liked');
                }
                } catch (error) {
                    console.error('检查用户点赞状态失败:', error);
            }
            })();
            
            return momentDiv;
        }
        
        // 预览图片
        function previewImage(imageSrc) {
            // 创建预览遮罩
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            `;
            
            const img = document.createElement('img');
            img.src = imageSrc;
            img.style.cssText = `
                max-width: 90%;
                max-height: 90%;
                object-fit: contain;
            `;
            
            overlay.appendChild(img);
            overlay.onclick = () => document.body.removeChild(overlay);
            document.body.appendChild(overlay);
        }
        
        // 注意：saveMomentsData函数已移除，现在使用Dexie数据库直接存储
        // 更新文字计数
        function updateTextCount() {
            const textarea = document.getElementById('moment-text');
            const countElement = document.getElementById('text-count');
            
            if (textarea && countElement) {
                const currentLength = textarea.value.length;
                const maxLength = 500;
                
                countElement.textContent = `${currentLength}/${maxLength}`;
                
                // 当接近限制时改变颜色
                if (currentLength > maxLength * 0.9) {
                    countElement.style.color = '#ff6b6b';
                } else if (currentLength > maxLength * 0.8) {
                    countElement.style.color = '#ffa500';
                } else {
                    countElement.style.color = '#999';
                }
            }
        }
        
        // 显示提示消息
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                z-index: 10000;
                font-size: 14px;
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            setTimeout(() => {
                document.body.removeChild(toast);
            }, 2000);
        }
        
        // 时间更新器
        let timeUpdateInterval = null;
        
        function startTimeUpdater() {
            // 清除已存在的定时器
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }
            
            // 立即更新一次
            updateMomentTimes();
            
            // 每分钟更新一次时间显示
            timeUpdateInterval = setInterval(updateMomentTimes, 60000);
        }
        
        function stopTimeUpdater() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }
        
        function updateMomentTimes() {
            try {
                const momentItems = document.querySelectorAll('.moment-item[data-timestamp]');
                
                momentItems.forEach(item => {
                    const timestamp = parseInt(item.getAttribute('data-timestamp'));
                    if (timestamp) {
                        const timeElement = item.querySelector('.moment-time');
                        if (timeElement) {
                            const newTime = formatTime(new Date(timestamp));
                            timeElement.textContent = newTime;
                        }
                    }
                });
            } catch (error) {
                console.error('更新动态时间失败:', error);
            }
        }
        
        // 动态选择模式相关变量
        let isSelectionMode = false;
        let selectedMoments = new Set();
        
        // 切换动态点赞状态
        async function toggleMomentLike(momentId) {
            if (isSelectionMode) return; // 选择模式下不响应点赞
            
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            const likeBtn = momentElement.querySelector('.moment-action-btn');
            const likeIcon = likeBtn.querySelector('i');
            
            try {
            // 检查用户是否已点赞
                const existingLike = await db.momentLikes
                    .where('[momentId+authorId]')
                    .equals([parseInt(momentId), 'user'])
                    .first();
            
                if (existingLike) {
                // 取消点赞
                likeIcon.classList.remove('fas');
                likeIcon.classList.add('far');
                likeBtn.classList.remove('liked');
                    await db.momentLikes.delete([parseInt(momentId), 'user']);
            } else {
                // 点赞
                likeIcon.classList.add('fas');
                likeIcon.classList.remove('far');
                likeBtn.classList.add('liked');
                    await db.momentLikes.add({
                        momentId: parseInt(momentId),
                        authorId: 'user',
                    characterId: 'user',
                    name: document.getElementById('moments-username')?.textContent || '我',
                    timestamp: Date.now()
                });
                
                // 触发AI角色自动点赞
                triggerAIInteractions(momentId, 'like');
            }
            
            // 更新显示
            updateMomentLikeDisplay(momentId);
            } catch (error) {
                console.error('点赞操作失败:', error);
            }
        }
        
        // 显示动态评论
        function showMomentComments(momentId) {
            if (isSelectionMode) return; // 选择模式下不响应评论
            
            // 显示简单评论输入框
            showSimpleCommentInput(momentId);
            
            // 触发AI角色自动评论
            triggerAIInteractions(momentId, 'comment');
        }
        
        // 显示简单评论输入框
        function showSimpleCommentInput(momentId, replyToNickname = null) {
            // 检查是否已经有输入框
            if (document.querySelector('.simple-comment-input')) {
                closeSimpleCommentInput();
            }
            
            const placeholder = replyToNickname ? `回复 ${replyToNickname}...` : '写评论...';
            
            const input = document.createElement('div');
            input.className = 'simple-comment-input';
            input.innerHTML = `
                <div class="comment-input-container">
                    <input type="text" placeholder="${placeholder}" maxlength="200" id="simple-comment-${momentId}" data-reply-to="${replyToNickname || ''}">
                    <button onclick="submitSimpleComment('${momentId}')">发送</button>
                    <button onclick="closeSimpleCommentInput()" class="cancel-btn">取消</button>
                </div>
            `;
            
            input.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: white;
                border-top: 1px solid #ddd;
                padding: 12px;
                z-index: 1000;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
                max-width: 360px;
                margin: 0 auto;
            `;
            
            const container = input.querySelector('.comment-input-container');
            container.style.cssText = `
                display: flex;
                gap: 8px;
                align-items: center;
                max-width: 360px;
                margin: 0 auto;
            `;
            
            const textInput = input.querySelector('input');
            textInput.style.cssText = `
                flex: 1;
                padding: 8px 12px;
                border: 1px solid #ddd;
                border-radius: 20px;
                font-size: 14px;
            `;
            
            const sendBtn = input.querySelector('button');
            sendBtn.style.cssText = `
                background: #1da1f2;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 16px;
                font-size: 14px;
                cursor: pointer;
            `;
            
            const cancelBtn = input.querySelector('.cancel-btn');
            cancelBtn.style.cssText = `
                background: #f0f0f0;
                color: #666;
                border: none;
                padding: 8px 16px;
                border-radius: 16px;
                font-size: 14px;
                cursor: pointer;
            `;
            
            document.body.appendChild(input);
            
            // 自动聚焦
            setTimeout(() => textInput.focus(), 100);
            
            // 回车发送
            textInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitSimpleComment(momentId);
                }
            });
        }
        
        // 关闭简单评论输入框
        function closeSimpleCommentInput() {
            const input = document.querySelector('.simple-comment-input');
            if (input) {
                document.body.removeChild(input);
            }
        }
        
        // 提交简单评论
        async function submitSimpleComment(momentId) {
            const input = document.getElementById(`simple-comment-${momentId}`);
            const text = input.value.trim();
            const replyTo = input.getAttribute('data-reply-to');
            
            if (!text) {
                showToast('请输入评论内容');
                return;
            }
            
            // 🔥【修复】使用await获取用户头像
            const userAvatar = await getDefaultAvatar();
            
            const comment = {
                id: Date.now() + Math.random(),
                nickname: document.getElementById('moments-username')?.textContent || '我',
                avatar: userAvatar,
                text: text,
                time: formatTime(new Date()),
                timestamp: Date.now(),
                replyTo: replyTo || null
            };
            
            // 保存评论到动态数据
            saveCommentToMoment(momentId, comment);
            
            // 更新动态列表中的评论数
            updateMomentCommentCount(momentId);
            
            // 在动态下方显示新评论
            displayCommentUnderMoment(momentId, comment);
            
            // 关闭输入框
            closeSimpleCommentInput();
            
            showToast('评论成功！');
            
            // 如果用户回复了某个AI角色，检查轮次并触发该角色的回复
            if (replyTo && replyTo !== '我') {
                const conversationKey = `${momentId}-${replyTo}`;
                const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                
                if (currentRounds < 10) {
                    console.log(`用户回复了 ${replyTo}，当前对话轮次: ${currentRounds}/10，将在2-5秒后触发AI回复`);
                    
                    // 用户回复时也要增加轮次
                    commentConversationRounds.set(conversationKey, currentRounds + 1);
                    console.log(`用户回复后，${replyTo} 在动态 ${momentId} 中的对话轮次更新为: ${currentRounds + 1}/10`);
                    
                setTimeout(() => {
                    console.log(`开始触发 ${replyTo} 回复用户评论: "${text}"`);
                    triggerAIReplyToUser(momentId, replyTo, text);
                }, Math.random() * 3000 + 2000); // 2-5秒后AI回复
                } else {
                    console.log(`${replyTo} 在动态 ${momentId} 中的对话已达到10轮上限，不再回复`);
                }
            } else {
                console.log(`用户发表了评论，replyTo: ${replyTo}`);
                
                // 检查是否是对角色动态的直接评论（不是回复）
                if (!replyTo) {
                    checkAndTriggerCharacterMomentReply(momentId, text);
                }
            }
        }
        
        // 检查并触发角色动态的回复
        async function checkAndTriggerCharacterMomentReply(momentId, userCommentText) {
            try {
                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment || !moment.characterId || moment.characterId === 'user') {
                    console.log('不是角色发布的动态，跳过角色回复');
                    return;
                }
                
                // 获取发布动态的角色
                const character = characters.find(c => c.id === moment.characterId);
                if (!character) {
                    console.log(`未找到动态发布者角色: ${moment.characterId}`);
                    return;
                }
                
                // 检查对话轮次
                const conversationKey = `${momentId}-${character.name}`;
                const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                
                if (currentRounds >= 10) {
                    console.log(`${character.name} 在动态 ${momentId} 中的对话已达到10轮上限，不再回复`);
                    return;
                }
                
                console.log(`用户评论了 ${character.name} 的动态，当前对话轮次: ${currentRounds}/10，将在2-5秒后触发回复`);
                
                // 增加对话轮次
                commentConversationRounds.set(conversationKey, currentRounds + 1);
                console.log(`用户评论后，${character.name} 在动态 ${momentId} 中的对话轮次更新为: ${currentRounds + 1}/10`);
                
                // 延迟回复
                setTimeout(() => {
                    console.log(`开始触发 ${character.name} 回复用户对其动态的评论: "${userCommentText}"`);
                    triggerAIReplyToUser(momentId, character.name, userCommentText);
                }, Math.random() * 3000 + 2000); // 2-5秒后AI回复
                
            } catch (error) {
                console.error('检查角色动态回复失败:', error);
            }
        }
        
        // 在动态下方显示评论
        function displayCommentUnderMoment(momentId, comment) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            // 查找或创建评论区域
            let commentsSection = momentElement.querySelector('.moment-comments-section');
            if (!commentsSection) {
                commentsSection = document.createElement('div');
                commentsSection.className = 'moment-comments-section';
                
                // 检查是否已有点赞区域，决定margin-top
                const likesDisplay = momentElement.querySelector('.likes-display');
                const marginTop = likesDisplay ? '0' : '0';
                
                commentsSection.style.cssText = `
                    margin-top: ${marginTop};
                    padding: 8px 12px;
                    background: #f8f9fa;
                    font-size: 13px;
                `;
                
                // 插入到正确位置：点赞区后面（如果有的话），否则在时间操作区后面
                const momentContent = momentElement.querySelector('.moment-content');
                const momentTimeActions = momentElement.querySelector('.moment-time-actions');
                
                if (momentContent && momentTimeActions) {
                if (likesDisplay) {
                        // 如果有点赞区，插入到点赞区后面
                    likesDisplay.parentNode.insertBefore(commentsSection, likesDisplay.nextSibling);
                    } else {
                        // 没有点赞区，插入到时间操作区后面
                    momentTimeActions.parentNode.insertBefore(commentsSection, momentTimeActions.nextSibling);
                    }
                }
            }
            
            // 创建评论元素
            const commentDiv = document.createElement('div');
            commentDiv.className = 'comment-item';
            commentDiv.style.cssText = `
                display: flex;
                gap: 8px;
                margin-bottom: 8px;
                align-items: flex-start;
            `;
            
            // 处理回复格式
            let commentText = comment.text;
            if (comment.replyTo) {
                commentText = `回复<span style="margin: 0 2px; color: #576b95; font-weight: 600;">${comment.replyTo}</span>: ${comment.text}`;
            }
            
            commentDiv.innerHTML = `
                <img src="${comment.avatar}" style="width: 24px; height: 24px; border-radius: 50%; object-fit: cover;">
                <div style="flex: 1; line-height: 1.4; cursor: pointer;" onclick="replyToMomentComment('${momentId}', '${comment.nickname}')">
                    <span style="color: #576b95; font-weight: 600;">${comment.nickname}${comment.replyTo ? '' : '：'}</span><span style="margin-left: 2px; color: #333;">${commentText}</span>
                    <div style="color: #999; font-size: 11px; margin-top: 2px;">${comment.time}</div>
                </div>
            `;
            
            commentsSection.appendChild(commentDiv);
        }
        
        // 回复动态评论
        function replyToMomentComment(momentId, nickname) {
            // 显示评论输入框，并设置为回复模式
            showSimpleCommentInput(momentId, nickname);
        }
        

        
        // 保存评论到动态数据
        async function saveCommentToMoment(momentId, comment) {
            try {
                const commentData = {
                    id: comment.id,
                    momentId: parseInt(momentId),
                    authorId: comment.characterId || 'user',
                    nickname: comment.nickname,
                    avatar: comment.avatar,
                    text: comment.text,
                    timestamp: comment.timestamp,
                    replyTo: comment.replyTo || null
                };
                
                await db.momentComments.add(commentData);
                console.log('评论已保存到数据库，动态ID:', momentId);
            } catch (error) {
                console.error('保存评论失败:', error);
            }
        }
        
        // 更新动态评论数
        async function updateMomentCommentCount(momentId) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
                const commentsCount = await db.momentComments.where('momentId').equals(parseInt(momentId)).count();
            
                const commentBtn = momentElement.querySelectorAll('.moment-action-btn')[1];
                const commentCount = commentBtn.querySelector('span');
                commentCount.textContent = commentsCount;
            } catch (error) {
                console.error('更新评论数失败:', error);
            }
        }
        
        // 触发AI角色互动
        async function triggerAIInteractions(momentId, type) {
            try {
            if (!characters || characters.length === 0) return;
            
            // 获取当前动态信息
                const moment = await db.moments.get(parseInt(momentId));
            if (!moment) return;
            
                const publisherCharacterId = moment.characterId;
                
                // 如果是用户发的动态
                if (!publisherCharacterId || publisherCharacterId === 'user') {
                    console.log('用户发布动态，所有角色80%概率互动');
                    // 用户发动态：所有联系人角色都有80%概率互动
            const contactCharacters = characters.filter(char => contacts.includes(char.id));
            
            if (type === 'like') {
                for (const character of contactCharacters) {
                    if (Math.random() < 0.8) {
                                setTimeout(() => {
                                    addAILike(momentId, character, moment);
                                }, Math.random() * 3000 + 1000);
                    }
                }
            } else if (type === 'comment') {
                for (const character of contactCharacters) {
                    if (Math.random() < 0.8) {
                            setTimeout(async () => {
                                await addAIComment(momentId, character, moment);
                                }, Math.random() * 5000 + 2000);
                    }
                }
                    }
                } else {
                    console.log('角色发布动态，同一分组下角色60%概率互动');
                    // 角色发动态：使用分组关系而不是群聊关系
                    const publisherCharacter = characters.find(c => c.id === publisherCharacterId);
                    
                    // 获取与发布者在同一分组的角色
                    const sameGroupCharacters = characters.filter(c => 
                        c.id !== publisherCharacterId && c.groupId === publisherCharacter.groupId
                    );
                
                    if (type === 'like') {
                        for (const character of sameGroupCharacters) {
                            if (Math.random() < 0.4) { // 40%概率互动，保持原有的设置概率
                    setTimeout(() => {
                                    addAILike(momentId, character, moment);
                                }, Math.random() * 3000 + 1000);
                            }
                        }
                    } else if (type === 'comment') {
                        for (const character of sameGroupCharacters) {
                            if (Math.random() < 0.4) { // 40%概率互动，保持原有的设置概率
                                setTimeout(async () => {
                                    await addAIComment(momentId, character, moment);
                                }, Math.random() * 5000 + 2000);
                            }
                        }
                        
                        // 触发同分组角色间的40%概率互动  
                        setTimeout(() => {
                            // 将发布者角色也加入到互动角色列表中
                            const allInteractionCharacters = [...sameGroupCharacters];
                            if (publisherCharacter) {
                                allInteractionCharacters.push(publisherCharacter);
                            }
                            triggerAiToAiInteraction(momentId, allInteractionCharacters);
                        }, Math.random() * 8000 + 5000);
                    }
                }
            } catch (error) {
                console.error('触发AI互动失败:', error);
            }
        }
        
        // 获取与指定角色在同一个群聊的其他角色
        function getCharactersInSameGroups(characterId) {
            const sameGroupCharacters = [];
            
            // 遍历所有群聊
            groupChats.forEach(group => {
                if (group.members && group.members.includes(characterId)) {
                    // 找到包含该角色的群聊，获取群内其他角色
                    group.members.forEach(memberId => {
                        if (memberId !== characterId && memberId !== 'user') {
                            const character = characters.find(c => c.id === memberId);
                            if (character && !sameGroupCharacters.find(c => c.id === character.id)) {
                                sameGroupCharacters.push(character);
                            }
                        }
                    });
                }
            });
            
            return sameGroupCharacters;
        }
        
        // AI角色点赞
        async function addAILike(momentId, character, moment) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            // 检查是否已经点赞过
                const existingLike = await db.momentLikes
                    .where('[momentId+authorId]')
                    .equals([parseInt(momentId), character.id])
                    .first();
                
                if (existingLike) return;
            
                // 基于角色人设决定是否真的点赞
                const shouldLike = await shouldCharacterLikeMoment(character, moment);
                if (!shouldLike) {
                    console.log(`${character.name} 基于人设选择不点赞这条动态`);
                    return;
                }
            
            // 添加点赞记录
                await db.momentLikes.add({
                    momentId: parseInt(momentId),
                    authorId: character.id,
                characterId: character.id,
                name: character.name,
                timestamp: Date.now()
            });
            
            // 更新界面显示
            updateMomentLikeDisplay(momentId);
            
            // 显示点赞提示
            showToast(`${character.name} 赞了你的动态`);
            
            // 🔥【新增】如果是点赞用户的动态，创建推送通知
            if (moment.authorId === 'user') {
                createPushNotification(character, `赞了你的动态`, 100);
            }
            } catch (error) {
                console.error('AI点赞失败:', error);
            }
        }
        
        // 判断角色是否会点赞这条动态
        async function shouldCharacterLikeMoment(character, moment) {
            try {
                // 基于角色人设和动态内容的简单判断
                const characterBio = (character.bio || '').toLowerCase();
                const momentText = (moment.text || '').toLowerCase();
                
                // 如果角色人设中包含负面词汇，降低点赞概率
                const negativeTraits = ['冷漠', '严肃', '不善交际', '内向', '沉默'];
                const hasNegativeTraits = negativeTraits.some(trait => characterBio.includes(trait));
                
                if (hasNegativeTraits && Math.random() < 0.7) {
                    return false; // 70%概率不点赞
                }
                
                // 如果动态内容与角色兴趣相关，增加点赞概率
                const characterInterests = extractInterestsFromBio(characterBio);
                const hasRelatedContent = characterInterests.some(interest => 
                    momentText.includes(interest)
                );
                
                if (hasRelatedContent) {
                    return Math.random() < 0.9; // 90%概率点赞
                }
                
                // 默认情况
                return Math.random() < 0.7; // 70%概率点赞
            } catch (error) {
                console.error('判断角色点赞偏好失败:', error);
                return Math.random() < 0.6; // 默认60%概率
            }
        }
        
        // 从角色人设中提取兴趣关键词
        function extractInterestsFromBio(bio) {
            const interests = [];
            const interestKeywords = [
                '音乐', '电影', '读书', '运动', '游戏', '美食', '旅行', '摄影',
                '绘画', '写作', '代码', '科技', '动漫', '小说', '咖啡', '茶',
                '宠物', '花', '星空', '雨天', '阳光', '学习', '工作', '朋友'
            ];
            
            interestKeywords.forEach(keyword => {
                if (bio.includes(keyword)) {
                    interests.push(keyword);
                }
            });
            
            return interests;
        }
        
        // 更新动态点赞显示
        async function updateMomentLikeDisplay(momentId) {
            try {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
                const momentLikes = await db.momentLikes.where('momentId').equals(parseInt(momentId)).toArray();
            
            // 更新点赞按钮数字
            const likeBtn = momentElement.querySelector('.moment-action-btn[onclick*="toggleMomentLike"]');
            if (likeBtn) {
                const likeCount = likeBtn.querySelector('span');
                if (likeCount) {
                    likeCount.textContent = momentLikes.length;
                }
            }
            
            // 更新或创建点赞用户名称显示
            let likesDisplay = momentElement.querySelector('.likes-display');
            
            if (momentLikes.length > 0) {
                if (!likesDisplay) {
                    likesDisplay = document.createElement('div');
                    likesDisplay.className = 'likes-display';
                    
                    // 检查是否已有评论区域，如果有就不设置margin-top
                        const existingCommentsSection = momentElement.querySelector('.moment-comments-section');
                        const marginTop = existingCommentsSection ? '0' : '0';
                    
                    likesDisplay.style.cssText = `
                        margin-top: ${marginTop};
                        padding: 8px 12px;
                        background: #f8f9fa;
                        font-size: 13px;
                        color: #666;
                        line-height: 1.4;
                    `;
                    
                        // 插入到操作按钮下面，评论区前面（如果有的话），否则在时间操作区后面
                    const momentContent = momentElement.querySelector('.moment-content');
                    const momentTimeActions = momentElement.querySelector('.moment-time-actions');
                        const commentsSection = momentElement.querySelector('.moment-comments-section');
                        
                    if (momentContent && momentTimeActions) {
                            if (commentsSection) {
                                // 如果已有评论区，插入到评论区前面
                                momentContent.insertBefore(likesDisplay, commentsSection);
                            } else {
                                // 没有评论区，插入到时间操作区后面
                        momentTimeActions.parentNode.insertBefore(likesDisplay, momentTimeActions.nextSibling);
                            }
                    }
                }
                
                // 使用和用户昵称相同颜色的空心爱心
                const likeIcon = '<svg width="14" height="14" style="margin-right: 4px; vertical-align: middle;" viewBox="0 0 24 24" fill="none" stroke="#576b95" stroke-width="2"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>';
                const names = momentLikes.map(like => like.name).join('、');
                likesDisplay.innerHTML = `${likeIcon}<span style="color: #576b95; font-weight: 600;">${names}</span>`;
                likesDisplay.style.display = 'block';
            } else if (likesDisplay) {
                likesDisplay.style.display = 'none';
                }
            } catch (error) {
                console.error('更新点赞显示失败:', error);
            }
        }
        
        // AI角色评论
        async function addAIComment(momentId, character, moment) {
            try {
                // 生成符合角色人设的评论
                const comments = await generateCharacterComment(character, moment);
                if (!comments || comments.length === 0) return;
                
                const randomComment = comments[Math.floor(Math.random() * comments.length)];
                
                const comment = {
                    id: Date.now() + Math.random(),
                    nickname: character.name,
                    avatar: character.avatarUrl,
                    text: randomComment,
                    time: formatTime(new Date()),
                    timestamp: Date.now(),
                    characterId: character.id
                };
                
                // 保存评论
                saveCommentToMoment(momentId, comment);
                
                // 更新评论数
                updateMomentCommentCount(momentId);
                
                // 在动态下方显示新评论
                displayCommentUnderMoment(momentId, comment);
                
                // 显示评论提示
                showToast(`${character.name} 评论了你的动态`);
                
                // 🔥【新增】如果是评论用户的动态，创建推送通知
                if (moment.authorId === 'user') {
                    createPushNotification(character, `评论了你的动态：${randomComment.length > 15 ? randomComment.substring(0, 15) + '...' : randomComment}`, 200);
                }
            } catch (error) {
                console.error('AI角色评论失败:', error);
            }
        }
        
        // AI角色间的楼中楼互动（套用完成.html逻辑）
        async function triggerAiToAiInteraction(momentId, relatedCharacters) {
            try {
                // 获取动态信息
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment || !moment.comments) return;
                
                const comments = moment.comments;
                if (comments.length < 2) return; // 至少需要2条评论才能触发角色间互动
                
                // 获取在同群的参与评论AI角色
                const participatingAis = [...new Set(comments
                    .filter(comment => comment.characterId && comment.characterId !== 'user')
                    .map(comment => comment.characterId)
                )];
                
                // 过滤出只有在同群的AI角色
                const sameGroupParticipants = participatingAis.filter(aiId => 
                    relatedCharacters.some(char => char.id === aiId)
                );
                
                if (sameGroupParticipants.length < 2) {
                    console.log('参与评论的同群AI角色少于2个，跳过角色间互动');
                    return;
                }
                
                console.log(`发现 ${sameGroupParticipants.length} 个同群AI角色参与了评论，开始角色间互动`);
                
                // 随机选择两个同群AI进行互动
                const aiA = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                let aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                
                // 确保选择不同的AI
                while (aiB === aiA && sameGroupParticipants.length > 1) {
                    aiB = sameGroupParticipants[Math.floor(Math.random() * sameGroupParticipants.length)];
                }
                
                if (aiA === aiB) return;
                
                // 检查角色关系和互动概率 (40%概率，保持原有设置概率)
                if (Math.random() > 0.4) {
                    console.log('基于概率选择不进行角色间互动');
                    return;
                }
                
                // 选择一个现有评论作为互动起点
                const targetComment = comments.find(comment => 
                    comment.characterId === aiA || comment.characterId === aiB
                );
                
                if (!targetComment) return;
                
                // 决定谁先回复谁
                const responderCharId = targetComment.characterId === aiA ? aiB : aiA;
                const targetCharId = targetComment.characterId;
                
                // 获取角色信息
                const responderChar = characters.find(c => c.id === responderCharId);
                const targetChar = characters.find(c => c.id === targetCharId);
                
                if (!responderChar || !targetChar) return;
                
                console.log(`${responderChar.name} 将回复 ${targetChar.name} 的评论`);
                
                // 生成AI间的互动回复
                await generateAiToAiReply(momentId, targetComment, responderChar, targetChar);
                
            } catch (error) {
                console.error('角色间互动失败:', error);
            }
        }
        

        
        // 角色之间互动（保留原函数，但不再使用）
        function triggerCharacterInteractions(momentId, characters) {
            if (characters.length < 2) return;
            
            // 获取已在同一群的角色关系
            const groupRelations = getGroupRelations(characters);
            
            for (let i = 0; i < characters.length - 1; i++) {
                for (let j = i + 1; j < characters.length; j++) {
                    const char1 = characters[i];
                    const char2 = characters[j];
                    
                    // 检查是否在同一个群里
                    const inSameGroup = groupRelations.some(group => 
                        group.includes(char1.id) && group.includes(char2.id)
                    );
                    
                    if (inSameGroup && Math.random() < 0.6) {
                        addCharacterInteraction(momentId, char1, char2);
                    }
                }
            }
        }
        
        // 获取分组关系 - 基于角色分组而不是群聊
        function getGroupRelations(characters) {
            const groups = [];
            
            // 按分组ID分组角色
            const groupedCharacters = {};
            characters.forEach(character => {
                const groupId = character.groupId || 'my_friends';
                if (!groupedCharacters[groupId]) {
                    groupedCharacters[groupId] = [];
                }
                groupedCharacters[groupId].push(character.id);
            });
            
            // 只返回可以互动的分组（非默认分组且允许互动）
            Object.entries(groupedCharacters).forEach(([groupId, characterIds]) => {
                const group = characterGroups.find(g => g.id === groupId);
                
                // 只有非默认分组且允许互动的分组中的角色才能相互互动
                if (group && !group.isDefault && group.canInteract && characterIds.length >= 2) {
                    groups.push(characterIds);
                }
            });
            
            return groups;
        }
        
        // 生成AI间的回复（套用完成.html逻辑）
        async function generateAiToAiReply(momentId, targetComment, responderChar, targetChar) {
            try {
                // 获取动态信息
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment) return;
                
                // 获取响应角色的聊天设置
                let responderSettings = null;
                try {
                    responderSettings = await db.chatSettings.get(responderChar.id);
                } catch (error) {
                    console.error('获取响应角色聊天设置失败:', error);
                }
                
                const responderPersona = responderSettings?.aiPersona || responderChar.prompt || '';
                const targetPersona = targetChar.prompt || '';
                
                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (responderSettings?.linkedWorldBookIds && responderSettings.linkedWorldBookIds.length > 0) {
            try {
                        const worldBooks = await Promise.all(
                            responderSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 获取聊天上下文
                let chatContext = '';
                const responderMessages = chatMessages[responderChar.id] || [];
                if (responderMessages.length > 0) {
                    const maxMemory = parseInt(responderSettings?.maxMemory) || 10;
                    const recentHistory = responderMessages.slice(-maxMemory);
                    chatContext = '\n\n最近的聊天记录（供参考）：\n' + 
                        recentHistory.map(msg => {
                            if (msg.role === 'user') return `用户：${msg.content}`;
                            return `${responderChar.name}：${msg.content}`;
                        }).join('\n');
                }
                
                const systemPrompt = `你是${responderChar.name}，你的人设如下：${responderPersona}。${worldBookContent}${chatContext}

现在在一个动态下，${targetChar.name}（人设：${targetPersona}）刚刚评论了："${targetComment.text}"。

原动态内容：${moment.text}

你要作为${responderChar.name}，基于你的人设和与${targetChar.name}的关系，对ta的评论进行回应。要求：
1. 严格按照你的人设进行回复，不能混淆角色
2. 回复要自然、符合朋友圈评论风格
3. 可以是赞同、不同观点、补充、提问或开玩笑
4. 要体现出你和${targetChar.name}之间的互动关系
5. 回复简短有趣，符合社交媒体的特点
6. 根据你的人设选择合适的语气和用词
7. 不要使用与角色性格不符的表情符号`;

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: `请回复${targetChar.name}的评论` }
                ];

                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI互动');
                    return;
                }

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 修复：智能处理URL拼接
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`AI互动API调用失败 (${response.status}): ${errorText}`);
                    return;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return;
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`AI互动API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('AI互动API无法解析响应，完整响应数据:', data);
                        return;
                    }
                }

                if (content && content.trim()) {
                    // 创建回复评论
                    const replyComment = {
                    id: Date.now() + Math.random(),
                        nickname: responderChar.name,
                        avatar: responderChar.avatarUrl,
                        text: content.trim(),
                    time: formatTime(new Date()),
                    timestamp: Date.now(),
                        replyTo: targetChar.name,
                        characterId: responderChar.id
                };
                
                    // 保存评论
                    saveCommentToMoment(momentId, replyComment);
                
                    // 更新评论数
                updateMomentCommentCount(momentId);
                
                    // 在动态下方显示新评论
                    displayCommentUnderMoment(momentId, replyComment);
                
                    showToast(`${responderChar.name} 回复了 ${targetChar.name}`);
                }

            } catch (error) {
                console.error('生成AI间回复失败:', error);
            }
        }
        
        // AI回复用户评论
        async function triggerAIReplyToUser(momentId, aiCharacterName, userCommentText) {
            try {
                console.log(`triggerAIReplyToUser被调用: momentId=${momentId}, aiCharacterName=${aiCharacterName}, userCommentText="${userCommentText}"`);
                console.log(`当前characters数组:`, characters);
                console.log(`当前contacts数组:`, contacts);
                
                // 找到对应的AI角色
                const character = characters.find(c => c.name === aiCharacterName);
                if (!character) {
                    console.log(`未找到角色 ${aiCharacterName}，可用角色:`, characters.map(c => c.name));
                    return;
                }
                
                // 获取动态信息
                const moment = await db.moments.get(parseInt(momentId));
                if (!moment) {
                    console.log(`未找到动态 ${momentId}`);
                    return;
                }
                
                // 获取角色设置
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }
                
                const persona = chatSettings?.aiPersona || character.prompt || `你是${character.name}。`;
                
                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 获取聊天上下文
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\n最近的聊天记录（供参考）：\n' + 
                        recentHistory.map(msg => {
                        if (msg.role === 'user') return `用户：${msg.content}`;
                            return `${character.name}：${msg.content}`;
                    }).join('\n');
                }
                
                const systemPrompt = `你是${character.name}，你的人设如下：${persona}。${worldBookContent}${chatContext}

在一个动态下，用户刚刚回复了你的评论："${userCommentText}"。

原动态内容：${moment.text}

请作为${character.name}，基于你的人设对用户的回复做出自然的反应。要求：
1. 严格按照你的人设进行回复，保持角色一致性
2. 回复要自然、符合朋友圈评论风格，简短有趣
3. 可以是继续讨论、表达感谢、开玩笑或者分享更多想法
4. 体现出你和用户之间的友好互动
5. 根据你的人设选择合适的语气和用词
6. 不要使用与角色性格不符的表情符号`;

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: `请回复用户的评论` }
                ];

                console.log(`找到角色 ${character.name}，准备生成回复`);
                console.log(`动态信息:`, moment);
                console.log(`角色设置:`, chatSettings);
                
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI回复');
                    console.log('API设置:', apiSettings);
                    return;
                }

                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');

                let response;
                if (isGeminiOfficial) {
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 修复：智能处理URL拼接
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`AI回复用户API调用失败 (${response.status}): ${errorText}`);
                    return;
                }

                const data = await response.json();
                let content;

                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return;
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`AI回复用户API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('AI回复用户API无法解析响应，完整响应数据:', data);
                        return;
                    }
                }

                if (content && content.trim()) {
                    // 创建AI回复评论
                    const replyComment = {
                        id: Date.now() + Math.random(),
                        nickname: character.name,
                        avatar: character.avatarUrl,
                        text: content.trim(),
                        time: formatTime(new Date()),
                        timestamp: Date.now(),
                        replyTo: '我', // 回复用户
                        characterId: character.id
                    };
                    
                    // 保存评论
                    saveCommentToMoment(momentId, replyComment);
                    
                    // 更新评论数
                    updateMomentCommentCount(momentId);
                    
                    // 在动态下方显示新评论
                    displayCommentUnderMoment(momentId, replyComment);
                    
                    // 增加对话轮次
                    const conversationKey = `${momentId}-${character.name}`;
                    const currentRounds = commentConversationRounds.get(conversationKey) || 0;
                    commentConversationRounds.set(conversationKey, currentRounds + 1);
                    console.log(`${character.name} 在动态 ${momentId} 中的对话轮次更新为: ${currentRounds + 1}/10`);
                    
                    showToast(`${character.name} 回复了你`);
                    
                    // 🔥【新增】为角色回复用户评论创建推送通知
                    createPushNotification(character, `回复了你：${content.trim().length > 15 ? content.trim().substring(0, 15) + '...' : content.trim()}`, 200);
                }

            } catch (error) {
                console.error('AI回复用户失败:', error);
            }
        }
        
        // 生成符合角色人设的评论 - 直接套用完成.html的逻辑
        async function generateCharacterComment(character, moment) {
            try {
                // 获取角色对应的聊天设置
                let chatSettings = null;
                try {
                    chatSettings = await db.chatSettings.get(character.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }
                
                const persona = chatSettings?.aiPersona || character.prompt || `你是${character.name}。`;
                
                // 获取绑定的世界书内容
                let worldBookContent = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                    const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                    );
                    const validWorldBooks = worldBooks.filter(book => book && book.content);
                    if (validWorldBooks.length > 0) {
                        worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                            validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                    }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 获取最近的聊天记录作为上下文（根据用户设置的条数）
                let chatContext = '';
                const characterMessages = chatMessages[character.id] || [];
                if (characterMessages.length > 0) {
                    const maxMemory = parseInt(chatSettings?.maxMemory) || 10;
                    const recentHistory = characterMessages.slice(-maxMemory);
                    chatContext = '\n\n最近的聊天记录（供参考）：\n' + 
                        recentHistory.map(msg => {
                            if (msg.role === 'user') return `用户：${msg.content}`;
                            return `${character.name}：${msg.content}`;
                        }).join('\n');
                }
                
                // 分析动态内容，提取关键信息
                const momentText = moment.text || '';
                const momentAuthor = moment.nickname || '用户';
                const isUserMoment = !moment.characterId || moment.characterId === 'user';
                
                // 判断评论的类型和风格
                let commentStyle = '';
                const bio = (character.bio || '').toLowerCase();
                
                if (bio.includes('活泼') || bio.includes('开朗') || bio.includes('外向')) {
                    commentStyle = '热情活泼，用词轻松有趣';
                } else if (bio.includes('冷静') || bio.includes('理性') || bio.includes('严谨')) {
                    commentStyle = '理性客观，表达简洁';
                } else if (bio.includes('温柔') || bio.includes('善良') || bio.includes('体贴')) {
                    commentStyle = '温暖关怀，语气柔和';
                } else if (bio.includes('幽默') || bio.includes('搞笑') || bio.includes('风趣')) {
                    commentStyle = '幽默风趣，善于调侃';
                } else if (bio.includes('内向') || bio.includes('安静') || bio.includes('害羞')) {
                    commentStyle = '简洁含蓄，不多话但真诚';
                } else {
                    commentStyle = '自然真实，符合性格';
                }

                let systemPrompt = `你是${character.name}，你的人设如下：${persona}。${worldBookContent}${chatContext}

你在朋友圈看到了${momentAuthor}发布的动态："${momentText}"

请作为${character.name}，基于你的人设和与发布者的关系，对这条动态发表评论。

## 评论风格要求：
- ${commentStyle}
- 10-30字左右，简洁有力
- 要体现出你的真实反应和情感
- 可以是：赞美认同、善意调侃、关心询问、分享感受、提出建议等

## 角色表达要求：
1. 严格按照你的人设和性格特点
2. 用词要符合你的身份和说话习惯
3. 表达要自然，不要过于刻意
4. 如果你们关系亲密，可以更随意一些
5. 根据动态内容选择合适的回应角度
6. 避免使用与角色性格不符的表情符号
7. 不要生硬地重复动态内容，要有自己的观点

## 互动关系：
- 如果是用户发的动态：以朋友身份温馨互动
- 如果是其他角色发的动态：基于你们的关系和人设互动

请生成一条自然、有个性、贴合你人设的评论：`;
                
                // 构建用户消息，检查是否有图片需要识别
                let postDescription = `原动态：${momentText}`;
                let hasImages = moment.images && moment.images.length > 0;
                
                if (hasImages) {
                    postDescription += `\n[该动态包含${moment.images.length}张图片]`;
                }
                
                const userMsg = `${postDescription}\n请发表你的看法：`;
                
                // 检查当前模型是否支持视觉识别
                const supportsVision = isVisionModelSupported();
                let messages;
                
                if (hasImages && supportsVision) {
                    // 使用多模态消息格式，包含图片
                    const firstImage = moment.images[0]; // 使用第一张图片
                    console.log(`为角色 ${character.name} 使用图片识别功能评论动态`);
                    
                    messages = [
                        { role: 'system', content: systemPrompt },
                        { 
                            role: 'user', 
                            content: [
                                { type: 'text', text: `原动态文字：${momentText}\n\n这条动态还包含了一张图片，请仔细观察图片内容，然后发表你的看法：` },
                                { type: 'image_url', image_url: { url: firstImage } }
                            ]
                        }
                    ];
                } else {
                    // 普通文本消息
                    if (hasImages && !supportsVision) {
                        console.log(`当前模型不支持图片识别，${character.name} 将基于文字内容评论`);
                        // 修改提示，让AI知道有图片但无法看到
                        const textOnlyMsg = `${postDescription}\n\n注意：这条动态包含图片，但由于当前模型限制，你无法看到图片内容。请基于文字部分发表你的看法，可以适当询问图片相关内容。`;
                        messages = [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: textOnlyMsg }
                        ];
                    } else {
                        // 纯文字动态
                        messages = [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userMsg }
                        ];
                    }
                }
                
                // 使用完整的API调用逻辑（与聊天相同）
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过AI评论');
                    return [];
                }
                
                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);
                
                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');
                
                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    // 转换消息格式为Gemini格式
                    const geminiMessages = [];
                    
                    // 添加系统提示词作为第一条用户消息
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    // 转换其他消息
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        // 处理多模态内容（包含图片）
                        if (Array.isArray(msg.content)) {
                            const parts = [];
                            msg.content.forEach(item => {
                                if (item.type === 'text') {
                                    parts.push({ text: item.text });
                                } else if (item.type === 'image_url') {
                                    // 处理图片，需要转换格式
                                    const imageUrl = item.image_url.url;
                                    if (imageUrl.startsWith('data:')) {
                                        // Base64图片
                                        const [mimeInfo, base64Data] = imageUrl.split(',');
                                        const mimeType = mimeInfo.match(/data:([^;]+)/)?.[1] || 'image/jpeg';
                                        parts.push({
                                            inline_data: {
                                                mime_type: mimeType,
                                                data: base64Data
                                            }
                                        });
                                    } else {
                                        // URL图片，Gemini可能不支持，添加文本说明
                                        parts.push({ text: '[图片：' + imageUrl + ']' });
                                    }
                                }
                            });
                            geminiMessages.push({
                                role: msg.role === 'user' ? 'user' : 'model',
                                parts: parts
                            });
                        } else {
                            // 文本消息
                            geminiMessages.push({
                                role: msg.role === 'user' ? 'user' : 'model',
                                parts: [{ text: msg.content }]
                            });
                        }
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 使用OpenAI格式
                    // 智能处理URL拼接
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`API调用失败 (${response.status}): ${errorText}`);
                    return [];
                }
                
                const data = await response.json();
                let content;
                
                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return [];
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        // 尝试查找第一个字符串类型的值
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`AI评论API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('AI评论API无法解析响应，完整响应数据:', data);
                        return [];
                    }
                }
                
                if (content && content.trim().length > 0) {
                    return [content.trim()];
                }
                
                return [];
                
            } catch (error) {
                console.error('生成AI评论失败:', error);
                return [];
            }
        }
        

        
        // 生成角色间互动评论 - 使用完整的AI聊天逻辑
        async function generateCharacterInteraction(char1, char2, momentId) {
            try {
                // 获取动态和之前的评论上下文
                const momentsData = JSON.parse(sessionStorage.getItem('momentsData') || '[]');
                const moment = momentsData.find(m => (m.id == momentId) || (m.timestamp == momentId));
                if (!moment) return '';
                
                // 获取角色对应的聊天设置
                let chatSettings1 = null;
                let chatSettings2 = null;
                try {
                    chatSettings1 = await db.chatSettings.get(char1.id);
                    chatSettings2 = await db.chatSettings.get(char2.id);
                } catch (error) {
                    console.error('获取聊天设置失败:', error);
                }
                
                // 获取char2的最新评论作为上下文
                const char2Comments = (moment.comments || []).filter(c => c.characterId === char2.id);
                const latestChar2Comment = char2Comments[char2Comments.length - 1];
                
                // 构建对话上下文
                let conversationContext = `用户发布了动态：${moment.text}\n`;
                if (latestChar2Comment) {
                    conversationContext += `${char2.name}评论说：${latestChar2Comment.text}\n`;
                }
                
                // 使用完整的AI人设和记忆系统
                const persona1 = chatSettings1?.aiPersona || char1.prompt || `你是${char1.name}。`;
                
                // 获取历史聊天记录
                const maxMemory = parseInt(chatSettings1?.maxMemory) || 10;
                const char1Messages = chatMessages[char1.id] || [];
                const recentMessages = char1Messages.slice(-maxMemory);
                
                let chatSummary = '';
                if (recentMessages.length > 0) {
                    chatSummary = '你和用户最近的聊天记录（供参考）：\n';
                    chatSummary += recentMessages.map(msg => {
                        if (msg.role === 'user') return `用户：${msg.content}`;
                        if (msg.role === 'assistant') return `${char1.name}：${msg.content}`;
                        return '';
                    }).filter(line => line).join('\n');
                }
                
                // 获取挂载的世界书内容
                let worldBookContent = '';
                if (chatSettings1?.linkedWorldBookIds && chatSettings1.linkedWorldBookIds.length > 0) {
                    try {
                    const worldBooks = await Promise.all(
                            chatSettings1.linkedWorldBookIds.map(async id => {
                                try {
                                    return await db.worldbooks.get(id);
                                } catch (error) {
                                    console.error('获取世界书失败:', error);
                                    return null;
                                }
                            })
                    );
                    const validWorldBooks = worldBooks.filter(book => book && book.content);
                    if (validWorldBooks.length > 0) {
                        worldBookContent = '\n\n世界书内容（供参考）：\n' + 
                            validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n');
                    }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                let systemPrompt = `你是${char1.name}，你的人设如下：${persona1}。${worldBookContent}${chatSummary}\n\n`;
                systemPrompt += `这是一个楼中楼讨论，请基于以下对话上下文，继续参与讨论。要符合你的人设，回复要简短有趣。`;
                if (chatSettings2?.aiPersona) {
                    systemPrompt += ` （${char2.name}的设定：${chatSettings2.aiPersona}）`;
                }
                systemPrompt += `\n\n要求：
1. 回复要符合朋友圈评论的风格，简短、自然
2. 严格按照你的人设来选择是否使用表情符号，不要使用与角色性格不符的emoji
3. 不要过于正式或客套，要像真实的朋友一样互动`;
                
                // 构建消息
                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: conversationContext }
                ];
                
                // 使用完整的API调用逻辑（与聊天相同）
                const { base: proxyUrl, key: apiKey, model } = apiSettings;
                if (!proxyUrl || !apiKey || !model) {
                    console.log('API配置不完整，跳过角色互动');
                    return '';
                }
                
                const requestBody = {
                    model: model,
                    messages: messages,
                    temperature: 0.8,
                    stream: false
                };
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);
                
                // 检测是否是Gemini官方API
                const isGeminiOfficial = proxyUrl.includes('generativelanguage.googleapis.com');
                
                let response;
                if (isGeminiOfficial) {
                    // 使用Gemini官方API格式
                    const apiUrl = `${proxyUrl}/models/${model}:generateContent?key=${apiKey}`;
                    
                    const geminiMessages = [];
                    if (requestBody.messages[0]?.role === 'system') {
                        geminiMessages.push({
                            role: 'user',
                            parts: [{ text: requestBody.messages[0].content }]
                        });
                        geminiMessages.push({
                            role: 'model',
                            parts: [{ text: '我明白了，我会按照这些要求进行对话。' }]
                        });
                    }
                    
                    for (let i = 1; i < requestBody.messages.length; i++) {
                        const msg = requestBody.messages[i];
                        if (msg.role === 'system') continue;
                        
                        geminiMessages.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiMessages,
                            generationConfig: {
                                temperature: requestBody.temperature || 0.8
                            }
                        }),
                        signal: controller.signal
                    });
                } else {
                    // 修复：智能处理URL拼接
                    let apiUrl;
                    if (proxyUrl.endsWith('/v1')) {
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else if (proxyUrl.includes('/v1/')) {
                        // 如果URL中已经包含/v1/路径，直接添加chat/completions
                        apiUrl = `${proxyUrl}/chat/completions`;
                    } else {
                        apiUrl = `${proxyUrl}/v1/chat/completions`;
                    }
                    
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody),
                        signal: controller.signal
                    });
                }
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    let errorText = await response.text();
                    console.error(`角色互动API调用失败 (${response.status}): ${errorText}`);
                    return '';
                }
                
                const data = await response.json();
                let content;
                
                if (isGeminiOfficial) {
                    content = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!content) {
                        console.log('Gemini API 响应数据:', data);
                        return '';
                    }
                } else {
                    // 解析OpenAI格式响应
                    if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                        content = data.choices[0].message.content;
                    } else if (data.message) {
                        content = data.message;
                    } else if (data.text) {
                        content = data.text;
                    } else if (data.response) {
                        content = data.response;
                    } else if (data.content) {
                        content = data.content;
                    } else if (data.result) {
                        content = data.result;
                    } else {
                        // 尝试查找第一个字符串类型的值
                        for (const key in data) {
                            if (typeof data[key] === 'string' && data[key].trim()) {
                                content = data[key];
                                console.log(`角色互动API使用字段 "${key}" 作为响应内容`);
                                break;
                            }
                        }
                    }
                    
                    if (!content) {
                        console.error('角色互动API无法解析响应，完整响应数据:', data);
                return '';
                    }
                }
                
                return content ? content.trim() : '';
                
            } catch (error) {
                console.error('生成角色互动失败:', error);
                return '';
            }
        }
        

        
        // 长按选择功能
        function addLongPressListener(element, momentId) {
            let pressTimer = null;
            let startY = 0;
            let moved = false;
            
            const startPress = (e) => {
                if (isSelectionMode) return;
                
                startY = e.touches ? e.touches[0].clientY : e.clientY;
                moved = false;
                
                pressTimer = setTimeout(() => {
                    if (!moved) {
                        enterSelectionMode();
                        selectMoment(momentId);
                    }
                }, 500); // 500ms长按
            };
            
            const endPress = () => {
                clearTimeout(pressTimer);
                pressTimer = null;
            };
            
            const movePress = (e) => {
                const currentY = e.touches ? e.touches[0].clientY : e.clientY;
                if (Math.abs(currentY - startY) > 10) {
                    moved = true;
                    endPress();
                }
            };
            
            element.addEventListener('touchstart', startPress);
            element.addEventListener('touchend', endPress);
            element.addEventListener('touchmove', movePress);
            element.addEventListener('mousedown', startPress);
            element.addEventListener('mouseup', endPress);
            element.addEventListener('mousemove', movePress);
        }
        
        // 进入选择模式
        function enterSelectionMode() {
            isSelectionMode = true;
            selectedMoments.clear();
            
            // 显示选择模式UI
            showSelectionModeUI();
            
            // 添加选择框到所有动态
            const momentItems = document.querySelectorAll('.moment-item');
            momentItems.forEach(item => {
                const checkbox = document.createElement('div');
                checkbox.className = 'moment-checkbox';
                checkbox.innerHTML = '<i class="far fa-circle"></i>';
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    const momentId = item.getAttribute('data-moment-id');
                    toggleMomentSelection(momentId);
                };
                item.appendChild(checkbox);
                item.classList.add('selection-mode');
            });
        }
        
        // 退出选择模式
        function exitSelectionMode() {
            isSelectionMode = false;
            selectedMoments.clear();
            
            // 隐藏选择模式UI
            hideSelectionModeUI();
            
            // 移除选择框
            const checkboxes = document.querySelectorAll('.moment-checkbox');
            checkboxes.forEach(checkbox => checkbox.remove());
            
            const momentItems = document.querySelectorAll('.moment-item');
            momentItems.forEach(item => {
                item.classList.remove('selection-mode', 'selected');
            });
        }
        
        // 显示选择模式UI
        function showSelectionModeUI() {
            const selectionBar = document.createElement('div');
            selectionBar.className = 'selection-bar';
            selectionBar.innerHTML = `
                <div class="selection-actions">
                    <button class="cancel-btn" onclick="exitSelectionMode()">取消</button>
                    <span class="selection-count">已选择 0 条动态</span>
                    <button class="delete-btn" onclick="deleteSelectedMoments()" disabled>删除</button>
                </div>
            `;
            
            const momentsPage = document.getElementById('moments-page');
            momentsPage.insertBefore(selectionBar, momentsPage.firstChild);
        }
        
        // 隐藏选择模式UI
        function hideSelectionModeUI() {
            const selectionBar = document.querySelector('.selection-bar');
            if (selectionBar) {
                selectionBar.remove();
            }
        }
        
        // 切换动态选择状态
        function toggleMomentSelection(momentId) {
            const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
            if (!momentElement) return;
            
            const checkbox = momentElement.querySelector('.moment-checkbox i');
            
            if (selectedMoments.has(momentId)) {
                selectedMoments.delete(momentId);
                checkbox.className = 'far fa-circle';
                momentElement.classList.remove('selected');
            } else {
                selectedMoments.add(momentId);
                checkbox.className = 'fas fa-check-circle';
                momentElement.classList.add('selected');
            }
            
            updateSelectionUI();
        }
        
        // 选择动态
        function selectMoment(momentId) {
            if (!selectedMoments.has(momentId)) {
                toggleMomentSelection(momentId);
            }
        }
        
        // 更新选择UI
        function updateSelectionUI() {
            const countSpan = document.querySelector('.selection-count');
            const deleteBtn = document.querySelector('.delete-btn');
            
            if (countSpan) {
                countSpan.textContent = `已选择 ${selectedMoments.size} 条动态`;
            }
            
            if (deleteBtn) {
                deleteBtn.disabled = selectedMoments.size === 0;
            }
        }
        
        // 删除选中的动态
        async function deleteSelectedMoments() {
            if (selectedMoments.size === 0) return;
            
            if (!confirm(`确定要删除 ${selectedMoments.size} 条动态吗？`)) {
                return;
            }
            
            try {
                // 从数据库中删除
                for (const momentId of selectedMoments) {
                    try {
                        // 尝试多种ID格式进行删除
                        let deleted = false;
                        const possibleIds = [momentId, parseInt(momentId), String(momentId), Number(momentId)];
                        
                        for (const id of possibleIds) {
                            try {
                                await db.moments.delete(id);
                                console.log(`✓ 成功删除动态 ${id} (类型: ${typeof id})`);
                                deleted = true;
                                break;
                            } catch (error) {
                                console.log(`删除ID ${id} (${typeof id}) 失败: ${error.message}`);
                            }
                        }
                        
                        if (!deleted) {
                            // 尝试使用where条件删除
                            await db.moments.where('id').equals(momentId).delete();
                            console.log(`✓ 使用where条件删除动态 ${momentId} 成功`);
                        }
                        
                        // 删除相关点赞（尝试不同ID格式）
                        const numericId = parseInt(momentId);
                        await db.momentLikes.where('momentId').equals(numericId).delete();
                        await db.momentLikes.where('momentId').equals(momentId).delete();
                        
                        // 删除相关评论（尝试不同ID格式）
                        await db.momentComments.where('momentId').equals(numericId).delete();
                        await db.momentComments.where('momentId').equals(momentId).delete();
                        
                    } catch (error) {
                        console.error(`删除动态 ${momentId} 失败:`, error);
                        throw error; // 重新抛出错误以便上层处理
                    }
                    
                    // 清理对话轮次记录
                    for (const [key, value] of commentConversationRounds.entries()) {
                        if (key.startsWith(`${momentId}-`)) {
                            commentConversationRounds.delete(key);
                        }
                    }
            }
            
            // 从DOM中移除
            selectedMoments.forEach(momentId => {
                const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
                if (momentElement) {
                    momentElement.remove();
                }
            });
                
                // 清理可能存在的sessionStorage缓存数据
                try {
                    const sessionMomentsData = sessionStorage.getItem('momentsData');
                    if (sessionMomentsData) {
                        const momentsArray = JSON.parse(sessionMomentsData);
                        const filteredMoments = momentsArray.filter(moment => 
                            !selectedMoments.has(moment.id.toString()) && 
                            !selectedMoments.has(moment.timestamp?.toString())
                        );
                        sessionStorage.setItem('momentsData', JSON.stringify(filteredMoments));
                    }
                } catch (error) {
                    console.warn('清理sessionStorage动态数据时出错:', error);
                }
            
            showToast(`已删除 ${selectedMoments.size} 条动态`);
            
            // 退出选择模式
            exitSelectionMode();
                
                // 强制重新加载动态列表，确保删除生效
                setTimeout(() => {
                    loadMoments();
                }, 500);
                
            } catch (error) {
                console.error('删除动态失败:', error);
                showToast('删除失败，请重试');
            }
        }
        
        // 强制清理指定动态的所有相关数据
        async function forceCleanMoment(momentId) {
            try {
                const numericId = parseInt(momentId);
                console.log(`开始彻底清理动态: ${momentId}`);
                
                // 1. 从IndexedDB删除（尝试多种ID格式）
                let deleted = false;
                const possibleIds = [momentId, numericId, String(momentId), Number(momentId)];
                
                for (const id of possibleIds) {
                    try {
                        await db.moments.delete(id);
                        console.log(`✓ 删除动态成功，使用ID: ${id} (类型: ${typeof id})`);
                        deleted = true;
                        break;
                    } catch (error) {
                        console.log(`删除ID ${id} 失败: ${error.message}`);
                    }
                }
                
                if (!deleted) {
                    await db.moments.where('id').equals(momentId).delete();
                }
                
                // 删除相关数据（尝试不同格式）
                await db.momentLikes.where('momentId').equals(numericId).delete();
                await db.momentLikes.where('momentId').equals(momentId).delete();
                await db.momentComments.where('momentId').equals(numericId).delete();
                await db.momentComments.where('momentId').equals(momentId).delete();
                
                // 2. 清理对话轮次记录
                for (const [key, value] of commentConversationRounds.entries()) {
                    if (key.startsWith(`${momentId}-`)) {
                        commentConversationRounds.delete(key);
                    }
                }
                
                // 3. 从DOM移除
                const momentElement = document.querySelector(`[data-moment-id="${momentId}"]`);
                if (momentElement) {
                    momentElement.remove();
                }
                
                // 4. 清理sessionStorage缓存
                const sessionMomentsData = sessionStorage.getItem('momentsData');
                if (sessionMomentsData) {
                    const momentsArray = JSON.parse(sessionMomentsData);
                    const filteredMoments = momentsArray.filter(moment => 
                        moment.id != momentId && 
                        moment.timestamp != momentId &&
                        moment.id.toString() !== momentId.toString()
                    );
                    sessionStorage.setItem('momentsData', JSON.stringify(filteredMoments));
                }
                
                console.log(`动态 ${momentId} 清理完成`);
                return true;
            } catch (error) {
                console.error('强制清理动态失败:', error);
                return false;
            }
        }
        
        // 清理所有有问题的动态（修复工具）
        async function cleanupCorruptedMoments() {
            if (!confirm('这将清理所有可能有问题的动态数据，确定继续吗？')) {
                return;
            }
            
            try {
                let cleanupCount = 0;
                
                // 获取所有动态
                const allMoments = await db.moments.toArray();
                
                for (const moment of allMoments) {
                    // 检查动态是否有无效的头像数据
                    if (moment.avatar && !isValidAvatarUrl(moment.avatar)) {
                        console.log(`发现无效头像的动态: ${moment.id}`);
                        
                        // 修复头像或删除动态
                        const shouldDelete = confirm(`动态 "${moment.text?.substring(0, 30)}..." 包含无效头像数据，是否删除此动态？\n点击"取消"将修复头像数据。`);
                        
                        if (shouldDelete) {
                            await forceCleanMoment(moment.id);
                            cleanupCount++;
                        } else {
                            // 修复头像
                            await db.moments.update(moment.id, { avatar: getDefaultAvatar() });
                        }
                    }
                }
                
                if (cleanupCount > 0) {
                    showToast(`已清理 ${cleanupCount} 条有问题的动态`);
                    // 重新加载动态列表
                    loadMoments();
                } else {
                    showToast('没有发现需要清理的动态');
                }
                
            } catch (error) {
                console.error('清理损坏动态失败:', error);
                showToast('清理失败，请重试');
            }
        }
        
        // 更换动态封面图片
        function changeCoverImage() {
            const input = document.createElement("input");
            input.type = "file";
            input.accept = "image/*";
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedImage = await compressImage(file, 1200, 0.8);
                        
                        const coverImage = document.getElementById("cover-image");
                        const coverPlaceholder = document.getElementById("cover-placeholder");
                        
                        if (coverImage && coverPlaceholder) {
                            coverImage.src = compressedImage;
                            coverImage.classList.remove("hide");
                            coverPlaceholder.classList.add("hide");
                        }
                        
                        saveMomentsImage("coverImage", compressedImage);
                        showToast("封面已更新！", "success");
                    } catch (error) {
                        console.error("处理封面图片失败:", error);
                        showToast("封面更新失败！", "error");
                    }
                }
            };
            input.click();
        }
        
        // 更换动态头像
        function changeAvatarImage(event) {
            event.stopPropagation();
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (file) {
                    try {
                        // 压缩头像图片
                        const compressedImage = await compressImage(file, 400, 0.9);
                        
                        const avatar = document.getElementById('moments-avatar');
                        const avatarIcon = avatar.querySelector('.moments-avatar-icon');
                        
                        avatar.style.backgroundImage = `url(${compressedImage})`;
                        avatarIcon.style.display = 'none';
                        
                        // 保存压缩后的图片
                        saveMomentsImage('avatarImage', compressedImage);
                        
                        showToast('头像已更新！', 'success');
                    } catch (error) {
                        console.error('处理头像图片失败:', error);
                        showToast('头像更新失败！', 'error');
                    }
                }
            };
            input.click();
        }
        
        // 🔥【修复】加载动态图片设置（异步版本）
        async function loadMomentsImages() {
            try {
                // 加载封面图片
                const savedCover = await getMomentsImage('coverImage');
                if (savedCover) {
                    const coverImage = document.getElementById('cover-image');
                    const coverPlaceholder = document.getElementById('cover-placeholder');
                    
                    if (coverImage && coverPlaceholder) {
                        coverImage.src = savedCover;
                        coverImage.classList.remove('hide');
                        coverPlaceholder.classList.add('hide');
                    }
                }
                
                // 加载头像图片
                const savedAvatar = await getMomentsImage('avatarImage');
                if (savedAvatar) {
                    const avatar = document.getElementById('moments-avatar');
                    const avatarIcon = avatar?.querySelector('.moments-avatar-icon');
                    
                    if (avatar) {
                        avatar.style.backgroundImage = `url(${savedAvatar})`;
                        if (avatarIcon) {
                            avatarIcon.style.display = 'none';
                        }
                    }
                }
                
                // 加载用户名
                const savedUsername = await getMomentsImage('username');
                if (savedUsername) {
                    const usernameElement = document.getElementById('moments-username');
                    if (usernameElement) {
                        usernameElement.textContent = savedUsername;
                    }
                }
                
                console.log('动态图片加载完成');
            } catch (error) {
                console.error('加载动态图片失败:', error);
            }
        }
        
        // 更改用户名
        function changeUsername(event) {
            event.stopPropagation();
            
            const currentUsername = document.getElementById('moments-username').textContent;
            const newUsername = prompt('请输入您的昵称:', currentUsername);
            
            if (newUsername !== null && newUsername.trim() !== '') {
                const usernameElement = document.getElementById('moments-username');
                usernameElement.textContent = newUsername.trim();
                
                // 保存用户名
                saveMomentsImage('username', newUsername.trim());
                
                showToast('昵称已更新！', 'success');
            }
        }
        
        // 压缩图片
        function compressImage(fileOrDataUrl, maxWidth = 800, quality = 0.8) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    // 计算压缩后的尺寸
                    let { width, height } = img;
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // 绘制压缩后的图片
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // 转换为base64，降低质量以减少大小
                    const compressedData = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedData);
                };
                
                // 判断输入类型：File对象还是base64字符串
                if (typeof fileOrDataUrl === 'string') {
                    // 如果是base64字符串，直接使用
                    img.src = fileOrDataUrl;
                } else {
                    // 如果是File对象，创建URL
                    img.src = URL.createObjectURL(fileOrDataUrl);
                }
            });
        }
        
        // 🔥【修复】保存动态图片（使用IndexedDB持久化存储）
        async function saveMomentsImage(imageType, imageData) {
            try {
                // 压缩图片数据以节省存储空间
                let compressedData = imageData;
                if (imageData.startsWith('data:image/')) {
                    try {
                        compressedData = await compressImage(imageData, 800, 0.8);
                    } catch (error) {
                        console.warn('图片压缩失败，使用原图:', error);
                    }
                }
                
                // 保存到IndexedDB
                await db.globalSettings.put({
                    id: `moments_${imageType}`,
                    type: 'moments_setting',
                    data: compressedData
                });
                
                console.log(`动态图片已保存到数据库: ${imageType}`);
            } catch (error) {
                console.error('保存动态图片失败:', error);
                // 如果数据库保存失败，回退到sessionStorage
                try {
                    sessionStorage.setItem(`moments_${imageType}`, imageData);
                    console.log(`动态图片已保存到会话存储: ${imageType}`);
                } catch (sessionError) {
                    // 如果sessionStorage也满了，只在内存中保存
                    window.momentsImages = window.momentsImages || {};
                    window.momentsImages[imageType] = imageData;
                    console.log(`动态图片已保存到内存: ${imageType}`);
                }
            }
        }
        
        // 🔥【修复】获取动态图片（从IndexedDB获取）
        async function getMomentsImage(imageType) {
            try {
                // 先从IndexedDB获取
                const dbData = await db.globalSettings.get(`moments_${imageType}`);
                if (dbData && dbData.data) {
                    return dbData.data;
                }
                
                // 兼容性：从sessionStorage获取
                const sessionData = sessionStorage.getItem(`moments_${imageType}`);
                if (sessionData) {
                    // 如果从sessionStorage获取到数据，迁移到IndexedDB
                    await saveMomentsImage(imageType, sessionData);
                    return sessionData;
                }
                
                // 最后从内存获取
                if (window.momentsImages && window.momentsImages[imageType]) {
                    return window.momentsImages[imageType];
                }
                
                return null;
            } catch (error) {
                console.error('获取动态图片失败:', error);
                // 回退到sessionStorage
                try {
                    return sessionStorage.getItem(`moments_${imageType}`);
                } catch (sessionError) {
                    return null;
                }
            }
        }
        
        // 重置数据库（如果出现schema错误）
        async function resetDatabase() {
            try {
                await db.delete();
                console.log('数据库已重置');
                location.reload(); // 重新加载页面
            } catch (error) {
                console.error('重置数据库失败:', error);
            }
        }
        
        // 开始游戏
        function startGame(gameName) {
            if (gameName === 'witchPotion') {
                // TODO: 实现女巫的解药游戏
                alert('女巫的解药游戏正在开发中...\n\n这将是一个与AI角色互动的解谜游戏！');
            } else {
                alert('游戏功能正在开发中...');
            }
        }
        
                // 切换手机边框显示
        function togglePhoneBorder() {
            const phoneFrame = document.getElementById('phone-frame');
            const phoneScreen = document.getElementById('phone-screen');
            const toggle = document.getElementById('phone-border-toggle');
            const body = document.body;
            
            if (toggle.checked) {
                // 显示真实手机边框
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '12px';
                phoneFrame.style.backgroundColor = '#fff';
                phoneFrame.style.borderRadius = '50px';
                phoneFrame.style.boxShadow = '0 20px 50px rgba(0,0,0,0.25), inset 0 2px 4px rgba(0,0,0,0.1)';
                phoneScreen.style.borderRadius = '40px';
                phoneScreen.style.border = '2px solid #333';
                body.style.background = 'var(--body-bg, #dcdcdc)';
                body.style.padding = '20px';
            } else {
                // 隐藏边框，但保持phone-screen的圆角和阴影
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '0';
                phoneFrame.style.backgroundColor = 'transparent';
                phoneFrame.style.borderRadius = '0';
                phoneFrame.style.boxShadow = 'none';
                phoneScreen.style.borderRadius = '25px';
                phoneScreen.style.border = 'none';
                phoneScreen.style.boxShadow = 'var(--shadow-phone)';
                body.style.background = 'var(--body-bg, #1a1a1a)';
                body.style.padding = '0';
            }
            
            // 保存设置到localStorage
            localStorage.setItem('phoneBorderEnabled', toggle.checked);
            
            // 显示提示
            const message = toggle.checked ? '手机边框已开启！' : '手机边框已关闭！';
            showToast(message, 'success');
        }
        
        // 显示屏幕尺寸选择
        function showScreenSizeOptions() {
            showApp('screen-size-screen');
        }
        
        // 改变屏幕尺寸
        function changeScreenSize(width, height, name) {
            const phoneScreen = document.getElementById('phone-screen');
            
            // 应用新尺寸
            phoneScreen.style.width = width + 'px';
            phoneScreen.style.height = height + 'px';
            
            // 更新外观设置中的显示文本
            const currentSizeDesc = document.getElementById('current-screen-size');
            if (currentSizeDesc) {
                currentSizeDesc.textContent = `当前：${width}×${height} (${name})`;
            }
            
            // 更新选中状态
            document.querySelectorAll('.size-option .check-icon').forEach(icon => {
                icon.style.display = 'none';
            });
            document.querySelectorAll('.size-option').forEach(option => {
                option.style.backgroundColor = '';
            });
            
            // 显示当前选中项的勾选图标
            const currentOption = event.target.closest('.size-option');
            if (currentOption) {
                const checkIcon = currentOption.querySelector('.check-icon');
                if (checkIcon) {
                    checkIcon.style.display = 'block';
                } else {
                    // 如果没有勾选图标，创建一个
                    const newCheckIcon = document.createElement('i');
                    newCheckIcon.className = 'fas fa-check check-icon';
                    newCheckIcon.style.display = 'block';
                    currentOption.appendChild(newCheckIcon);
                }
                currentOption.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
            }
            
            // 保存到localStorage
            localStorage.setItem('screenSize', JSON.stringify({width, height, name}));
            
            // 显示提示
            showToast(`屏幕尺寸已切换为${name}！`, 'success');
            
            // 延迟一点再返回，让用户看到选择效果
            setTimeout(() => {
                showApp('appearance-screen');
            }, 300);
        }
        
        // 加载屏幕尺寸设置
        function loadScreenSize() {
            const saved = localStorage.getItem('screenSize');
            if (saved) {
                const {width, height, name} = JSON.parse(saved);
                const phoneScreen = document.getElementById('phone-screen');
                phoneScreen.style.width = width + 'px';
                phoneScreen.style.height = height + 'px';
                
                const currentSizeDesc = document.getElementById('current-screen-size');
                if (currentSizeDesc) {
                    currentSizeDesc.textContent = `当前：${width}×${height} (${name})`;
                }
            }
        }
        
        // 加载边框设置
        function loadPhoneBorderSetting() {
            const saved = localStorage.getItem('phoneBorderEnabled');
            const toggle = document.getElementById('phone-border-toggle');
            
            // 默认关闭边框
            const enabled = saved !== null ? saved === 'true' : false;
            
            if (toggle) {
                toggle.checked = enabled;
            }
            
            // 应用设置
            const phoneFrame = document.getElementById('phone-frame');
            const phoneScreen = document.getElementById('phone-screen');
            const body = document.body;
            
            if (enabled) {
                // 显示真实手机边框
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '12px';
                phoneFrame.style.backgroundColor = '#fff';
                phoneFrame.style.borderRadius = '50px';
                phoneFrame.style.boxShadow = '0 20px 50px rgba(0,0,0,0.25), inset 0 2px 4px rgba(0,0,0,0.1)';
                phoneScreen.style.borderRadius = '40px';
                phoneScreen.style.border = '2px solid #333';
                body.style.background = 'var(--body-bg, #dcdcdc)';
                body.style.padding = '20px';
            } else {
                // 隐藏边框，但保持phone-screen的圆角和阴影
                phoneFrame.style.display = 'block';
                phoneFrame.style.padding = '0';
                phoneFrame.style.backgroundColor = 'transparent';
                phoneFrame.style.borderRadius = '0';
                phoneFrame.style.boxShadow = 'none';
                phoneScreen.style.borderRadius = '25px';
                phoneScreen.style.border = 'none';
                phoneScreen.style.boxShadow = 'var(--shadow-phone)';
                body.style.background = 'var(--body-bg, #1a1a1a)';
                body.style.padding = '0';
            }
        }
        
        // 添加Toast提示函数
        function showToast(message, type = 'info') {
            // 创建toast元素
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                opacity: 0;
                transition: opacity 0.3s ease;
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            // 显示toast
            setTimeout(() => {
                toast.style.opacity = '1';
            }, 10);
            
            // 3秒后自动隐藏
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }
        
        // 文本截断函数
        function truncateText(text, maxLength = 50) {
    // --- 新增的安全检查 ---
    let textStr = '';
    if (typeof text === 'string') {
        textStr = text;
    } else if (text && typeof text === 'object') {
        // 如果收到了一个对象，可能是[object Object]问题的根源，
        // 我们不再让它崩溃，而是显示一个通用占位符。
        console.warn("truncateText 函数收到了一个对象，已自动处理:", text);
        return '[多媒体消息]';
    } else {
        // 对于其他意外情况 (如 null 或 undefined)，返回空字符串。
        return '';
    }
    // --- 安全检查结束 ---

    // 现在 textStr 保证是一个字符串，后续代码可以安全执行
            const plainText = textStr.replace(/<[^>]*>/g, '');
            const cleanText = plainText.replace(/\s+/g, ' ').trim();
            
            if (cleanText.length <= maxLength) {
                return cleanText;
            }
            
            return cleanText.substring(0, maxLength) + '...';
        }

        // 添加单个消息并应用动画效果
        function addMessageWithAnimation(message, characterId) {
            const messagesContainer = document.getElementById('api-chat-messages');
            if (!messagesContainer || !currentChatCharacter || characterId !== currentChatCharacter.id) return;
            
            const chatSettings = getCurrentChatSettings();
            const typingIndicator = document.getElementById('typing-indicator');
            
            // 处理系统消息
            if (message.sender === 'system') {
                let systemElement;
                
                if (message.isPoke) {
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'poke-system-container';
                    const systemMessage = document.createElement('div');
                    systemMessage.className = 'poke-system-message';
                    systemMessage.textContent = message.content;
                    systemContainer.appendChild(systemMessage);
                    systemElement = systemContainer;
                } else if (message.type === 'recalled_message') {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    centerContainer.dataset.messageId = message.id;
                    
                    const recallElement = document.createElement('div');
                    recallElement.className = 'recalled-message';
                    
                    const lines = message.content.split('\n');
                    const mainText = lines[0];
                    const originalText = lines[1];
                    
                    recallElement.textContent = mainText;
                    
                    if (originalText && originalText.startsWith('原文：')) {
                        const originalDiv = document.createElement('div');
                        originalDiv.className = 'original-text';
                        originalDiv.textContent = originalText;
                        recallElement.appendChild(originalDiv);
                    }
                    
                    centerContainer.appendChild(recallElement);
                    systemElement = centerContainer;
                    addMessageLongPressListener(centerContainer, message.id);
                } else {
                    const centerContainer = document.createElement('div');
                    centerContainer.style.display = 'flex';
                    centerContainer.style.justifyContent = 'center';
                    centerContainer.style.margin = '4px 0';
                    
                    const systemContainer = document.createElement('div');
                    systemContainer.className = 'system-message';
                    systemContainer.textContent = message.content;
                    
                    centerContainer.appendChild(systemContainer);
                    systemElement = centerContainer;
                }
                
                // 为系统消息添加滑入动画
                systemElement.style.opacity = '0';
                systemElement.style.transform = 'translateY(20px)';
                
                messagesContainer.insertBefore(systemElement, typingIndicator);
                
                // 触发动画
                requestAnimationFrame(() => {
                    systemElement.classList.add('message-slide-in');
                });
                
                return;
            }
            
            // 创建普通消息容器
            let messageContainer = document.createElement('div');
            const isEmojiOnly = message.isEmoji && !message.content;
            messageContainer.className = `message-container ${message.sender}${chatSettings.hideAvatars ? ' no-avatar' : ''}${isEmojiOnly ? ' emoji-only' : ''}`;
            messageContainer.dataset.messageId = message.id;
            
            if (message.sender === 'received') {
                // ==== 群聊支持 ====
                let character = characters.find(c => c.id === characterId);
                let isGroup = false;
                let group = null;
                if (!character) {
                    group = groupChats.find(g => g.id === characterId);
                    if (group) {
                        isGroup = true;
                    }
                }
                
                let displayAvatar = '';
                let displayName = '';
                let color = '#4CAF50';
                
                if (isGroup && group) {
                    // 群聊：根据消息的senderId或name查找成员
                    let member = null;
                    if (message.senderId) {
                        member = group.members.find(m => m.id === message.senderId);
                    } else if (message.name) {
                        member = group.members.find(m => m.name === message.name);
                    }
                    displayAvatar = member?.avatarUrl || '';
                    displayName = member?.name || '群成员';
                    color = member?.color || '#4CAF50';
                } else if (character) {
                    // 单聊
                    displayAvatar = chatSettings.aiDynamicAvatar || chatSettings.aiChatAvatar || character.avatarUrl;
                    displayName = chatSettings.aiChatNickname || character.name;
                    color = character.color || '#4CAF50';
                } else {
                    // 兜底，防止报错
                    displayAvatar = '';
                    displayName = '未知';
                    color = '#4CAF50';
                }
                
                // 🔥【新增】获取气泡样式 - 群聊中使用成员专属颜色
                let bubbleColor = chatSettings.aiBubbleColor || '#f0f0f0';
                
                // 如果是群聊且有成员专属颜色设置，使用成员专属颜色
                if (isGroup && group && message.senderId && chatSettings.memberBubbleColors) {
                    const memberColor = chatSettings.memberBubbleColors[message.senderId];
                    if (memberColor) {
                        bubbleColor = memberColor;
                    }
                }
                
                const bubbleOpacity = chatSettings.aiBubbleOpacity || '1';
                const textColor = isLightColor(bubbleColor) ? '#333' : '#fff';
                const bubblePadding = chatSettings.bubblePadding || '12';
                
                // 处理特殊消息类型
                let messageContent = '';
                
                if (message.type === 'voice_message') {
                    // AI语音消息直接创建voice-message-container结构，不需要在这里创建messageContent
                    messageContent = '';
                } else if (message.type === 'ai_image') {
                    messageContent = `
                        <div class="ai-image-container">
                            <img src="${message.image}" class="message-image" onclick="showImage('${message.image}')" alt="AI生成的图片">
                            <div class="image-description">${message.imageDescription || ''}</div>
                        </div>
                    `;
                } else if (message.type === 'transfer') {
                    // 转账消息
                    const isUser = message.role === 'user';
                    const heartIcon = isUser ? '💕' : '💖';
                    const titleText = isUser ? '你发起的转账' : '收到转账';
                    let cardClass = '';
                    let statusHtml = '';
                    let clickHandler = '';
                    
                    if (message.status === 'accepted') {
                        statusHtml = `<div class="transfer-status">${isUser ? '对方已收款' : '已收款'}</div>`;
                        cardClass = 'accepted';
                    } else if (message.status === 'rejected') {
                        statusHtml = `<div class="transfer-status">${isUser ? '对方已退回' : '已退回'}</div>`;
                        cardClass = 'rejected';
                    } else if (!isUser) {
                        // AI发来的转账且未处理，添加点击处理
                        clickHandler = `onclick="showTransferConfirmDialog(${JSON.stringify(message).replace(/"/g, '&quot;')})"`;
                    }
                    
                    messageContent = `
                        <div class="transfer-message-container received">
                            <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}" ${clickHandler}>
                                <div class="transfer-title">${heartIcon} ${titleText}</div>
                                <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                <div class="transfer-note">${message.note || '转账'}</div>
                                ${statusHtml}
                            </div>
                        </div>
                    `;
                } else {
                    const chatMode = chatSettings.chatMode || 'online';
                    let processedContent = message.content;
                    
                    if (chatMode === 'offline') {
                        processedContent = processOfflineContent(message.content);
                    }
                    
                    // 如果有引用消息，在内容前添加引用显示
                    if (message.replyTo) {
                        messageContent = generateReplyHTML(message.replyTo) + renderMentionText(processedContent);
                    } else {
                        messageContent = renderMentionText(processedContent);
                    }
                }
                
                let avatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    avatarHtml = `
                        <div class="message-avatar" style="background-color: ${color}; ${displayAvatar ? `background-image: url(${displayAvatar}); background-size: cover; background-position: center;` : ''}" ${character ? `onclick="pokeCharacter('${character.id}')" title="戳一戳"` : `title="${displayName}"`}>
                            ${displayAvatar ? '' : displayName.charAt(0)}
                        </div>
                    `;
                }
                
                const transparentBubbleColor = convertColorWithOpacity(bubbleColor, bubbleOpacity);
                
                let bubbleHtml = '';
                if (message.type === 'transfer') {
                    // 转账消息不需要气泡包裹
                    bubbleHtml = messageContent;
                } else {
                    // 普通消息用气泡包裹
                    bubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                        ${messageContent}
                        ${message.image && !message.type ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                        ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ''}
                    </div>
                `;
                }
                
          // 🔥【修复】群聊昵称显示 （第三个渲染函数版本）- 特别处理语音消息和转账消息
          if (isGroup && group && displayName !== '群成员') {
    messageContainer.classList.add('group-message-item');
    const senderNameHtml = `<div class="sender-name">${displayName}</div>`;
    
    if (message.type === 'voice_message' || message.type === 'transfer') {
        // 🔥【修复】对于语音消息和转账消息，昵称需要在容器外部
    messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    } else {
        // 普通消息的处理
        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${bubbleHtml}</div>`;
    }
} else {
                messageContainer.innerHTML = avatarHtml + bubbleHtml;
}
                
                // 🔥【修复】如果是语音消息，按照renderChatMessages的结构创建，但要保留群聊昵称
                if (message.type === 'voice_message') {
                    // 过滤掉括号中的描述性内容，保留实际说话内容
                    const cleanVoiceContent = message.content.replace(/\([^)]*\)\s*/g, '').trim();
                    const duration = message.duration || Math.max(1, Math.ceil(cleanVoiceContent.length / 8));
                    const durationFormatted = duration < 60 ? `0:${String(duration).padStart(2, '0')}''` : `${Math.floor(duration/60)}:${String(duration%60).padStart(2, '0')}''`;
                    
                    const voiceMessageHTML = `
                        <div class="voice-message-container received">
                            <div class="message-bubble" style="background-color: ${transparentBubbleColor}; color: ${textColor}; position: relative; padding: ${bubblePadding}px;">
                                <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${cleanVoiceContent}">
                                    <div class="voice-wave">
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                    </div>
                                    <div class="voice-duration">${durationFormatted}</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                </div>
                            </div>
                            <div class="voice-text-content">${cleanVoiceContent}</div>
                        </div>
                    `;
                    
                    // 🔥【修复】保留群聊昵称显示
                    if (isGroup && group && displayName !== '群成员') {
                        const senderNameHtml = `<div class="sender-name">${displayName}</div>`;
                        messageContainer.innerHTML = avatarHtml + `<div class="bubble-wrapper">${senderNameHtml}${voiceMessageHTML}</div>`;
                    } else {
                    messageContainer.innerHTML = avatarHtml + voiceMessageHTML;
                    }
                }
            } else {
                // 用户消息
                let myDisplayAvatar = chatSettings.myChatAvatar;
                
                if (!myDisplayAvatar && chatSettings.selectedIdentityId) {
                    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                    if (selectedPersona && selectedPersona.avatarUrl) {
                        myDisplayAvatar = selectedPersona.avatarUrl;
                    }
                }
                
                const myBubbleColor = chatSettings.myBubbleColor || '#007AFF';
                const myBubbleOpacity = chatSettings.myBubbleOpacity || '1';
                const myTextColor = isLightColor(myBubbleColor) ? '#333' : '#fff';
                const myBubblePadding = chatSettings.bubblePadding || '12';
                
                const transparentMyBubbleColor = convertColorWithOpacity(myBubbleColor, myBubbleOpacity);
                
                let myBubbleHtml = '';
                if (message.type === 'voice') {
                    const duration = message.duration || Math.max(1, Math.ceil(message.content.length / 8));
                    
                    myBubbleHtml = `
                        <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                            <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                <div class="voice-wave">
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                    <div class="wave-bar"></div>
                                </div>
                                <div class="voice-duration">${duration}"</div>
                            ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'location') {
                    // 位置消息
                    myBubbleHtml = `
                        <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                            <div class="location-title">${message.locationName}</div>
                            <div class="location-card-map">
                                ${generateRealisticMapHTML()}
                            </div>
                        </div>
                    `;
                } else if (message.type === 'transfer') {
                    // 用户转账消息
                    let cardClass = '';
                    let statusHtml = '';
                    
                    if (message.status === 'accepted') {
                        statusHtml = `<div class="transfer-status">对方已收款</div>`;
                        cardClass = 'accepted';
                    } else if (message.status === 'rejected') {
                        statusHtml = `<div class="transfer-status">对方已退回</div>`;
                        cardClass = 'rejected';
                    }
                    
                    myBubbleHtml = `
                        <div class="transfer-message-container sent">
                            <div class="transfer-card ${cardClass}" data-transfer-id="${message.timestamp}">
                                <div class="transfer-title">💕 你发起的转账</div>
                                <div class="transfer-amount">¥ ${Number(message.amount).toFixed(2)}</div>
                                <div class="transfer-note">${message.note || '转账'}</div>
                                ${statusHtml}
                            </div>
                        </div>
                    `;
                } else {
                    // 🔥【修复】处理多模态消息或普通文本消息 (第三个渲染函数版本)
                    let messageContentStr = '';
                    if (Array.isArray(message.content)) {
                        // 新的多模态格式
                        const textPart = message.content.find(p => p.type === 'text');
                        const imagePart = message.content.find(p => p.type === 'image_url');
                        
                        messageContentStr = renderMentionText(textPart?.text || '');
                        
                        // 如果有图片，添加图片显示
                        if (imagePart?.image_url?.url) {
                            if (messageContentStr) {
                                messageContentStr += '<br>';
                            }
                            messageContentStr += `<img src="${imagePart.image_url.url}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${imagePart.image_url.url}')">`;
                        }
                    } else {
                        // 普通文本消息或旧格式
                        let baseContent = message.content;
                        
                        // 如果有引用消息，在内容前添加引用显示
                        if (message.replyTo) {
                            messageContentStr = generateReplyHTML(message.replyTo) + renderMentionText(baseContent);
                        } else {
                            messageContentStr = renderMentionText(baseContent);
                        }
                    }
                    
                    myBubbleHtml = `
                    <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                        ${messageContentStr}
                        ${message.image && !Array.isArray(message.content) ? `<img src="${message.image}" class="${message.isEmoji ? 'message-emoji' : 'message-image'}" onclick="showImage('${message.image}')">` : ''}
                    </div>
                `;
                }
                
                let myAvatarHtml = '';
                if (!chatSettings.hideAvatars) {
                    myAvatarHtml = `
                        <div class="message-avatar" style="background-color: #007AFF; ${myDisplayAvatar ? `background-image: url(${myDisplayAvatar}); background-size: cover; background-position: center;` : ''}">
                            ${myDisplayAvatar ? '' : '<i class="fas fa-user"></i>'}
                        </div>
                    `;
                }
                
                messageContainer.innerHTML = myBubbleHtml + myAvatarHtml;
                
                // 如果是语音消息，按照renderChatMessages的结构创建
                if (message.type === 'voice') {
                    // 创建完整的语音消息HTML，和renderChatMessages保持一致
                    const voiceMessageHTML = `
                        <div class="voice-message-container sent">
                            <div class="message-bubble" style="background-color: ${transparentMyBubbleColor}; color: ${myTextColor}; position: relative; padding: ${myBubblePadding}px;">
                                <div class="voice-message" onclick="toggleVoiceText(this)" data-text="${message.content}">
                                    <div class="voice-wave">
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                        <div class="wave-bar"></div>
                                    </div>
                                    <div class="voice-duration">${message.duration || Math.max(1, Math.ceil(message.content.length / 8))}"</div>
                                    ${message.edited ? `<div class="message-edited-indicator">已编辑</div>` : ""}
                                </div>
                            </div>
                            <div class="voice-text-content">${message.content}</div>
                        </div>
                    `;
                    
                    messageContainer.innerHTML = voiceMessageHTML + myAvatarHtml;
                }
                
                // 如果是位置消息，按照renderChatMessages的结构创建
                if (message.type === 'location') {
                    // 创建完整的位置消息HTML，确保不被包装在气泡中
                    const locationMessageHTML = `
                        <div class="location-card" onclick="showLocationDetail('${message.locationName}')">
                            <div class="location-title">${message.locationName}</div>
                            <div class="location-card-map">
                                ${generateRealisticMapHTML()}
                            </div>
                        </div>
                    `;
                    
                    messageContainer.innerHTML = locationMessageHTML + myAvatarHtml;
                }
            }
            
            // 添加滑入动画效果 - 简单自然的滑入
            messageContainer.style.opacity = '0';
            messageContainer.style.transform = 'translateY(20px)';
            
            messagesContainer.insertBefore(messageContainer, typingIndicator);
            
            // 触发滑入动画
            requestAnimationFrame(() => {
                messageContainer.classList.add('message-slide-in');
            });
            
            // 添加长按监听器
            addMessageLongPressListener(messageContainer, message.id);
            
            // 添加右键菜单功能
            const bubble = messageContainer.querySelector('.message-bubble');
            if (bubble) {
                bubble.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMessageMenu(message.id, e);
                });
                
                bubble.onclick = (e) => {
                    if (e.target.tagName === 'IMG' && e.target.classList.contains('message-image')) {
                        showImage(e.target.src);
                    }
                };
            }
            
            // 🔥【新增】如果是AI消息，调整心率
            if (message.sender === 'received' && typeof message.content === 'string') {
                adjustHeartrateForMessage(message.content, false);
            }
            
            // 滚动到底部
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }
        
        // 将颜色和透明度转换为rgba格式
        function convertColorWithOpacity(color, opacity) {
            // 如果颜色已经是rgba格式，直接返回
            if (color.startsWith('rgba')) {
                return color;
            }
            
            // 如果是十六进制颜色，转换为rgba
            if (color.startsWith('#')) {
                const hex = color.slice(1);
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                return `rgba(${r}, ${g}, ${b}, ${opacity})`;
            }
            
            // 如果是rgb格式，转换为rgba
            if (color.startsWith('rgb(')) {
                const rgbValues = color.match(/\d+/g);
                return `rgba(${rgbValues[0]}, ${rgbValues[1]}, ${rgbValues[2]}, ${opacity})`;
            }
            
            // 如果是颜色名称，尝试转换（简单实现）
            const colorMap = {
                'red': '255, 0, 0',
                'green': '0, 128, 0',
                'blue': '0, 0, 255',
                'white': '255, 255, 255',
                'black': '0, 0, 0',
                'gray': '128, 128, 128',
                'yellow': '255, 255, 0',
                'cyan': '0, 255, 255',
                'magenta': '255, 0, 255'
            };
            
            if (colorMap[color.toLowerCase()]) {
                return `rgba(${colorMap[color.toLowerCase()]}, ${opacity})`;
            }
            
            // 如果无法识别，返回原色加透明度（作为备用）
            return color;
        }

        // 字体大小设置功能
        function changeFontSize(size) {
            const fontSize = parseInt(size);
            
            // 更新预览文字
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('font-size-value');
            
            if (preview) {
                preview.style.fontSize = fontSize + 'px';
            }
            
            if (valueDisplay) {
                valueDisplay.textContent = fontSize + 'px';
            }
            
            // 创建或更新全局字体大小CSS变量
            document.documentElement.style.setProperty('--global-font-size', fontSize + 'px');
            
            // 应用到聊天消息
            applyFontSizeToMessages(fontSize);
            
            // 应用到社交动态
            applyFontSizeToMoments(fontSize);
            
            // 如果当前有聊天角色，重新渲染消息以确保新字体大小生效
            if (currentChatCharacter && typeof renderChatMessages === 'function') {
                setTimeout(() => {
                    renderChatMessages(currentChatCharacter.id);
                }, 100);
            }
            
            // 保存设置
            localStorage.setItem('globalFontSize', fontSize);
            
            // 显示成功提示
            showToast('字号设置已保存并应用！', 'success');
        }
        
        // 字距设置功能
        function changeLetterSpacing(spacing) {
            const letterSpacing = parseFloat(spacing);
            
            // 更新预览文字
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('letter-spacing-value');
            
            if (preview) {
                preview.style.letterSpacing = letterSpacing + 'px';
            }
            
            if (valueDisplay) {
                // 根据数值显示对应的文字描述
                let description;
                if (letterSpacing < -0.2) {
                    description = '很紧凑';
                } else if (letterSpacing < 0.2) {
                    description = '标准';
                } else if (letterSpacing < 0.8) {
                    description = '舒适';
                } else if (letterSpacing < 1.5) {
                    description = '宽松';
                } else {
                    description = '很宽松';
                }
                valueDisplay.textContent = `${description} (${letterSpacing}px)`;
            }
            
            // 创建或更新全局字距CSS变量
            document.documentElement.style.setProperty('--global-letter-spacing', letterSpacing + 'px');
            
            // 应用到聊天消息
            applyLetterSpacingToMessages(letterSpacing);
            
            // 应用到社交动态
            applyLetterSpacingToMoments(letterSpacing);
            
            // 如果当前有聊天角色，重新渲染消息以确保新字距生效
            if (currentChatCharacter && typeof renderChatMessages === 'function') {
                setTimeout(() => {
                    renderChatMessages(currentChatCharacter.id);
                }, 100);
            }
            
            // 保存设置
            localStorage.setItem('globalLetterSpacing', letterSpacing);
            
            // 显示成功提示
            showToast('字距设置已保存并应用！', 'success');
        }
        
        function applyFontSizeToMessages(fontSize) {
            // 应用到所有聊天消息，使用!important强制覆盖内联样式
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.style.setProperty('font-size', fontSize + 'px', 'important');
            });
            
            // 应用到聊天输入框
            const chatInput = document.getElementById('api-chat-input');
            if (chatInput) {
                chatInput.style.fontSize = fontSize + 'px';
            }
        }
        
        function applyFontSizeToMoments(fontSize) {
            // 应用到微博动态内容
            const postContents = document.querySelectorAll('.post-content');
            postContents.forEach(content => {
                content.style.fontSize = fontSize + 'px';
            });
            
            // 应用到微博输入框
            const weiboTextarea = document.getElementById('weibo-text');
            if (weiboTextarea) {
                weiboTextarea.style.fontSize = fontSize + 'px';
            }
        }
        
        function applyLetterSpacingToMessages(letterSpacing) {
            // 应用到所有聊天消息
            const messageBubbles = document.querySelectorAll('.message-bubble');
            messageBubbles.forEach(bubble => {
                bubble.style.setProperty('letter-spacing', letterSpacing + 'px', 'important');
            });
            
            // 应用到聊天输入框
            const chatInput = document.getElementById('api-chat-input');
            if (chatInput) {
                chatInput.style.letterSpacing = letterSpacing + 'px';
            }
        }
        
        function applyLetterSpacingToMoments(letterSpacing) {
            // 应用到微博动态内容
            const postContents = document.querySelectorAll('.post-content');
            postContents.forEach(content => {
                content.style.letterSpacing = letterSpacing + 'px';
            });
            
            // 应用到微博输入框
            const weiboTextarea = document.getElementById('weibo-text');
            if (weiboTextarea) {
                weiboTextarea.style.letterSpacing = letterSpacing + 'px';
            }
        }
        
        function toggleAutoScale() {
            const toggle = document.getElementById('auto-scale-toggle');
            const isEnabled = toggle.checked;
            
            // 保存自动缩放设置
            localStorage.setItem('autoScaleFont', isEnabled);
            
            if (isEnabled) {
                // 根据屏幕尺寸自动调整字体
                autoAdjustFontSize();
                showToast('字体自动缩放已开启！', 'success');
            } else {
                showToast('字体自动缩放已关闭！', 'success');
            }
        }
        
        function autoAdjustFontSize() {
            const phoneScreen = document.getElementById('phone-screen');
            if (!phoneScreen) return;
            
            const screenWidth = parseInt(phoneScreen.style.width) || 350;
            
            // 根据屏幕宽度计算推荐字体大小
            let recommendedSize = 15; // 默认大小
            
            if (screenWidth <= 320) {
                recommendedSize = 13; // 小屏幕用小字体
            } else if (screenWidth <= 350) {
                recommendedSize = 14;
            } else if (screenWidth <= 375) {
                recommendedSize = 15;
            } else if (screenWidth <= 390) {
                recommendedSize = 16;
            } else {
                recommendedSize = 17; // 大屏幕用大字体
            }
            
            // 更新滑块和应用字体大小
            const slider = document.getElementById('font-size-slider');
            if (slider) {
                slider.value = recommendedSize;
                changeFontSize(recommendedSize);
            }
        }
        
        function loadFontSizeSettings() {
            // 加载字体大小设置
            const savedSize = localStorage.getItem('globalFontSize');
            const fontSize = savedSize ? parseInt(savedSize) : 15;
            
            const slider = document.getElementById('font-size-slider');
            const preview = document.getElementById('font-size-preview');
            const valueDisplay = document.getElementById('font-size-value');
            
            if (slider) {
                slider.value = fontSize;
            }
            
            if (preview) {
                preview.style.fontSize = fontSize + 'px';
            }
            
            if (valueDisplay) {
                valueDisplay.textContent = fontSize + 'px';
            }
            
            // 应用字体大小
            document.documentElement.style.setProperty('--global-font-size', fontSize + 'px');
            
            // 加载字距设置
            const savedSpacing = localStorage.getItem('globalLetterSpacing');
            const letterSpacing = savedSpacing ? parseFloat(savedSpacing) : 0;
            
            const spacingSlider = document.getElementById('letter-spacing-slider');
            const spacingValueDisplay = document.getElementById('letter-spacing-value');
            
            if (spacingSlider) {
                spacingSlider.value = letterSpacing;
            }
            
            if (preview) {
                preview.style.letterSpacing = letterSpacing + 'px';
            }
            
            if (spacingValueDisplay) {
                // 根据数值显示对应的文字描述
                let description;
                if (letterSpacing < -0.2) {
                    description = '很紧凑';
                } else if (letterSpacing < 0.2) {
                    description = '标准';
                } else if (letterSpacing < 0.8) {
                    description = '舒适';
                } else if (letterSpacing < 1.5) {
                    description = '宽松';
                } else {
                    description = '很宽松';
                }
                spacingValueDisplay.textContent = `${description} (${letterSpacing}px)`;
            }
            
            // 应用字距
            document.documentElement.style.setProperty('--global-letter-spacing', letterSpacing + 'px');
            
            // 延迟应用，确保DOM元素已经加载
            setTimeout(() => {
                applyFontSizeToMessages(fontSize);
                applyFontSizeToMoments(fontSize);
                applyLetterSpacingToMessages(letterSpacing);
                applyLetterSpacingToMoments(letterSpacing);
            }, 500);
            
            // 加载自动缩放设置
            const autoScale = localStorage.getItem('autoScaleFont');
            const autoScaleToggle = document.getElementById('auto-scale-toggle');
            if (autoScaleToggle) {
                autoScaleToggle.checked = autoScale === 'true';
            }
        }



        // 工具栏功能
        function triggerVoiceMessage() {
            showToast('语音功能开发中...', 'info');
            // 这里可以添加语音录制功能
        }

        // 聊天界面拍照功能 - 文字描述图片发送给AI
        async function openCamera() {
            if (!currentChatCharacter) {
                showToast('请先选择一个聊天对象', 'error');
                return;
            }
            
            const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片：");
            if (description && description.trim()) {
                const msg = {
                    id: Date.now().toString(),
                    sender: 'sent',
                    type: 'user_photo',
                    content: description.trim(),
                    timestamp: Date.now(),
                    photoDescription: description.trim() // 保存原始描述用于点击查看
                };
                
                // 添加到聊天记录
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                chatMessages[currentChatCharacter.id].push(msg);
                await saveChatMessages();
                
                // 刷新界面
                renderChatMessages(currentChatCharacter.id);
                renderMessageList();
                
                showToast('照片已发送', 'success');
            }
        }

        function openTransfer() {
            // 检查是否有当前聊天角色
            if (!currentChatCharacter) {
                showToast('请先选择聊天对象', 'warning');
                return;
            }
            
            // 显示转账对话框
            document.getElementById('transfer-modal').classList.add('visible');
        }

        // 通话状态变量
        let isInCall = false;
        let callTimer = null;
        let callStartTime = null;
        let callDuration = 0;
        let isMuted = false;
        let isSpeakerOn = false;
        let currentCallCharacter = null;
        
        // 生成消息ID函数
        function generateMessageId() {
            return Date.now().toString() + Math.floor(Math.random() * 1000).toString();
        }
        
        // 添加消息到聊天记录
        function addMessageToChat(message) {
            if (!currentChatCharacter) return;
            
            const characterId = currentChatCharacter.id;
            if (!chatMessages[characterId]) {
                chatMessages[characterId] = [];
            }
            
            chatMessages[characterId].push(message);
            saveChatMessages();
            
            // 更新聊天界面
            renderChatMessages(characterId);
        }

        function makeCall() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'error');
                return;
            }
            
            // 检查角色主动拨打电话开关，用户主动拨打时不受此限制
            const currentChatSettings = getCurrentChatSettings();
            console.log('📞 用户主动拨打电话，开关状态:', currentChatSettings.aiCallEnabled);
            
            currentCallCharacter = currentChatCharacter;
            
            // 设置通话界面
            const avatarSrc = currentCallCharacter.avatar || currentCallCharacter.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            document.getElementById('call-avatar-img').src = avatarSrc;
            document.getElementById('call-name').textContent = currentCallCharacter.name;
            document.getElementById('call-status').textContent = '正在通话中...';
            document.getElementById('call-timer').textContent = '00:00';
            
            // 清空通话消息容器
            document.getElementById('call-message-container').innerHTML = '';
            
            // 显示通话界面
            showApp('phone-call-screen');
            
            // 开始计时
            startCallTimer();
            
            // 设置通话状态
            isInCall = true;
            
            // 发送系统消息到聊天记录
            const callStartMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[语音通话] 与${currentCallCharacter.name}的通话已开始`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'outgoing',
                callStatus: 'started'
            };
            
            addMessageToChat(callStartMessage);
            
            // 用户主动拨打电话时不自动添加角色回应，等待用户先说话
            // 设置标志，表明这是用户主动拨打的电话
            window.isUserInitiatedCall = true;
        }
        
        // 角色主动拨打电话
        async function initiateAICall(character, callReason) {
            if (isInCall) return; // 如果已经在通话中，不再发起
            
            currentCallCharacter = character;
            
            // 🔥【恢复】先生成角色的开场白，再显示来电界面
            let characterGreeting = '';
            try {
                const prompt = `你是${character.name}，刚刚决定给用户打电话。

请生成一句简短自然的开场白，说明你为什么要打这个电话：
- 要符合你的性格特点
- 像真实通话开始时的自然表达
- 1句话即可，不要超过20字
- 直接说话，不要任何格式标记

例如：
- "我想和你聊聊今天的事情"
- "有个好消息想告诉你"
- "想听听你的声音"

请只回复开场白内容：`;

                const response = await callChatAPI(prompt, character);
                
                // 🔥【关键修复】使用parseAiResponse解析开场白
                const parsedMessages = parseAiResponse(response);
                console.log('🔔 开场白AI回复解析结果:', parsedMessages);
                
                if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
                    // 找到第一条纯文本消息
                    const firstTextMessage = parsedMessages.find(msg => typeof msg === 'string');
                    if (firstTextMessage) {
                        characterGreeting = firstTextMessage.trim();
                    } else {
                        // 如果没有纯文本，尝试提取对象中的内容
                        const firstMessage = parsedMessages[0];
                        if (typeof firstMessage === 'object' && firstMessage.content) {
                            characterGreeting = firstMessage.content.trim();
                        }
                    }
                } else if (typeof response === 'string') {
                    // 备用：如果解析失败，清理原始字符串
                    characterGreeting = cleanCallResponse(response).trim();
                }
                
                if (!characterGreeting || characterGreeting.length > 30) {
                    characterGreeting = callReason || '想和你通话...';
                }
            } catch (error) {
                console.error('生成角色开场白失败:', error);
                characterGreeting = callReason || '想和你通话...';
            }
            
            // 设置来电显示界面
            const avatarSrc = character.avatar || character.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            document.getElementById('incoming-call-avatar').src = avatarSrc;
            document.getElementById('incoming-call-name').textContent = character.name;
            document.getElementById('incoming-call-text').textContent = characterGreeting;
            
            // 🔥【保存开场白供接听后使用】
            window.aiCallGreeting = characterGreeting;
            
            // 添加振铃动画
            document.getElementById('incoming-call-avatar').classList.add('ringing-animation');
            
            // 显示来电界面
            showApp('incoming-call-screen');
            
            // 播放来电铃声（如果需要）
            // playRingtone();
            
            // 发送系统消息到聊天记录
            const incomingCallMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[语音通话] ${character.name}正在呼叫你`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'ringing'
            };
            
            addMessageToChat(incomingCallMessage);
            
            // 如果30秒内没有接听，自动挂断
            setTimeout(() => {
                if (document.getElementById('incoming-call-screen').style.display !== 'none') {
                    rejectCall();
                }
            }, 30000);
        }
        
        // 接受来电
        function acceptCall() {
            // 停止振铃动画
            document.getElementById('incoming-call-avatar').classList.remove('ringing-animation');
            
            // 隐藏来电界面
            hideApp('incoming-call-screen');
            
            // 设置通话界面
            const avatarSrc = currentCallCharacter.avatar || currentCallCharacter.avatarUrl || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="lightgray"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="gray">头像</text></svg>';
            document.getElementById('call-avatar-img').src = avatarSrc;
            document.getElementById('call-name').textContent = currentCallCharacter.name;
            document.getElementById('call-status').textContent = '正在通话中...';
            document.getElementById('call-timer').textContent = '00:00';
            
            // 清空通话消息容器
            document.getElementById('call-message-container').innerHTML = '';
            
            // 显示通话界面
            showApp('phone-call-screen');
            
            // 开始计时
            startCallTimer();
            
            // 设置通话状态
            isInCall = true;
            
            // 发送系统消息到聊天记录
            const callAcceptedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[语音通话] 已接听${currentCallCharacter.name}的来电`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'accepted'
            };
            
            addMessageToChat(callAcceptedMessage);
            
            // 🔥【修复】使用AI生成的开场白或默认问候
            setTimeout(() => {
                let initialResponse = window.aiCallGreeting || getRandomCallGreeting(currentCallCharacter.name);
                addCallMessage(initialResponse, 'received');
                // 清理开场白缓存
                window.aiCallGreeting = null;
            }, 1000);
        }
        
        // 拒绝来电
        function rejectCall() {
            // 停止振铃动画
            document.getElementById('incoming-call-avatar').classList.remove('ringing-animation');
            
            // 隐藏来电界面
            hideApp('incoming-call-screen');
            
            // 发送系统消息到聊天记录
            const callRejectedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[语音通话] 已拒绝${currentCallCharacter.name}的来电`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'incoming',
                callStatus: 'rejected'
            };
            
            addMessageToChat(callRejectedMessage);
            
            currentCallCharacter = null;
        }
        
        // 结束通话
        function endCall() {
            if (!isInCall) return;
            
            // 停止计时
            stopCallTimer();
            
            // 隐藏通话界面
            hideApp('phone-call-screen');
            
            // 返回聊天界面
            showApp('api-chat-screen');
            
            // 发送系统消息到聊天记录
            const formattedDuration = formatCallDuration(callDuration);
            const callEndedMessage = {
                id: generateMessageId(),
                sender: 'system',
                content: `[语音通话] 与${currentCallCharacter.name}的通话已结束`,
                timestamp: Date.now(),
                type: 'call_record',
                callType: 'ended',
                callStatus: 'completed',
                duration: formattedDuration
            };
            
            addMessageToChat(callEndedMessage);
            
            // 重置通话状态
            isInCall = false;
            isMuted = false;
            isSpeakerOn = false;
            
            currentCallCharacter = null;
        }
        
        // 静音/取消静音
        function toggleMute() {
            isMuted = !isMuted;
            const muteBtn = document.getElementById('mute-btn');
            
            if (isMuted) {
                muteBtn.classList.add('muted');
                muteBtn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
                showToast('已静音', 'info');
            } else {
                muteBtn.classList.remove('muted');
                muteBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                showToast('已取消静音', 'info');
            }
        }
        
        // 扬声器开关
        function toggleSpeaker() {
            isSpeakerOn = !isSpeakerOn;
            const speakerBtn = document.getElementById('speaker-btn');
            
            if (isSpeakerOn) {
                speakerBtn.classList.add('active');
                showToast('已开启扬声器', 'info');
            } else {
                speakerBtn.classList.remove('active');
                showToast('已关闭扬声器', 'info');
            }
        }
        
        // 开始通话计时器
        function startCallTimer() {
            callStartTime = new Date();
            callDuration = 0;
            
            callTimer = setInterval(() => {
                callDuration = Math.floor((new Date() - callStartTime) / 1000);
                document.getElementById('call-timer').textContent = formatCallDuration(callDuration);
            }, 1000);
        }
        
        // 停止通话计时器
        function stopCallTimer() {
            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }
        }
        
        // 格式化通话时长
        function formatCallDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        // 在通话界面发送消息
        function sendCallMessage() {
            const input = document.getElementById('call-input');
            if (!input) {
                console.error('找不到通话输入框元素');
                return;
            }
            
            const message = input.value.trim();
            
            if (!message) return;
            
            // 添加用户消息到通话界面
            addCallMessage(message, 'sent');
            
            // 清空输入框
            input.value = '';
            
            // 显示AI正在说话的指示器
            const typingIndicator = showCallTypingIndicator();
            
            // 根据通话类型决定是否回复
            if (currentCallCharacter) {
                setTimeout(async () => {
                    try {
                        // 🔥【修复】构建更好的语音通话提示词
                        const prompt = `你是${currentCallCharacter.name}，正在与用户进行语音通话。
用户刚说："${message}"

请用简短自然的口语方式回复，就像真实的电话对话一样：
- 直接说话，不要任何描述性文字
- 保持自然的语音对话风格
- 回复要简洁，1-2句话即可
- 符合你的性格设定

请只回复对话内容，不要JSON格式，不要其他格式：`;
                        
                        try {
                            const response = await callChatAPI(prompt, currentCallCharacter);
                            
                            // 移除输入指示器
                            hideCallTypingIndicator(typingIndicator);
                            
                            // 🔥【关键修复】使用parseAiResponse解析回复，显示所有文本消息
                            const parsedMessages = parseAiResponse(response);
                            console.log('🔔 通话AI回复解析结果:', parsedMessages);
                            
                            let hasValidMessage = false;
                            if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
                                // 遍历所有消息，显示每一条文本消息
                                for (const msg of parsedMessages) {
                                    let replyText = '';
                                    if (typeof msg === 'string') {
                                        replyText = msg.trim();
                                    } else if (typeof msg === 'object' && msg.content) {
                                        replyText = msg.content.trim();
                                    }
                                    
                                    if (replyText) {
                                        addCallMessage(replyText, 'received');
                                        hasValidMessage = true;
                                        // 添加短暂延迟，让多条消息分开显示
                                        await new Promise(resolve => setTimeout(resolve, 300));
                                    }
                                }
                            }
                            
                            // 如果没有有效消息，使用备用回复
                            if (!hasValidMessage) {
                                if (typeof response === 'string') {
                                    const cleanedText = cleanCallResponse(response);
                                    if (cleanedText) {
                                        addCallMessage(cleanedText, 'received');
                                    } else {
                                        addCallMessage(getRandomCallResponse(), 'received');
                                    }
                                } else {
                                    addCallMessage(getRandomCallResponse(), 'received');
                                }
                            }
                            
                        } catch (error) {
                            console.error('获取AI回复失败:', error);
                            hideCallTypingIndicator(typingIndicator);
                            addCallMessage(getRandomCallResponse(), 'received');
                        }
                        
                    } catch (error) {
                        console.error('通话回复错误:', error);
                        hideCallTypingIndicator(typingIndicator);
                        addCallMessage('我明白了', 'received');
                    }
                }, 1000 + Math.random() * 1000);
            }
        }
        
        // 添加消息到通话界面
        function addCallMessage(message, type) {
            const container = document.getElementById('call-message-container');
            const messageElement = document.createElement('div');
            messageElement.className = `call-message ${type}`;
            messageElement.textContent = message;
            
            container.appendChild(messageElement);
            container.scrollTop = container.scrollHeight;
            
            // 🔥【修复】同时添加到聊天记录，但标记为通话消息
            if (currentChatCharacter && currentChatCharacter.id) {
                const callMessage = {
                    id: generateMessageId(),
                    sender: type === 'sent' ? 'sent' : 'received',  // 修复：使用正确的sender格式
                    content: message,
                    timestamp: Date.now(),
                    isCallMessage: true,
                    type: 'call_message'  // 添加特殊类型标记
                };
                
                if (!chatMessages[currentChatCharacter.id]) {
                    chatMessages[currentChatCharacter.id] = [];
                }
                
                chatMessages[currentChatCharacter.id].push(callMessage);
                saveChatMessages();
            }
        }

        // 🔥【新增】显示AI正在说话的指示器
        function showCallTypingIndicator() {
            const container = document.getElementById('call-message-container');
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'call-typing-indicator';
            typingIndicator.innerHTML = `
                <div class="call-typing-dots">
                    <div class="call-typing-dot"></div>
                    <div class="call-typing-dot"></div>
                    <div class="call-typing-dot"></div>
                </div>
            `;
            
            container.appendChild(typingIndicator);
            container.scrollTop = container.scrollHeight;
            
            return typingIndicator;
        }

        // 🔥【新增】隐藏AI正在说话的指示器
        function hideCallTypingIndicator(indicator) {
            if (indicator && indicator.parentNode) {
                indicator.parentNode.removeChild(indicator);
            }
        }

        // 🔥【简化】清理通话回复文本 - 因为已经用parseAiResponse处理JSON格式
        function cleanCallResponse(text) {
            if (!text) return '';
            
            console.log('🧹 原始文本:', text);
            
            // 基础清理：移除多余空格和换行
            text = text.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
            
            // 移除常见的描述性前缀
            text = text.replace(/^(角色说|我说|回复|答案|回答)[:：]\s*/i, '');
            
            // 移除括号中的描述性内容
            text = text.replace(/\([^)]*\)/g, '');
            text = text.replace(/【[^】]*】/g, '');
            text = text.replace(/\[[^\]]*\]/g, '');
            
            // 如果文本以标点符号开头，移除它
            text = text.replace(/^[，。！？；：,.!?;:\s]*/, '');
            
            console.log('🧹 清理后文本:', text);
            
            // 验证清理结果
            if (!text || text.length < 2) {
                console.log('🧹 文本无效，使用备用回复');
                return getRandomCallResponse();
            }
            
            // 如果文本太长，截取前面部分
            if (text.length > 60) {
                text = text.substring(0, 60) + '...';
            }
            
            return text;
        }
        
        // 随机通话问候语
        function getRandomCallGreeting(characterName) {
            const greetings = [
                `你好，我是${characterName}，很高兴能和你通话。`,
                `嗨，终于能听到你的声音了！`,
                `喂，你好啊，听得到我说话吗？`,
                `你好，谢谢你接我电话。`,
                `嗨，很高兴能和你通话。`
            ];
            
            return greetings[Math.floor(Math.random() * greetings.length)];
        }
        
        // 随机通话回复（备用）
        function getRandomCallResponse() {
            const responses = [
                '嗯，我明白了。',
                '好的，我知道了。',
                '是的，你说得对。',
                '我觉得这个想法不错。',
                '嗯，有道理。',
                '哦，真的吗？',
                '我明白你的意思了。',
                '这样啊，我懂了。',
                '确实如此。',
                '我同意你的看法。'
            ];
            
            return responses[Math.floor(Math.random() * responses.length)];
        }
        
        // 检测是否应该触发AI主动拨打电话
        function checkForAICallTrigger(userMessage, aiResponse) {
            // 获取当前聊天设置
            const currentChatSettings = getCurrentChatSettings();
            
            // 如果未启用AI主动拨打电话功能，直接返回
            if (!currentChatSettings.aiCallEnabled) {
                console.log('🔔 AI主动拨打电话功能未开启，角色不会主动拨打电话');
                return false;
            }
            
            // 如果已经在通话中，不再触发
            if (isInCall) {
                console.log('🔔 当前正在通话中，不触发新的来电');
                return false;
            }
            
            // 确保有当前聊天角色
            if (!currentChatCharacter) {
                console.log('🔔 没有当前聊天角色，无法触发来电');
                return false;
            }
            
            // 通话关键词
            const callKeywords = ['通话', '电话', '视频', '语音', '打给你', '想听', '想看', '聊天', '说话', '测试', '试试', '打电话'];
            
            // 检查用户消息和AI回复中是否包含通话关键词
            const userMessageHasCallKeyword = callKeywords.some(keyword => userMessage.includes(keyword));
            const aiResponseHasCallKeyword = callKeywords.some(keyword => aiResponse.includes(keyword));
            
            console.log('🔔 检查AI主动拨打触发条件:', {
                userMessage,
                aiResponse,
                userHasKeyword: userMessageHasCallKeyword,
                aiHasKeyword: aiResponseHasCallKeyword,
                aiCallEnabled: currentChatSettings.aiCallEnabled
            });
            
            // 根据关键词出现情况和角色性格决定触发概率
            let triggerProbability = 0;
            if (userMessageHasCallKeyword) {
                // 基础概率：用户提到通话关键词时20%
                triggerProbability = 0.2;
                
                // 如果AI回复也包含通话关键词，大幅提升概率到60%
                if (aiResponseHasCallKeyword) {
                    triggerProbability = 0.6;
                }
                
                // 根据角色性格调整概率（如果角色设定中包含主动、外向等特质）
                const characterBio = currentChatCharacter.bio || '';
                if (characterBio.includes('主动') || characterBio.includes('外向') || characterBio.includes('热情')) {
                    triggerProbability += 0.1;
                }
                
                // 限制最大概率为70%
                triggerProbability = Math.min(triggerProbability, 0.7);
            }
            
            // 增加随机因素：即使没有关键词，也有极小概率(2%)触发，模拟真实的突然来电
            if (triggerProbability === 0 && Math.random() < 0.02) {
                triggerProbability = 0.02;
                console.log('🔔 随机触发AI来电（模拟突然想到要打电话）');
            }
            
            if (triggerProbability > 0 && Math.random() < triggerProbability) {
                console.log('🔔 AI主动拨打电话被触发！概率:', triggerProbability);
                
                // 从AI回复中提取一个合理的通话理由
                let callReason = extractCallReason(aiResponse);
                
                // 延迟2-5秒后触发来电
                const delay = 2000 + Math.random() * 3000;
                console.log(`🔔 将在${Math.round(delay/1000)}秒后发起来电，理由: ${callReason}`);
                
                setTimeout(() => {
                    console.log('🔔 开始发起AI来电');
                    initiateAICall(currentChatCharacter, callReason);
                }, delay);
                
                return true;
            } else {
                console.log('🔔 AI主动拨打未触发，概率:', triggerProbability);
            }
            
            return false;
        }
        
        // 从AI回复中提取通话理由
        function extractCallReason(aiResponse) {
            // 默认理由
            let defaultReasons = [
                '想和你聊聊天',
                '有事情想告诉你',
                '想听听你的声音',
                '想和你说说话'
            ];
            
            // 尝试从回复中提取一个合理的句子作为理由
            const sentences = aiResponse.split(/[。！？.!?]/);
            const validSentences = sentences.filter(s => {
                const trimmed = s.trim();
                return trimmed.length > 5 && trimmed.length < 20 && !trimmed.includes('我');
            });
            
            if (validSentences.length > 0) {
                return validSentences[Math.floor(Math.random() * validSentences.length)].trim();
            }
            
            return defaultReasons[Math.floor(Math.random() * defaultReasons.length)];
        }

        function openVideoCall() {
            showToast('视频通话功能开发中...', 'info');
            // 这里可以添加视频通话功能
        }

        function shareLocation() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }
            
            // 重置输入框
            document.getElementById('location-address').value = '';
            document.getElementById('map-location-display').textContent = '请输入位置名称';
            
            // 随机化地图显示
            randomizeMapPosition();
            
            // 加载历史记录
            renderLocationHistory();
            
            // 显示模态框
            document.getElementById('location-modal').style.display = 'flex';
        }

        function hideLocationModal() {
            document.getElementById('location-modal').style.display = 'none';
        }

        function setLocationAddress(address) {
            document.getElementById('location-address').value = address;
            document.getElementById('map-location-display').textContent = address;
            
            // 生成随机坐标
            const lat = (39.8 + Math.random() * 0.4).toFixed(4);
            const lng = (116.2 + Math.random() * 0.4).toFixed(4);
            document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
        }

        function randomizeMapPosition() {
            const marker = document.getElementById('location-marker');
            const buildings = document.querySelectorAll('.building');
            
            // 随机移动标记位置
            const newTop = 20 + Math.random() * 60; // 20% - 80%
            const newLeft = 20 + Math.random() * 60; // 20% - 80%
            marker.style.top = newTop + '%';
            marker.style.left = newLeft + '%';
            
            // 随机移动建筑物
            buildings.forEach(building => {
                const top = Math.random() * 85; // 0% - 85%
                const left = Math.random() * 85; // 0% - 85%
                building.style.top = top + '%';
                building.style.left = left + '%';
            });
            
            // 更新坐标
            const lat = (39.8 + Math.random() * 0.4).toFixed(4);
            const lng = (116.2 + Math.random() * 0.4).toFixed(4);
            document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
        }

        // 生成逼真的地图HTML内容
        function generateRealisticMapHTML() {
            return `
                <div class="map-background"></div>
                <!-- 弯曲河流 -->
                <div class="river" style="top: 5%; left: 60%; width: 20px; height: 3px; transform: rotate(35deg);"></div>
                <div class="river-curve" style="top: 12%; left: 72%; width: 18px; height: 3px; transform: rotate(15deg);"></div>
                <div class="river" style="top: 18%; left: 80%; width: 16px; height: 3px; transform: rotate(-5deg);"></div>
                <div class="river-curve" style="top: 22%; left: 85%; width: 15px; height: 3px; transform: rotate(-25deg);"></div>
                <div class="river" style="top: 55%; left: 2%; width: 22px; height: 3px; transform: rotate(-10deg);"></div>
                <div class="river-curve" style="top: 62%; left: 18%; width: 20px; height: 3px; transform: rotate(8deg);"></div>
                <div class="river" style="top: 68%; left: 32%; width: 18px; height: 3px; transform: rotate(25deg);"></div>
                <!-- 公园绿地 -->
                <div class="park" style="top: 20%; left: 65%; width: 18px; height: 15px;"></div>
                <div class="park" style="top: 45%; left: 10%; width: 22px; height: 18px;"></div>
                <!-- 道路 -->
                <div class="map-roads">
                    <div class="road road-horizontal" style="top: 35%; width: 100%;"></div>
                    <div class="road road-vertical" style="left: 40%; height: 100%;"></div>
                    <div class="road road-horizontal" style="top: 65%; width: 70%; left: 30%;"></div>
                </div>
                <!-- 建筑物 -->
                <div class="map-buildings">
                    <div class="building house" style="top: 15%; left: 20%; width: 12px; height: 10px;"></div>
                    <div class="building office" style="top: 25%; left: 45%; width: 8px; height: 16px;"></div>
                    <div class="building shop" style="top: 50%; left: 50%; width: 14px; height: 8px;"></div>
                    <div class="building house" style="top: 70%; left: 75%; width: 10px; height: 8px;"></div>
                    <div class="building office" style="top: 8%; left: 85%; width: 6px; height: 12px;"></div>
                </div>
                <!-- 树木 -->
                <div class="tree big" style="top: 25%; left: 15%; width: 6px; height: 6px;"></div>
                <div class="tree small" style="top: 55%; left: 25%; width: 4px; height: 4px;"></div>
                <div class="tree big" style="top: 10%; left: 70%; width: 5px; height: 5px;"></div>
                <div class="tree small" style="top: 75%; left: 85%; width: 3px; height: 3px;"></div>
                <div class="tree small" style="top: 40%; left: 80%; width: 4px; height: 4px;"></div>
                <!-- 位置标记 -->
                <div class="map-marker">
                    <div class="marker-pin" style="color: #1890ff;">📍</div>
                </div>
            `;
        }

        // 历史地点管理
        let locationHistory = JSON.parse(localStorage.getItem('locationHistory') || '[]');

        function saveLocationHistory() {
            localStorage.setItem('locationHistory', JSON.stringify(locationHistory));
        }

        function addToLocationHistory(locationName) {
            if (!locationName.trim()) return;
            
            // 移除重复项
            locationHistory = locationHistory.filter(name => name !== locationName);
            // 添加到开头
            locationHistory.unshift(locationName);
            // 限制最多保存10个
            if (locationHistory.length > 10) {
                locationHistory = locationHistory.slice(0, 10);
            }
            
            saveLocationHistory();
            renderLocationHistory();
        }

        function removeFromLocationHistory(locationName) {
            locationHistory = locationHistory.filter(name => name !== locationName);
            saveLocationHistory();
            renderLocationHistory();
        }

        function renderLocationHistory() {
            const container = document.getElementById('location-history-items');
            if (!container) return;

            if (locationHistory.length === 0) {
                container.innerHTML = '<div class="location-history-empty">暂无历史记录</div>';
                return;
            }

            container.innerHTML = locationHistory.map(location => 
                `<div class="location-history-item" data-location="${location}" onclick="setLocationAddress('${location}')">
                    <span class="location-text">${location}</span>
                    <span class="delete-btn" onclick="event.stopPropagation(); confirmDeleteLocation('${location}')" title="删除">×</span>
                </div>`
            ).join('');
        }

        // 长按删除处理
        let touchTimer = null;
        let touchedElement = null;

        function handleLocationTouchStart(event, location) {
            touchedElement = event.target;
            touchTimer = setTimeout(() => {
                confirmDeleteLocation(location);
            }, 800); // 800ms长按
        }

        function handleLocationTouchEnd(event) {
            if (touchTimer) {
                clearTimeout(touchTimer);
                touchTimer = null;
            }
            if (touchedElement) {
                touchedElement.classList.remove('deleting');
                touchedElement = null;
            }
        }

        function confirmDeleteLocation(location) {
            if (touchedElement) {
                touchedElement.classList.add('deleting');
            }
            
            if (confirm(`确定要删除位置"${location}"吗？`)) {
                removeFromLocationHistory(location);
                showToast('位置已删除', 'success');
            } else if (touchedElement) {
                touchedElement.classList.remove('deleting');
            }
        }

        function sendLocationMessage() {
            const address = document.getElementById('location-address').value.trim();
            if (!address) {
                alert('请输入位置名称');
                return;
            }

            // 添加到历史记录
            addToLocationHistory(address);

            // 创建位置消息
            const locationMessage = {
                id: Date.now().toString(),
                sender: 'sent',
                type: 'location',
                locationName: address,
                coordinates: document.querySelector('.map-coordinates').textContent,
                content: `[用户分享了位置信息：${address}，坐标：${document.querySelector('.map-coordinates').textContent}]`,
                timestamp: Date.now()
            };

            console.log('🗺️ 创建位置消息:', locationMessage);
            
            // 🔥【调试】检查消息数据
            if (!locationMessage.locationName || !locationMessage.coordinates) {
                console.error('❌ 位置消息数据不完整:', {
                    locationName: locationMessage.locationName,
                    coordinates: locationMessage.coordinates
                });
                alert('位置信息不完整，请重试');
                return;
            }

            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(locationMessage);

            // 保存到数据库
            saveChatMessages();

            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(locationMessage, currentChatCharacter.id);

            // 设置为待回复消息
            pendingUserMessage = locationMessage;

            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }

            // 更新联系人列表
            renderMessageList();

            // 关闭模态框
            hideLocationModal();

            showToast('位置已分享', 'success');
        }

        // 更新已存在的位置卡片地图
        function updateExistingLocationMaps() {
            const locationMaps = document.querySelectorAll('.location-card-map');
            locationMaps.forEach(mapElement => {
                // 检查是否需要更新（没有新的地图元素）
                if (!mapElement.querySelector('.river')) {
                    mapElement.innerHTML = generateRealisticMapHTML();
                }
            });
        }

        // 监听位置输入框的变化
        document.addEventListener('DOMContentLoaded', function() {
            const locationInput = document.getElementById('location-address');
            if (locationInput) {
                locationInput.addEventListener('input', function() {
                    const value = this.value.trim();
                    if (value) {
                        document.getElementById('map-location-display').textContent = value;
                        
                        // 生成随机坐标
                        const lat = (39.8 + Math.random() * 0.4).toFixed(4);
                        const lng = (116.2 + Math.random() * 0.4).toFixed(4);
                        document.querySelector('.map-coordinates').textContent = `${lng}°E, ${lat}°N`;
                    } else {
                        document.getElementById('map-location-display').textContent = '请输入位置名称';
                    }
                });
            }
            
            // 点击模态框背景关闭
            document.getElementById('location-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('location-modal')) {
                    hideLocationModal();
                }
            });

            // 定期更新现有的位置卡片地图
            setInterval(updateExistingLocationMaps, 1000);
        });

        // 显示位置详情
        function showLocationDetail(locationName) {
            alert(`📍 ${locationName}`);
        }
 
        // 📊 数据管理相关函数
        
        // 计算存储空间使用情况
        async function calculateStorageUsage() {
            try {
                let chatSize = 0, characterSize = 0, settingsSize = 0, emojiSize = 0;

                const [chatData, charData, settingsData, emojiData] = await Promise.all([
                    db.chatMessages.toArray(),
                    db.characters.toArray(), 
                    db.chatSettings.toArray(),
                    db.customEmojis.toArray()
                ]);

                chatSize = JSON.stringify(chatData).length;
                characterSize = JSON.stringify(charData).length;
                settingsSize = JSON.stringify(settingsData).length;
                emojiSize = JSON.stringify(emojiData).length;
                const total = chatSize + characterSize + settingsSize + emojiSize;

                // 更新显示
                const formatBytes = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };

                if (document.getElementById('chat-storage-size')) {
                    document.getElementById('chat-storage-size').textContent = formatBytes(chatSize);
                    document.getElementById('character-storage-size').textContent = formatBytes(characterSize);
                    document.getElementById('settings-storage-size').textContent = formatBytes(settingsSize);
                    document.getElementById('emoji-storage-size').textContent = formatBytes(emojiSize);
                    document.getElementById('total-storage-size').textContent = formatBytes(total);
                }
            } catch (error) {
                console.error('计算存储失败:', error);
            }
        }

        // 导出所有数据
        async function exportAllData() {
            try {
                showToast('正在导出数据...', 'info');
                
                // 🔥【修复】导出所有重要数据表
                const exportData = {
                    version: '2.0', // 更新版本号
                    exportTime: new Date().toISOString(),
                    characters: await db.characters.toArray(),
                    chatMessages: await db.chatMessages.toArray(),
                    chatSettings: await db.chatSettings.toArray(),
                    customEmojis: await db.customEmojis.toArray(),
                    wallpapers: await db.wallpapers.toArray(),
                    worldbooks: await db.worldbooks.toArray(),
                    characterGroups: await db.characterGroups.toArray(),
                    groupChats: await db.groupChats.toArray(),
                    personas: await db.personas.toArray(),
                    apiSettings: await db.apiSettings.toArray(),
                    globalSettings: await db.globalSettings.toArray(),
                    recentEmojis: await db.recentEmojis.toArray(),
                    contacts: await db.contacts.toArray(),
                    appIcons: await db.appIcons.toArray()
                };

                // 显示导出统计
                const stats = [];
                if (exportData.characters?.length) stats.push(`角色: ${exportData.characters.length}个`);
                if (exportData.chatMessages?.length) stats.push(`消息: ${exportData.chatMessages.length}条`);
                if (exportData.chatSettings?.length) stats.push(`设置: ${exportData.chatSettings.length}个`);
                if (exportData.wallpapers?.length) stats.push(`壁纸: ${exportData.wallpapers.length}个`);
                if (exportData.worldbooks?.length) stats.push(`世界书: ${exportData.worldbooks.length}个`);
                if (exportData.characterGroups?.length) stats.push(`分组: ${exportData.characterGroups.length}个`);
                if (exportData.groupChats?.length) stats.push(`群聊: ${exportData.groupChats.length}个`);
                if (exportData.personas?.length) stats.push(`面具: ${exportData.personas.length}个`);
                if (exportData.customEmojis?.length) stats.push(`表情: ${exportData.customEmojis.length}个`);
                
                console.log('导出数据统计:', stats.join(', '));

                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `完整备份_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                const statsText = stats.length > 0 ? `\n${stats.join('\n')}` : '';
                showToast(`导出成功！${statsText}`, 'success');
            } catch (error) {
                console.error('导出失败:', error);
                showToast('导出失败: ' + error.message, 'error');
            }
        }

        // 导入数据
        // 🔥【修复】导入数据 - 增强错误处理和数据验证
        function importDataFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (!file) return;
                try {
                    showToast('正在导入...', 'info');
                    const text = await file.text();
                    
                    // 尝试解析JSON
                    let data;
                    try {
                        data = JSON.parse(text);
                    } catch (parseError) {
                        throw new Error('JSON格式错误：' + parseError.message);
                    }
                    
                    // 检查数据格式
                    if (!data || typeof data !== 'object') {
                        throw new Error('无效的备份文件格式');
                    }
                    
                    // 显示导入预览
                    const dataPreview = [];
                    if (data.characters?.length) dataPreview.push(`角色: ${data.characters.length}个`);
                    if (data.chatMessages?.length) dataPreview.push(`聊天消息: ${data.chatMessages.length}条`);
                    if (data.chatSettings?.length) dataPreview.push(`聊天设置: ${data.chatSettings.length}个`);
                    if (data.worldbooks?.length) dataPreview.push(`世界书: ${data.worldbooks.length}个`);
                    if (data.customEmojis?.length) dataPreview.push(`自定义表情: ${data.customEmojis.length}个`);
                    if (data.wallpapers?.length) dataPreview.push(`壁纸: ${data.wallpapers.length}个`);
                    if (data.characterGroups?.length) dataPreview.push(`角色分组: ${data.characterGroups.length}个`);
                    if (data.groupChats?.length) dataPreview.push(`群聊: ${data.groupChats.length}个`);
                    if (data.personas?.length) dataPreview.push(`用户面具: ${data.personas.length}个`);
                    if (data.apiSettings?.length) dataPreview.push(`API设置: ${data.apiSettings.length}个`);
                    if (data.globalSettings?.length) dataPreview.push(`全局设置: ${data.globalSettings.length}个`);
                    if (data.contacts?.length) dataPreview.push(`联系人: ${data.contacts.length}个`);
                    if (data.appIcons?.length) dataPreview.push(`应用图标: ${data.appIcons.length}个`);
                    
                    const previewText = dataPreview.length > 0 ? 
                        `将导入以下数据：\n${dataPreview.join('\n')}\n\n导入将覆盖现有数据，确定继续？` : 
                        '备份文件中没有找到有效数据，确定继续？';
                    
                    if (!confirm(previewText)) return;
                    
                    // 🔥【修复】使用bulkPut代替bulkAdd避免主键冲突
                    let importedTables = 0;
                    
                    // 导入角色数据
                    if (data.characters?.length) {
                        try {
                        await db.characters.clear();
                            // 确保每个角色都有有效ID
                            const validCharacters = data.characters.map(char => ({
                                ...char,
                                id: char.id || `char_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.characters.bulkPut(validCharacters);
                            importedTables++;
                            console.log(`导入了 ${validCharacters.length} 个角色`);
                        } catch (error) {
                            console.error('导入角色失败:', error);
                            showToast('角色导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入聊天消息
                    if (data.chatMessages?.length) {
                        try {
                        await db.chatMessages.clear();
                            // 确保每条消息都有有效ID
                            const validMessages = data.chatMessages.map(msg => ({
                                ...msg,
                                id: msg.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.chatMessages.bulkPut(validMessages);
                            importedTables++;
                            console.log(`导入了 ${validMessages.length} 条聊天消息`);
                        } catch (error) {
                            console.error('导入聊天消息失败:', error);
                            showToast('聊天消息导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入聊天设置
                    if (data.chatSettings?.length) {
                        try {
                        await db.chatSettings.clear();
                            // 确保每个设置都有有效ID
                            const validSettings = data.chatSettings.map(setting => ({
                                ...setting,
                                id: setting.id || `setting_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.chatSettings.bulkPut(validSettings);
                            importedTables++;
                            console.log(`导入了 ${validSettings.length} 个聊天设置`);
                        } catch (error) {
                            console.error('导入聊天设置失败:', error);
                            showToast('聊天设置导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入其他可能的数据
                    if (data.worldbooks?.length) {
                        try {
                            await db.worldbooks.clear();
                            const validWorldbooks = data.worldbooks.map(wb => ({
                                ...wb,
                                id: wb.id || `wb_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.worldbooks.bulkPut(validWorldbooks);
                            importedTables++;
                            console.log(`导入了 ${validWorldbooks.length} 个世界书`);
                        } catch (error) {
                            console.error('导入世界书失败:', error);
                            showToast('世界书导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    if (data.customEmojis?.length) {
                        try {
                            await db.customEmojis.clear();
                            const validEmojis = data.customEmojis.map(emoji => ({
                                ...emoji,
                                id: emoji.id || `emoji_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.customEmojis.bulkPut(validEmojis);
                            importedTables++;
                            console.log(`导入了 ${validEmojis.length} 个自定义表情`);
                        } catch (error) {
                            console.error('导入自定义表情失败:', error);
                            showToast('自定义表情导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入壁纸
                    if (data.wallpapers?.length) {
                        try {
                            await db.wallpapers.clear();
                            const validWallpapers = data.wallpapers.map(wp => ({
                                ...wp,
                                id: wp.id || `wp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.wallpapers.bulkPut(validWallpapers);
                            importedTables++;
                            console.log(`导入了 ${validWallpapers.length} 个壁纸`);
                        } catch (error) {
                            console.error('导入壁纸失败:', error);
                            showToast('壁纸导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入角色分组
                    if (data.characterGroups?.length) {
                        try {
                            await db.characterGroups.clear();
                            const validGroups = data.characterGroups.map(group => ({
                                ...group,
                                id: group.id || `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.characterGroups.bulkPut(validGroups);
                            importedTables++;
                            console.log(`导入了 ${validGroups.length} 个角色分组`);
                        } catch (error) {
                            console.error('导入角色分组失败:', error);
                            showToast('角色分组导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入群聊
                    if (data.groupChats?.length) {
                        try {
                            await db.groupChats.clear();
                            const validGroups = data.groupChats.map(chat => ({
                                ...chat,
                                id: chat.id || `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.groupChats.bulkPut(validGroups);
                            importedTables++;
                            console.log(`导入了 ${validGroups.length} 个群聊`);
                        } catch (error) {
                            console.error('导入群聊失败:', error);
                            showToast('群聊导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入用户面具
                    if (data.personas?.length) {
                        try {
                            await db.personas.clear();
                            const validPersonas = data.personas.map(persona => ({
                                ...persona,
                                id: persona.id || `persona_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.personas.bulkPut(validPersonas);
                            importedTables++;
                            console.log(`导入了 ${validPersonas.length} 个用户面具`);
                        } catch (error) {
                            console.error('导入用户面具失败:', error);
                            showToast('用户面具导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入API设置
                    if (data.apiSettings?.length) {
                        try {
                            await db.apiSettings.clear();
                            const validApiSettings = data.apiSettings.map(setting => ({
                                ...setting,
                                id: setting.id || `api_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.apiSettings.bulkPut(validApiSettings);
                            importedTables++;
                            console.log(`导入了 ${validApiSettings.length} 个API设置`);
                        } catch (error) {
                            console.error('导入API设置失败:', error);
                            showToast('API设置导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入全局设置
                    if (data.globalSettings?.length) {
                        try {
                            await db.globalSettings.clear();
                            const validGlobalSettings = data.globalSettings.map(setting => ({
                                ...setting,
                                id: setting.id || `global_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.globalSettings.bulkPut(validGlobalSettings);
                            importedTables++;
                            console.log(`导入了 ${validGlobalSettings.length} 个全局设置`);
                        } catch (error) {
                            console.error('导入全局设置失败:', error);
                            showToast('全局设置导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入最近表情
                    if (data.recentEmojis?.length) {
                        try {
                            await db.recentEmojis.clear();
                            const validRecentEmojis = data.recentEmojis.map(emoji => ({
                                ...emoji,
                                id: emoji.id || `recent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.recentEmojis.bulkPut(validRecentEmojis);
                            importedTables++;
                            console.log(`导入了 ${validRecentEmojis.length} 个最近表情`);
                        } catch (error) {
                            console.error('导入最近表情失败:', error);
                            showToast('最近表情导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入联系人
                    if (data.contacts?.length) {
                        try {
                            await db.contacts.clear();
                            const validContacts = data.contacts.map(contact => ({
                                ...contact,
                                id: contact.id || `contact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.contacts.bulkPut(validContacts);
                            importedTables++;
                            console.log(`导入了 ${validContacts.length} 个联系人`);
                        } catch (error) {
                            console.error('导入联系人失败:', error);
                            showToast('联系人导入失败: ' + error.message, 'warning');
                        }
                    }
                    
                    // 导入应用图标
                    if (data.appIcons?.length) {
                        try {
                            await db.appIcons.clear();
                            const validAppIcons = data.appIcons.map(icon => ({
                                ...icon,
                                id: icon.id || `icon_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                            }));
                            await db.appIcons.bulkPut(validAppIcons);
                            importedTables++;
                            console.log(`导入了 ${validAppIcons.length} 个应用图标`);
                        } catch (error) {
                            console.error('导入应用图标失败:', error);
                            showToast('应用图标导入失败: ' + error.message, 'warning');
                        }
                    }
                    

                    
                    // 重新加载所有数据
                    await loadCharacterGroups();
                    await loadCharacters();
                    await loadChatMessages();
                    await loadChatSettings();
                    await loadPersonas();
                    await loadGroupChats();
                    await loadWallpaper();
                    await loadAppIcons();
                    await loadWorldbooks();
                    renderCharacterList();
                    renderMessageList();
                    renderPersonaList();
                    calculateStorageUsage();
                    
                    showToast(`导入成功！共导入 ${importedTables} 个数据表`, 'success');
                    console.log(`数据导入完成，共导入 ${importedTables} 个数据表`);
                } catch (error) {
                    console.error('导入失败:', error);
                    showToast('导入失败：' + error.message, 'error');
                }
            };
            input.click();
        }

        // 显示清理选项
        function showCleanupOptions() {
            const choice = prompt('选择清理项目：\n1. 清除动态头像\n2. 删除空聊天记录\n3. 清理localStorage\n4. 压缩图片\n\n输入数字（逗号分隔）：');
            if (choice) executeCleanupOptions(choice);
        }

        // 执行清理
        async function executeCleanupOptions(choice) {
            const selections = choice.split(',').map(s => parseInt(s.trim())).filter(n => n >= 1 && n <= 4);
            if (!selections.length) return;
            
            showToast('清理中...', 'info');
            let count = 0;
            
            for (const option of selections) {
                switch (option) {
                    case 1:
                        Object.keys(chatSettings).forEach(id => {
                            if (chatSettings[id]?.aiDynamicAvatar) {
                                delete chatSettings[id].aiDynamicAvatar;
                                count++;
                            }
                        });
                        break;
                    case 2:
                        Object.keys(chatMessages).forEach(id => {
                            if (!chatMessages[id]?.length) {
                                delete chatMessages[id];
                                count++;
                            }
                        });
                        break;
                    case 3:
                        for (let i = localStorage.length - 1; i >= 0; i--) {
                            const key = localStorage.key(i);
                            if (key?.startsWith('chatSettings_')) {
                                localStorage.removeItem(key);
                                count++;
                            }
                        }
                        break;
                    case 4:
                        await compressAllImages();
                        break;
                }
            }
            
            await saveChatSettings();
            await saveChatMessages();
            calculateStorageUsage();
            showToast(`清理完成！处理 ${count} 项`, 'success');
        }

        // 压缩图片
        async function compressAllImages() {
            showToast('压缩中...', 'info');
            let count = 0;
            
            // 压缩角色头像
            for (const char of characters) {
                if (char.avatarUrl?.length > 50000) {
                    char.avatarUrl = await compressImage(char.avatarUrl, 150, 0.6);
                    count++;
                }
            }
            await saveCharacters();
            
            // 压缩设置中的头像
            for (const id of Object.keys(chatSettings)) {
                const settings = chatSettings[id];
                if (settings?.aiChatAvatar?.length > 50000) {
                    settings.aiChatAvatar = await compressImage(settings.aiChatAvatar, 150, 0.6);
                    count++;
                }
                if (settings?.myChatAvatar?.length > 50000) {
                    settings.myChatAvatar = await compressImage(settings.myChatAvatar, 150, 0.6);
                    count++;
                }
            }
            await saveChatSettings();
            calculateStorageUsage();
            showToast(`压缩完成！处理 ${count} 张图片`, 'success');
        }

        // 调试用：列出所有角色ID和名称，帮助识别幽灵角色
        async function debugListAllCharacters() {
            try {
                console.log('=== 所有角色数据 ===');
                
                // 1. 数据库中的角色
                const dbChars = await db.characters.toArray();
                console.log('数据库角色表:', dbChars.map(c => `${c.name} (ID: ${c.id})`));
                
                // 2. 内存中的角色
                if (window.characters) {
                    console.log('内存角色列表:', window.characters.map(c => `${c.name} (ID: ${c.id})`));
                }
                
                // 3. 联系人列表
                if (window.contacts) {
                    console.log('联系人ID列表:', window.contacts);
                }
                
                // 4. 动态评论中的角色
                const comments = await db.momentComments.toArray();
                const commentAuthors = [...new Set(comments.map(c => `${c.nickname} (ID: ${c.authorId})`))];
                console.log('动态评论中的角色:', commentAuthors);
                
                // 5. 动态点赞中的角色
                const likes = await db.momentLikes.toArray();
                const likeAuthors = [...new Set(likes.map(l => `${l.name} (ID: ${l.authorId})`))];
                console.log('动态点赞中的角色:', likeAuthors);
                
                return {dbChars, comments, likes};
            } catch (error) {
                console.error('调试失败:', error);
            }
        }
        
        // 调试用：精确删除指定ID的角色数据
        async function debugDeleteCharacterById(characterId) {
            if (!characterId) {
                console.log('用法: debugDeleteCharacterById("角色ID")');
                return;
            }
            
            try {
                console.log(`开始删除角色ID: ${characterId}`);
                let deleteCount = 0;
                
                // 1. 从动态评论中删除
                const comments = await db.momentComments.where('authorId').equals(characterId).toArray();
                for (const comment of comments) {
                    await db.momentComments.delete(comment.id);
                    deleteCount++;
                    console.log(`删除评论: ${comment.nickname} - ${comment.text}`);
                }
                
                // 2. 从动态点赞中删除
                const likes = await db.momentLikes.where('authorId').equals(characterId).toArray();
                for (const like of likes) {
                    await db.momentLikes.delete([like.momentId, like.authorId]);
                    deleteCount++;
                    console.log(`删除点赞: ${like.name}`);
                }
                
                // 3. 从其他表中删除
                const chatMsgs = await db.chatMessages.where('characterId').equals(characterId).toArray();
                for (const msg of chatMsgs) {
                    await db.chatMessages.delete(msg.id);
                    deleteCount++;
                }
                
                const chatSets = await db.chatSettings.toArray();
                for (const setting of chatSets) {
                    if (setting.characterId === characterId) {
                        await db.chatSettings.delete(setting.id);
                        deleteCount++;
                    }
                }
                
                await db.characters.delete(characterId);
                deleteCount++;
                
                // 4. 从内存数组中删除
                if (window.contacts) {
                    window.contacts = window.contacts.filter(id => id !== characterId);
                    await saveContacts();
                }
                if (window.characters) {
                    window.characters = window.characters.filter(char => char.id !== characterId);
                }
                
                console.log(`删除完成！共删除 ${deleteCount} 条相关数据`);
                
                // 刷新界面
                if (window.renderContactList) window.renderContactList();
                if (window.renderMessageList) window.renderMessageList();
                
            } catch (error) {
                console.error('删除失败:', error);
            }
        }
        
        // 强制删除指定角色（用于清理幽灵角色）
        async function forceDeleteCharacter() {
            const characterName = prompt('输入要强制删除的角色名称（如：方回）：');
            if (!characterName || !characterName.trim()) return;
            
            try {
                showToast(`正在强制删除角色 "${characterName}"...`, 'info');
                let deleteCount = 0;
                
                // 1. 从动态评论中删除
                const comments = await db.momentComments.toArray();
                for (const comment of comments) {
                    if (comment.nickname === characterName || (comment.authorId && comment.authorId.includes(characterName))) {
                        await db.momentComments.delete(comment.id);
                        deleteCount++;
                        console.log(`删除评论：${comment.nickname} - ${comment.text}`);
                    }
                }
                
                // 2. 从动态点赞中删除
                const likes = await db.momentLikes.toArray();
                for (const like of likes) {
                    if (like.name === characterName || (like.authorId && like.authorId.includes(characterName))) {
                        await db.momentLikes.delete([like.momentId, like.authorId]);
                        deleteCount++;
                        console.log(`删除点赞：${like.name}`);
                    }
                }
                
                // 3. 从聊天消息中删除
                const chatMsgs = await db.chatMessages.toArray();
                for (const msg of chatMsgs) {
                    if (msg.characterId && msg.characterId.includes(characterName)) {
                        await db.chatMessages.delete(msg.id);
                        deleteCount++;
                    }
                }
                
                // 4. 从聊天设置中删除
                const chatSets = await db.chatSettings.toArray();
                for (const setting of chatSets) {
                    if (setting.characterId && setting.characterId.includes(characterName)) {
                        await db.chatSettings.delete(setting.id);
                        deleteCount++;
                    }
                }
                
                // 5. 从characters表中删除
                const chars = await db.characters.toArray();
                for (const char of chars) {
                    if (char.name === characterName || char.id.includes(characterName)) {
                        await db.characters.delete(char.id);
                        deleteCount++;
                        console.log(`删除角色：${char.name} (${char.id})`);
                    }
                }
                
                // 6. 从联系人列表中删除
                if (window.contacts) {
                    window.contacts = window.contacts.filter(id => !id.includes(characterName));
                    await saveContacts();
                }
                
                // 7. 清理内存中的数据
                if (window.characters) {
                    window.characters = window.characters.filter(char => char.name !== characterName);
                }
                if (window.chatMessages) {
                    Object.keys(window.chatMessages).forEach(key => {
                        if (key.includes(characterName)) {
                            delete window.chatMessages[key];
                        }
                    });
                }
                if (window.chatSettings) {
                    Object.keys(window.chatSettings).forEach(key => {
                        if (key.includes(characterName)) {
                            delete window.chatSettings[key];
                        }
                    });
                }
                
                // 刷新界面
                if (window.renderContactList) window.renderContactList();
                if (window.renderMessageList) window.renderMessageList();
                
                showToast(`强制删除完成！共删除 ${deleteCount} 条相关数据`, 'success');
                console.log(`强制删除角色 "${characterName}" 完成，删除了 ${deleteCount} 条记录`);
                
            } catch (error) {
                console.error('强制删除失败:', error);
                showToast('强制删除失败: ' + error.message, 'error');
            }
        }

        // 清理孤立联系人和重复数据
        async function cleanupOrphanedContacts() {
            try {
                showToast('正在清理孤立数据...', 'info');
                
                let cleanupCount = 0;
                
                // 1. 清理联系人列表中不存在的角色ID
                const validCharacterIds = characters.map(char => char.id);
                const originalContactsLength = contacts.length;
                contacts = contacts.filter(contactId => {
                    const isValid = validCharacterIds.includes(contactId);
                    if (!isValid) cleanupCount++;
                    return isValid;
                });
                
                // 2. 从数据库中清理孤立的联系人记录
                const dbContacts = await db.contacts.toArray();
                for (const contact of dbContacts) {
                    if (!validCharacterIds.includes(contact.characterId)) {
                        await db.contacts.delete(contact.id);
                        cleanupCount++;
                    }
                }
                
                // 3. 清理聊天消息中不存在角色的记录
                const chatMessageKeys = Object.keys(chatMessages);
                for (const characterId of chatMessageKeys) {
                    if (!validCharacterIds.includes(characterId)) {
                        delete chatMessages[characterId];
                        cleanupCount++;
                    }
                }
                
                // 4. 清理数据库中孤立的聊天消息
                const dbChatMessages = await db.chatMessages.toArray();
                for (const msgRecord of dbChatMessages) {
                    if (!validCharacterIds.includes(msgRecord.characterId)) {
                        await db.chatMessages.delete(msgRecord.id);
                        cleanupCount++;
                    }
                }
                
                // 5. 清理聊天设置中不存在角色的记录
                const chatSettingsKeys = Object.keys(chatSettings);
                for (const characterId of chatSettingsKeys) {
                    if (!validCharacterIds.includes(characterId)) {
                        delete chatSettings[characterId];
                        cleanupCount++;
                    }
                }
                
                // 6. 清理数据库中孤立的聊天设置
                const dbChatSettings = await db.chatSettings.toArray();
                for (const setting of dbChatSettings) {
                    if (!validCharacterIds.includes(setting.characterId)) {
                        await db.chatSettings.delete(setting.id);
                        cleanupCount++;
                    }
                }
                
                // 7. 清理动态评论中不存在角色的记录
                const dbMomentComments = await db.momentComments.toArray();
                for (const comment of dbMomentComments) {
                    // 清理authorId不在角色列表中且不是用户的评论
                    if (comment.authorId !== 'user' && !validCharacterIds.includes(comment.authorId)) {
                        await db.momentComments.delete(comment.id);
                        cleanupCount++;
                        console.log(`删除了孤立评论：${comment.nickname}(${comment.authorId})`);
                    }
                }
                
                // 8. 清理动态点赞中不存在角色的记录
                const dbMomentLikes = await db.momentLikes.toArray();
                for (const like of dbMomentLikes) {
                    // 清理authorId不在角色列表中且不是用户的点赞
                    if (like.authorId !== 'user' && !validCharacterIds.includes(like.authorId)) {
                        await db.momentLikes.delete([like.momentId, like.authorId]);
                        cleanupCount++;
                        console.log(`删除了孤立点赞：${like.name}(${like.authorId})`);
                    }
                }
                
                // 9. 保存清理后的数据
                await Promise.all([
                    saveContacts(),
                    saveChatMessages(),
                    saveChatSettings()
                ]);
                
                // 10. 重新渲染界面
                renderContactList();
                renderMessageList();
                
                showToast(`清理完成！共清理了 ${cleanupCount} 条孤立数据`, 'success');
                
                console.log('清理结果:', {
                    有效角色数: validCharacterIds.length,
                    清理前联系人数: originalContactsLength,
                    清理后联系人数: contacts.length,
                    总清理项目: cleanupCount
                });
                
            } catch (error) {
                console.error('清理孤立数据失败:', error);
                showToast('清理失败: ' + error.message, 'error');
            }
        }
        
        // 清空所有数据
        async function clearAllData() {
            const confirm = prompt('警告：将删除所有数据且无法恢复！\n输入"清空所有数据"确认：');
            if (confirm !== '清空所有数据') return;
            
            try {
                showToast('清空中...', 'info');
                
                // 清空所有数据库表
                await Promise.all([
                    db.characters.clear(),
                    db.chatMessages.clear(), 
                    db.chatSettings.clear(),
                    db.customEmojis.clear(),
                    db.worldbooks.clear() // 确保也清空世界书数据
                ]);
                
                // 重置内存中的全局变量
                characters = [];
                chatMessages = {};
                chatSettings = {};
                customEmojis = [];
                contacts = [];
                groupChats = [];
                currentChatCharacter = null;
                
                // 清理localStorage中的备份数据
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    // 清除所有聊天设置和其他应用数据
                    if (key?.startsWith('chatSettings_') || 
                        key?.startsWith('contacts') || 
                        key?.startsWith('characters') || 
                        key?.startsWith('chatMessages')) {
                        localStorage.removeItem(key);
                    }
                }
                
                // 刷新界面
                renderCharacterList();
                renderMessageList();
                renderContactList();
                calculateStorageUsage();
                
                showToast('已清空所有数据', 'success');
                console.log('✅ 所有数据已清空，包括聊天设置、角色数据、聊天记录和世界书');
                
                // 返回主界面
                setTimeout(() => {
                    hideApp('data-management-screen');
                    hideApp('settings-screen');
                    showApp('chat-screen');
                }, 2000);
            } catch (error) {
                console.error('清空数据失败:', error);
                showToast('清空失败: ' + error.message, 'error');
            }
        }

        // 重复函数已删除

        // 转账相关变量
        let currentTransferMsg = null;
        
        // 处理用户发送给AI的转账
        async function processUserTransfer(userTransferMsg, aiMessages) {
            console.log('🚀 processUserTransfer 被调用:', {
                userTransferMsg,
                aiMessages,
                currentCharacter: currentChatCharacter?.name
            });
            
            if (!userTransferMsg || !currentChatCharacter) {
                console.log('❌ processUserTransfer 退出：缺少必要参数');
                return;
            }
            
            const messages = chatMessages[currentChatCharacter.id] || [];
            
            // 分析AI的回复内容，判断是否有转账相关操作
            let transferAction = null;
            let transferActionReason = '';
            
            for (const msgData of aiMessages) {
                // 检查AI是否在回复中明确处理了转账
                if (typeof msgData === 'object' && msgData.type === 'transfer_action') {
                    transferAction = msgData.action; // 'accept', 'reject', 'ignore'
                    transferActionReason = msgData.reason || '';
                    break;
                }
                
                // 检查AI的普通回复中是否包含转账处理的关键词
                if (typeof msgData === 'string') {
                    const content = msgData.toLowerCase();
                    console.log('🔥 [转账处理] 分析AI回复内容:', content);
                    
                    if (content.includes('收下') || content.includes('谢谢') || content.includes('收款') || content.includes('接受') || 
                        content.includes('确认收款') || content.includes('已收款') || content.includes('收到了') || content.includes('收到') ||
                        content.includes('感谢') || content.includes('好的') || content.includes('ok') || 
                        content.includes('没问题') || content.includes('可以')) {
                        transferAction = 'accept';
                        transferActionReason = '角色同意收款';
                        console.log('🔥 [转账处理] 检测到收款关键词，设置为accept');
                        break;
                    } else if (content.includes('退回') || content.includes('不要') || content.includes('拒绝') || 
                              content.includes('不需要') || content.includes('不收') || content.includes('算了')) {
                        transferAction = 'reject';
                        transferActionReason = '角色拒绝收款';
                        console.log('🔥 [转账处理] 检测到拒绝关键词，设置为reject');
                        break;
                    } else {
                        console.log('🔥 [转账处理] 未检测到相关关键词');
                    }
                }
            }
            
            // 如果AI明确表示了转账处理意图，则执行相应操作
            console.log('🔥 [转账处理] 最终转账操作决定:', transferAction);
            if (transferAction === 'accept' || transferAction === 'reject') {
                const transferIndex = messages.findIndex(msg => 
                    msg.timestamp === userTransferMsg.timestamp && msg.type === 'transfer' && msg.sender === 'sent');
                    
                if (transferIndex !== -1) {
                    // 更新转账状态
                    const newStatus = transferAction === 'accept' ? 'accepted' : 'rejected';
                    messages[transferIndex].status = newStatus;
                    
                    console.log('✅ 转账状态已更新:', {
                        oldStatus: userTransferMsg.status,
                        newStatus: newStatus,
                        message: messages[transferIndex]
                    });
                    
                    // 保存到数据库
                    await saveChatMessages();
                    
                    // 添加系统消息
                    const actionText = transferAction === 'accept' ? '已收款' : '已退回';
                    const systemMsg = {
                        id: Date.now().toString(),
                        sender: 'system',
                        content: `${currentChatCharacter.name}${actionText} ¥${Number(userTransferMsg.amount).toFixed(2)}`,
                        timestamp: Date.now()
                    };
                    
                    messages.push(systemMsg);
                    await saveChatMessages();
                    
                    console.log('📱 系统消息已添加:', systemMsg);
                    
                    // 立即重新渲染聊天界面以显示更新
                    renderChatMessages(currentChatCharacter.id);
                    
                    // 显示确认提示
                    const toastText = transferAction === 'accept' ? '转账已被接受' : '转账已被退回';
                    showToast(toastText, 'success');
                    
                    console.log('🎉 转账处理完成');
                } else {
                    console.error('❌ 未找到对应的转账消息');
                }
            } else {
                console.log('ℹ️ AI没有明确表态，转账保持pending状态');
            }
            // 如果AI没有明确表态，转账保持pending状态，等待用户手动处理或下次AI回复
        }
        
        // 转账相关函数
        function sendTransfer() {
            const amount = parseFloat(document.getElementById('transfer-amount').value);
            const note = document.getElementById('transfer-note').value.trim();
            
            if (!amount || amount <= 0) {
                showToast('请输入有效的转账金额', 'warning');
                return;
            }
            
            if (amount > 1000000000) {
                showToast('转账金额不能超过10亿元', 'warning');
                return;
            }
            
            // 创建转账消息 - 修复数据结构和设置pendingUserMessage
            const transferMessage = {
                id: Date.now().toString(),
                sender: 'sent',  // 修复：使用 sender 而不是 role
                type: 'transfer',
                amount: amount,
                note: note || '转账',
                timestamp: Date.now()
            };
            
            // 添加到聊天记录
            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(transferMessage);
            
            // 保存到数据库
            saveChatMessages();
            
            // 使用动画添加消息而不是重新渲染整个列表
            addMessageWithAnimation(transferMessage, currentChatCharacter.id);
            
            // 🔥 【关键修复】设置为待回复消息，让AI能看到转账
            pendingUserMessage = transferMessage;
            
            // 更新智能回复按钮状态
            const smartReplyBtn = document.getElementById('smart-reply-btn');
            if (smartReplyBtn) {
                smartReplyBtn.style.animation = 'pulse 1.5s infinite';
                smartReplyBtn.classList.add('waiting');
                smartReplyBtn.title = '点击获取AI回复';
            }
            
            // 更新联系人列表
            renderMessageList();
            
            // 关闭转账对话框
            document.getElementById('transfer-modal').classList.remove('visible');
            
            // 清空输入框
            document.getElementById('transfer-amount').value = '';
            document.getElementById('transfer-note').value = '';
            
            showToast('转账已发送', 'success');
        }
        
        function showTransferConfirmDialog(transferMsg) {
            if (!transferMsg || transferMsg.status) return;
            
            const modal = document.getElementById('transfer-confirm-modal');
            const amountEl = modal.querySelector('.transfer-confirm-amount');
            const noteEl = modal.querySelector('.transfer-confirm-note');
            
            // 设置转账信息
            amountEl.textContent = `¥ ${Number(transferMsg.amount).toFixed(2)}`;
            noteEl.textContent = `备注：${transferMsg.note || '无'}`;
            
            // 存储当前处理的转账信息
            currentTransferMsg = transferMsg;
            
            // 显示对话框
            modal.classList.add('visible');
        }
        
        async function acceptTransfer() {
            if (!currentTransferMsg || !currentChatCharacter) return;
            
            // 在聊天记录中找到对应的转账消息并更新状态
            const messages = chatMessages[currentChatCharacter.id] || [];
            const transferIndex = messages.findIndex(msg => 
                msg.timestamp === currentTransferMsg.timestamp && msg.type === 'transfer');
                
            if (transferIndex !== -1) {
                // 更新转账状态
                messages[transferIndex].status = 'accepted';
                
                // 保存到数据库
                await saveChatMessages();
                
                // 重新渲染聊天界面
                renderChatMessages(currentChatCharacter.id);
                
                // 添加一条系统消息，表示已收款
                const systemMsg = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `你已确认收款 ¥${Number(currentTransferMsg.amount).toFixed(2)}`,
                    timestamp: Date.now()
                };
                
                messages.push(systemMsg);
                await saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
            }
            
            // 关闭对话框
            document.getElementById('transfer-confirm-modal').classList.remove('visible');
            currentTransferMsg = null;
            
            showToast('已确认收款', 'success');
        }
        
        async function rejectTransfer() {
            if (!currentTransferMsg || !currentChatCharacter) return;
            
            // 在聊天记录中找到对应的转账消息并更新状态
            const messages = chatMessages[currentChatCharacter.id] || [];
            const transferIndex = messages.findIndex(msg => 
                msg.timestamp === currentTransferMsg.timestamp && msg.type === 'transfer');
                
            if (transferIndex !== -1) {
                // 更新转账状态
                messages[transferIndex].status = 'rejected';
                
                // 保存到数据库
                await saveChatMessages();
                
                // 重新渲染聊天界面
                renderChatMessages(currentChatCharacter.id);
                
                // 添加一条系统消息，表示已退回
                const systemMsg = {
                    id: Date.now().toString(),
                    sender: 'system',
                    content: `你已退回 ¥${Number(currentTransferMsg.amount).toFixed(2)}`,
                    timestamp: Date.now()
                };
                
                messages.push(systemMsg);
                await saveChatMessages();
                renderChatMessages(currentChatCharacter.id);
            }
            
            // 关闭对话框
            document.getElementById('transfer-confirm-modal').classList.remove('visible');
            currentTransferMsg = null;
            
            showToast('已退回转账', 'success');
        }

        // 监听app显示事件
        const originalShowApp = window.showApp;
        if (originalShowApp) {
            window.showApp = function(appId) {
                originalShowApp(appId);
                if (appId === 'data-management-screen') calculateStorageUsage();
            };
        }

        // 显示定时发布时间设置模态框
        function showScheduleTimesModal() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduledMomentsTimes || [];
            
            const container = document.getElementById('schedule-times-modal-container');
            container.innerHTML = '';
            
            // 渲染已有时间点
            scheduleTimes.forEach((time, index) => {
                const timeItem = document.createElement('div');
                timeItem.className = 'schedule-time-item';
                timeItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    margin-bottom: 10px;
                    gap: 10px;
                `;
                timeItem.innerHTML = `
                    <input type="time" value="${time}" onchange="updateScheduleTime(${index}, this.value)" 
                           style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                    <button onclick="removeScheduleTime(${index})" 
                            style="padding: 8px 12px; background: #ff3b30; color: white; border: none; border-radius: 6px; cursor: pointer;">×</button>
                `;
                container.appendChild(timeItem);
            });
            
            showModal('schedule-times-modal');
        }
        
        // 添加定时发布时间点
        function addScheduleTime() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduledMomentsTimes) {
                chatSettings.scheduledMomentsTimes = [];
            }
            
            if (chatSettings.scheduledMomentsTimes.length >= 10) {
                alert('最多只能设置10个时间点');
                return;
            }
            
            chatSettings.scheduledMomentsTimes.push('09:00');
            saveCurrentChatSettings(chatSettings);
            showScheduleTimesModal(); // 重新渲染
        }
        
        // 更新定时发布时间点
        function updateScheduleTime(index, newTime) {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes[index] !== undefined) {
                chatSettings.scheduledMomentsTimes[index] = newTime;
                saveCurrentChatSettings(chatSettings);
            }
        }
        
        // 移除定时发布时间点
        function removeScheduleTime(index) {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (chatSettings.scheduledMomentsTimes && chatSettings.scheduledMomentsTimes[index] !== undefined) {
                chatSettings.scheduledMomentsTimes.splice(index, 1);
                saveCurrentChatSettings(chatSettings);
                showScheduleTimesModal(); // 重新渲染
            }
        }
        
        // 保存定时发布设置
        function saveScheduleTimes() {
            if (!currentChatCharacter) return;
            
            const container = document.getElementById('schedule-times-modal-container');
            const timeInputs = container.querySelectorAll('input[type="time"]');
            const times = Array.from(timeInputs).map(input => input.value).filter(time => time);
            
            const chatSettings = getCurrentChatSettings();
            chatSettings.scheduledMomentsTimes = times;
            saveCurrentChatSettings(chatSettings);
            
            updateScheduleTimesDisplay();
            hideModal('schedule-times-modal');
            
            // 重新初始化全局动态发布系统以应用新设置
            setTimeout(async () => {
                try {
                    await initGlobalMomentsSystem();
                    console.log('✅ 定时发布设置已更新');
                } catch (error) {
                    console.error('❌ 更新定时发布设置失败:', error);
                }
            }, 500);
            
            showToast(`已保存 ${times.length} 个定时发布时间点`, 'success');
        }
        
        // 更新定时发布时间显示
        function updateScheduleTimesDisplay() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            const scheduleTimes = chatSettings.scheduledMomentsTimes || [];
            const displayElement = document.getElementById('schedule-times-display');
            
            if (scheduleTimes.length === 0) {
                displayElement.textContent = '未设置';
            } else if (scheduleTimes.length === 1) {
                displayElement.textContent = `1个时间点 (${scheduleTimes[0]})`;
            } else {
                displayElement.textContent = `${scheduleTimes.length}个时间点`;
            }
        }
        
        // 测试发布动态
        async function testPublishMoment() {
            if (!currentChatCharacter) {
                alert('请先选择一个角色');
                return;
            }
            
            const button = document.querySelector('button[onclick="testPublishMoment()"]');
            const originalText = button.textContent;
            button.textContent = '发布中...';
            button.disabled = true;
            
            try {
                await triggerBackgroundMomentsTest(currentChatCharacter.id);
                showToast('测试动态发布成功！', 'success');
            } catch (error) {
                console.error('测试发布失败:', error);
                showToast('测试发布失败', 'error');
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        // 初始化定时发布系统
        function initScheduledMomentsSystem() {
            if (!currentChatCharacter) return;
            
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.scheduledMomentsEnabled || !chatSettings.scheduledMomentsTimes?.length) {
                return;
            }
            
            // 为每个设定时间创建定时器
            chatSettings.scheduledMomentsTimes.forEach(time => {
                if (!time) return;
                
                const [hours, minutes] = time.split(':').map(Number);
                const now = new Date();
                const scheduledTime = new Date();
                
                scheduledTime.setHours(hours, minutes, 0, 0);
                
                // 如果时间已过，设置为明天
                if (scheduledTime <= now) {
                    scheduledTime.setDate(scheduledTime.getDate() + 1);
                }
                
                const delay = scheduledTime.getTime() - now.getTime();
                
                setTimeout(() => {
                    // 执行定时发布
                    triggerBackgroundMoments(currentChatCharacter.id);
                    
                    // 设置每24小时重复执行
                    setInterval(() => {
                        triggerBackgroundMoments(currentChatCharacter.id);
                    }, 24 * 60 * 60 * 1000);
                }, delay);
            });
        }

        // 🔥【新增】推送通知功能
        // 🔥【新增】通知队列和单个通知管理
        let notificationQueue = [];
        let currentNotification = null;
        let isProcessingQueue = false;

        // 🔥【修复】创建推送通知 - 改为队列方式，单个显示
        function createPushNotification(character, messageData, delay = 0) {
            // 🔥【修复】检查用户是否在聊天界面 - 使用更可靠的方法
            
            // 方法1：检查主屏幕是否可见（更可靠）
            const phoneScreen = document.getElementById('phone-screen');
            const isOnMainScreen = phoneScreen && window.getComputedStyle(phoneScreen).display !== 'none';
            
            // 方法2：检查聊天界面是否可见
            const chatScreen = document.getElementById('api-chat-screen');
            const isChatVisible = chatScreen && window.getComputedStyle(chatScreen).display !== 'none';
            
            console.log('🔔 [推送通知] 检查界面状态:', {
                mainScreenVisible: isOnMainScreen,
                chatScreenVisible: isChatVisible,
                shouldShowNotification: isOnMainScreen && !isChatVisible
            });
            
            // 只有在主屏幕可见且聊天界面不可见时才显示推送
            if (!isOnMainScreen || isChatVisible) {
                console.log('🔔 [推送通知] 用户不在主屏幕或正在聊天界面，不显示推送');
                return;
            }
            
            // 添加到队列
            notificationQueue.push({
                character,
                messageData,
                delay
            });
            
            console.log('🔔 [推送通知] 添加通知到队列，当前队列长度:', notificationQueue.length);
            
            // 开始处理队列
            processNotificationQueue();
        }

        // 🔥【新增】处理通知队列
        function processNotificationQueue() {
            if (isProcessingQueue || notificationQueue.length === 0) {
                return;
            }
            
            isProcessingQueue = true;
            console.log('🔔 [推送通知] 开始处理队列，剩余通知数:', notificationQueue.length);
            
            const processNext = () => {
                if (notificationQueue.length === 0) {
                    isProcessingQueue = false;
                    console.log('🔔 [推送通知] 队列处理完成');
                    return;
                }
                
                const { character, messageData, delay } = notificationQueue.shift();
                
                setTimeout(() => {
                    showSingleNotification(character, messageData);
                    
                    // 1.5秒后处理下一个通知
                    setTimeout(() => {
                        processNext();
                    }, 1500);
                }, delay);
            };
            
            processNext();
        }

        // 🔥【新增】显示单个通知
        function showSingleNotification(character, messageData) {
            console.log('🔔 [推送通知] 显示单个通知，角色:', character.name);
            
            const container = document.getElementById('notification-container');
            if (!container) {
                console.error('🔔 [推送通知] 找不到通知容器!');
                return;
            }
            
            // 如果有现有通知，先移除
            if (currentNotification) {
                hideNotification(currentNotification, true);
            }
            
            // 创建通知元素
            const notification = document.createElement('div');
            notification.className = 'push-notification';
            currentNotification = notification;
            
            // 生成通知内容
            let notificationText = '';
            let notificationType = 'message';
            let senderName = character.name;
            
            if (typeof messageData === 'string') {
                notificationText = messageData;
            } else if (typeof messageData === 'object') {
                // 🔥【修复】处理群聊消息格式
                if (messageData.name && messageData.message) {
                    // 群聊消息格式: {name: "角色名", message: "消息内容"}
                    senderName = messageData.name;
                    
                    if (typeof messageData.message === 'string') {
                        notificationText = messageData.message;
                    } else if (typeof messageData.message === 'object' && messageData.message.type) {
                        // 群聊中的特殊消息类型
                        switch (messageData.message.type) {
                            case 'transfer':
                                notificationText = `向你转账了 ¥${messageData.message.amount}`;
                                notificationType = 'transfer';
                                break;
                            case 'voice_message':
                                notificationText = '[语音消息]';
                                notificationType = 'voice';
                                break;
                            default:
                                notificationText = messageData.message.content || '[消息]';
                        }
                    } else {
                        notificationText = String(messageData.message);
                    }
                } else if (messageData.type) {
                    // 普通的特殊消息类型
                    switch (messageData.type) {
                        case 'transfer':
                            notificationText = `向你转账了 ¥${messageData.amount}`;
                            notificationType = 'transfer';
                            break;
                        case 'voice_message':
                            notificationText = '[语音消息]';
                            notificationType = 'voice';
                            break;
                        case 'ai_image':
                            notificationText = '[图片]';
                            notificationType = 'image';
                            break;
                        case 'emoji':
                            notificationText = `发送了表情包：${messageData.description}`;
                            notificationType = 'emoji';
                            break;
                        default:
                            notificationText = messageData.content || '[消息]';
                    }
                } else {
                    notificationText = messageData.content || messageData.message || '[消息]';
                }
            }
            
            // 限制通知文本长度
            if (notificationText.length > 25) {
                notificationText = notificationText.substring(0, 25) + '...';
            }
            
            // 生成时间
            const now = new Date();
            const timeString = now.toLocaleTimeString('zh-CN', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            // 设置通知HTML
            notification.innerHTML = `
                <img class="notification-avatar" src="${character.avatarUrl || 'https://via.placeholder.com/28'}" alt="${senderName}">
                <div class="notification-content">
                    <div class="notification-title">${senderName}</div>
                    <div class="notification-message">${notificationText}</div>
                </div>
                <div class="notification-time">${timeString}</div>
            `;
            
            // 点击通知打开聊天
            notification.onclick = () => {
                console.log('🔔 [推送通知] 用户点击了推送通知，跳转到聊天界面');
                
                // 如果有角色信息，确保切换到对应角色
                if (character && character.id) {
                    console.log('🔔 [推送通知] 切换到角色:', character.name, character.id);
                    // 设置当前聊天角色
                    currentChatCharacter = character;
                    // 更新聊天界面标题
                    const chatTitle = document.getElementById('api-chat-title');
                    if (chatTitle) {
                        chatTitle.textContent = character.name;
                    }
                    // 渲染该角色的聊天记录
                    renderChatMessages(character.id);
                }
                
                // 切换到聊天界面
                showApp('api-chat-screen');
                
                // 移除通知
                hideNotification(notification);
                
                console.log('🔔 [推送通知] 跳转完成');
            };
            
            // 添加到容器
            container.appendChild(notification);
            
            // 显示动画
            setTimeout(() => {
                notification.classList.add('show');
            }, 50);
            
            // 自动隐藏 - 1.5秒后自动消失
            setTimeout(() => {
                if (currentNotification === notification) {
                    hideNotification(notification);
                }
            }, 1500);
        }
        
        function hideNotification(notification, immediate = false) {
            if (notification && notification.parentNode) {
                notification.classList.remove('show');
                notification.classList.add('hide');
                
                // 如果是当前通知，清除引用
                if (currentNotification === notification) {
                    currentNotification = null;
                }
                
                const removeDelay = immediate ? 0 : 250;
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, removeDelay);
            }
        }
        
        // 🔥【新增】为动态互动创建推送通知
        function createMomentInteractionNotification(character, interactionType, momentText) {
            let notificationText = '';
            switch (interactionType) {
                case 'like':
                    notificationText = `赞了你的动态`;
                    break;
                case 'comment':
                    notificationText = `评论了你的动态`;
                    break;
                default:
                    notificationText = `与你的动态互动了`;
            }
            
            createPushNotification(character, notificationText);
        }

        // 初始化转账功能事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            // 添加转账相关事件监听器
            document.getElementById('transfer-cancel-btn')?.addEventListener('click', () => {
                document.getElementById('transfer-modal').classList.remove('visible');
            });
            
            document.getElementById('transfer-confirm-btn')?.addEventListener('click', sendTransfer);
            document.getElementById('transfer-accept-btn')?.addEventListener('click', acceptTransfer);
            document.getElementById('transfer-reject-btn')?.addEventListener('click', rejectTransfer);
            
            // 点击模态框背景关闭
            document.getElementById('transfer-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('transfer-modal')) {
                    document.getElementById('transfer-modal').classList.remove('visible');
                }
            });
            
            document.getElementById('transfer-confirm-modal')?.addEventListener('click', (e) => {
                if (e.target === document.getElementById('transfer-confirm-modal')) {
                    document.getElementById('transfer-confirm-modal').classList.remove('visible');
                    currentTransferMsg = null;
                }
            });
        });

        // 群聊相关函数
        function updateGroupChatInfo() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // 更新群聊头像预览
            const groupAvatarPreview = document.getElementById('group-avatar-preview');
            if (groupAvatarPreview) {
                if (currentChatCharacter.avatarUrl) {
                    groupAvatarPreview.src = currentChatCharacter.avatarUrl;
                } else {
                    // 使用默认的群聊头像 - 创建一个简单的Canvas头像
                    const canvas = document.createElement('canvas');
                    canvas.width = 40;
                    canvas.height = 40;
                    const ctx = canvas.getContext('2d');
                    
                    // 绘制蓝色圆形背景
                    ctx.beginPath();
                    ctx.arc(20, 20, 20, 0, 2 * Math.PI);
                    ctx.fillStyle = '#4a84c1';
                    ctx.fill();
                    
                    // 绘制白色"群"字
                    ctx.fillStyle = 'white';
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('群', 20, 20);
                    
                    groupAvatarPreview.src = canvas.toDataURL();
                }
            }
            
            // 更新群聊名称显示
            const groupNameDisplay = document.getElementById('group-name-display');
            if (groupNameDisplay) {
                groupNameDisplay.textContent = currentChatCharacter.name || '群聊名称';
            }
            
            // 更新群成员数量显示
            const groupMemberCountDisplay = document.getElementById('group-member-count-display');
            if (groupMemberCountDisplay) {
                const memberCount = currentChatCharacter.members ? currentChatCharacter.members.length : 0;
                // 群成员数量 = 角色数量 + 1个用户
                const totalMemberCount = memberCount + 1;
                groupMemberCountDisplay.textContent = `${totalMemberCount}名成员`;
            }
            
            // 更新群公告显示
            const groupDescriptionDisplay = document.getElementById('group-description-display');
            if (groupDescriptionDisplay) {
                groupDescriptionDisplay.textContent = currentChatCharacter.description || '群公告：点击设置群公告';
            }
            
            // 更新我在群里的昵称 - 使用当前选择的面具名称作为默认值
            const currentMyGroupNickname = document.getElementById('current-my-group-nickname');
            if (currentMyGroupNickname) {
                let defaultNickname = '未选择';
        
        // --- 新增代码开始 ---
        const chatSettings = getCurrentChatSettings();
        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
        // --- 新增代码结束 ---

                // 如果用户选择了面具，使用面具名称
        if (selectedPersona && selectedPersona.name) { // <--- 修改这里
            defaultNickname = selectedPersona.name;
                }
        
        // 优先显示用户在群聊中自己设置的昵称，如果没有，则显示创建群聊时选择的身份昵称
        currentMyGroupNickname.textContent = chatSettings.myChatNickname || defaultNickname;
            }
            
            // 渲染群成员网格
            renderGroupMembersGrid();
        }
        
        function changeGroupAvatar() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            const tempInput = document.createElement('input');
            tempInput.type = 'file';
            tempInput.accept = 'image/*';
            tempInput.style.display = 'none';
            document.body.appendChild(tempInput);
            
            tempInput.onchange = function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = async function(event) {
                        // 更新当前群聊角色的头像
                        currentChatCharacter.avatarUrl = event.target.result;
                        
                        // 如果是群聊，需要更新群聊数据
                        if (groupChats) {
                            const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                            if (groupIndex !== -1) {
                                groupChats[groupIndex].avatarUrl = event.target.result;
                                await saveGroupChats(groupChats);
                            }
                        }
                        
                        // 更新UI显示
                        updateGroupChatInfo();
                        document.getElementById('api-chat-title').textContent = currentChatCharacter.name;
                        
                        // 更新头像显示
                        const chatAvatarElement = document.querySelector('#api-chat-screen .message-avatar img');
                        if (chatAvatarElement) {
                            chatAvatarElement.src = event.target.result;
                        }
                        
                        // 更新消息列表和联系人列表中的群聊头像
                        renderContactList();
                        renderMessageList();
                        
                        document.body.removeChild(tempInput);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                } else {
                    document.body.removeChild(tempInput);
                }
            };
            
            tempInput.click();
        }
        
        function changeGroupName() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            const newName = prompt('请输入新的群聊名称:', currentChatCharacter.name);
            if (newName && newName.trim() !== '') {
                const trimmedName = newName.trim();
                
                // 更新当前群聊角色的名称
                currentChatCharacter.name = trimmedName;
                
                // 如果是群聊，需要更新群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].name = trimmedName;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 更新UI显示
                updateGroupChatInfo();
                document.getElementById('api-chat-title').textContent = trimmedName;
                renderContactList();
                renderMessageList();
            }
        }
        
// --- 请从这里开始复制，替换掉旧的 showGroupChatMemberSelection 和 renderGroupMembersGrid 函数 ---

// 5. 显示群成员选择 (已修正版本)
function showGroupChatMemberSelection(personaId) {
    console.log('✅ 第二个showGroupChatMemberSelection被调用，接收到的personaId:', personaId);
    
    // 立即将personaId存储到全局变量中，确保不会丢失
    window.currentGroupPersonaId = personaId;
    
    // 重置表单
    document.getElementById('group-chat-name').value = '';
    selectedGroupMembers = [];
    
    const membersContainer = document.getElementById('group-chat-members');
    membersContainer.innerHTML = '';
    
    if (characters.length < 2) {
        membersContainer.innerHTML = '<p class="empty-mount-chats">至少需要2个角色才能创建群聊</p>';
    } else {
        characters.forEach(character => {
            const memberItem = document.createElement('div');
            memberItem.className = 'group-member-item';
            memberItem.onclick = () => toggleGroupMemberSelection(character.id);
            // 关键修复：重新添加了显示角色简介的HTML代码
            memberItem.innerHTML = `
                <div class="group-member-checkbox" id="checkbox-${character.id}"></div>
                <div class="message-avatar" style="background-color: ${character.color}; ${character.avatarUrl ? `background-image: url('${character.avatarUrl}'); background-size: cover; background-position: center;` : ''}">
                    ${character.avatarUrl ? '' : character.name.charAt(0)}
                </div>
                <div class="chat-option-text">
                    <div class="chat-option-title">${character.name}</div>
                    <div class="chat-option-desc">${truncateText(character.bio || '暂无简介', 80)}</div>
                </div>`;
            membersContainer.appendChild(memberItem);
        });
    }

    // 将 personaId 附加到创建按钮上
    console.log('✅ 在第二个位置绑定创建按钮，personaId:', personaId);
    const createBtn = document.getElementById('group-chat-modal').querySelector('.modal-primary');
    createBtn.onclick = () => {
        console.log('✅ 第二个位置的创建群聊按钮被点击，直接使用参数personaId:', personaId);
        createGroupChat(personaId);
    }; // 绑定带参数的创建函数

    showModal('group-chat-modal');
}


// 渲染群成员网格 (已修正版本)
        function renderGroupMembersGrid() {
            const groupMembersGrid = document.getElementById('group-members-grid');
            if (!groupMembersGrid || !currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // 清空现有内容
            groupMembersGrid.innerHTML = '';
            
    // --- 关键修复：正确获取并显示用户在当前群聊中的身份 ---
    const chatSettings = getCurrentChatSettings(); // 获取当前群聊的专属设置
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    
            let userName = '用户';
            let userAvatar = '';
            
    if (selectedPersona) {
        // 优先使用群聊设置里为“我”单独设置的昵称和头像
        userName = chatSettings.myChatNickname || selectedPersona.name;
        userAvatar = chatSettings.myChatAvatar || selectedPersona.avatarUrl;
    }
    
    // 添加用户自己（排在第一位）
    const userItem = document.createElement('div');
    userItem.className = 'member-item user-member';
    userItem.onclick = () => changeMyGroupAvatar();
            userItem.innerHTML = `
                <img class="member-avatar" src="${userAvatar || createDefaultAvatar(userName)}" alt="${userName}">
                <div class="member-name">${userName}</div>
            `;
            groupMembersGrid.appendChild(userItem);
    // --- 修复结束 ---
            
            // 然后添加群内现有角色
            if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                currentChatCharacter.members.forEach(member => {
                    const memberItem = document.createElement('div');
                    memberItem.className = 'member-item';
                    
                    memberItem.innerHTML = `
                        <div class="member-avatar-wrapper">
                            <img class="member-avatar clickable-avatar" 
                                 src="${member.avatarUrl || createDefaultAvatar(member.name)}" 
                                 alt="${member.name}"
                                 onclick="changeMemberAvatar('${member.id}', event)"
                                 title="点击更换${member.name}的头像">
                            <div class="avatar-hover-hint">
                                <i class="fas fa-camera"></i>
                            </div>
                        </div>
                        <div class="member-name">${member.name}</div>
                    `;
                    groupMembersGrid.appendChild(memberItem);
                });
            }
            
            // 添加邀请按钮
            const addMemberBtn = document.createElement('div');
            addMemberBtn.className = 'member-item add-member';
            addMemberBtn.onclick = () => addGroupMember();
            addMemberBtn.innerHTML = `
                <div class="member-avatar add-avatar">
                    <i class="fas fa-plus"></i>
                </div>
                <div class="member-name">邀请</div>
            `;
            groupMembersGrid.appendChild(addMemberBtn);
            
            // 只要群内有角色成员就显示移除按钮
            if (currentChatCharacter.members && currentChatCharacter.members.length > 0) {
                const removeMemberBtn = document.createElement('div');
                removeMemberBtn.className = 'member-item remove-member';
                removeMemberBtn.onclick = () => removeGroupMember();
                removeMemberBtn.innerHTML = `
                    <div class="member-avatar remove-avatar">
                        <i class="fas fa-minus"></i>
                    </div>
                    <div class="member-name">移除</div>
                `;
                groupMembersGrid.appendChild(removeMemberBtn);
            }
        }

// --- 请复制到这里结束 ---
        
        // 显示成员详情
        function showMemberProfile(member) {
            alert(`👤 群成员信息\n\n昵称：${member.name}\n角色ID：${member.id}\n\n点击头像可以查看角色详细信息`);
        }
        
        // 显示用户自己的资料
        function showUserProfile() {
            let userName = '用户';
            let userInfo = '群聊成员';
            
            if (currentPersona) {
                userName = currentPersona.name;
                userInfo = `当前面具：${currentPersona.name}`;
                if (currentPersona.description) {
                    userInfo += `\n面具描述：${currentPersona.description}`;
                }
            } else if (currentChatCharacter.myNickname) {
                userName = currentChatCharacter.myNickname;
                userInfo = `群昵称：${currentChatCharacter.myNickname}`;
            }
            
            alert(`👤 我的信息\n\n昵称：${userName}\n身份：${userInfo}\n\n这是你自己在群聊中的信息`);
        }
        
        // 创建默认头像
        function createDefaultAvatar(name) {
            const canvas = document.createElement('canvas');
            canvas.width = 50;
            canvas.height = 50;
            const ctx = canvas.getContext('2d');
            
            // 随机背景颜色
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];
            const bgColor = colors[name.charCodeAt(0) % colors.length];
            
            // 绘制圆形背景
            ctx.beginPath();
            ctx.arc(25, 25, 25, 0, 2 * Math.PI);
            ctx.fillStyle = bgColor;
            ctx.fill();
            
            // 绘制文字
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(name.charAt(0), 25, 25);
            
            return canvas.toDataURL();
        }
        
        function showGroupMembers() {
            alert('👥 群成员管理功能开发中...\n\n将支持以下功能：\n• 查看群成员列表\n• 设置群管理员\n• 管理群成员权限\n• 禁言/踢出群聊');
        }
        
        async function changeMyGroupNickname() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
    const chatSettings = getCurrentChatSettings();
    const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
    
    const currentNickname = chatSettings.myChatNickname || (selectedPersona ? selectedPersona.name : '用户');
    const newNickname = prompt('请输入我在本群的昵称:', currentNickname);

    if (newNickname && newNickname.trim() !== '' && newNickname.trim() !== currentNickname) {
                const trimmedNickname = newNickname.trim();
                
        // 1. 更新当前群聊设置中的昵称
        chatSettings.myChatNickname = trimmedNickname;
        await saveCurrentChatSettings(chatSettings);
        
        // 2. 创建并添加系统消息
        const systemMessage = {
            id: 'system_' + Date.now(),
            sender: 'system',
            content: `你已将群昵称修改为 "${trimmedNickname}"`,
            timestamp: Date.now()
        };
        
        if (!chatMessages[currentChatCharacter.id]) {
            chatMessages[currentChatCharacter.id] = [];
        }
        chatMessages[currentChatCharacter.id].push(systemMessage);
        await saveChatMessages();
        
        // 3. 更新UI
        updateGroupChatInfo(); // 这会刷新设置页面的显示
        renderChatMessages(currentChatCharacter.id); // 刷新聊天界面显示系统消息

        showToast('群昵称修改成功！', 'success');
    }
}
// --- 新增函数 ---
async function changeMyGroupAvatar() {
    if (!currentChatCharacter) return;

    // 创建一个临时的文件输入框
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.style.display = 'none';

    // 当用户选择了文件后
    input.onchange = async (e) => {
        if (!e.target.files || !e.target.files[0]) return;
        
        const file = e.target.files[0];
        const reader = new FileReader();

        reader.onload = async (event) => {
            const newAvatarUrl = event.target.result;

            // 1. 更新当前群聊设置中的头像
            const chatSettings = getCurrentChatSettings();
            chatSettings.myChatAvatar = newAvatarUrl;
            await saveCurrentChatSettings(chatSettings);
            
            // 2. 创建并添加系统消息
            const systemMessage = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `你更换了新头像`,
                timestamp: Date.now()
            };

            if (!chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            chatMessages[currentChatCharacter.id].push(systemMessage);
            await saveChatMessages();

            // 3. 更新UI
            updateGroupChatInfo(); // 刷新设置页面的成员列表
            renderChatMessages(currentChatCharacter.id); // 刷新聊天界面显示新头像和系统消息

            showToast('群头像更换成功！', 'success');
        };
        
        reader.readAsDataURL(file);
        document.body.removeChild(input); // 清理临时的input元素
    };

    document.body.appendChild(input);
    input.click(); // 弹出文件选择窗口
        }
        
        // 编辑群公告
        function editGroupDescription() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            showGroupNoticeModal();
        }
        
        // 显示群公告编辑模态框
        function showGroupNoticeModal() {
            const modal = document.getElementById('group-notice-modal');
            const textarea = document.getElementById('group-notice-content');
            const charCount = document.getElementById('notice-char-current');
            
            // 设置当前群公告内容
            const currentDescription = currentChatCharacter?.description || '';
            textarea.value = currentDescription;
            charCount.textContent = currentDescription.length;
            
            // 监听字符数变化
            textarea.addEventListener('input', updateNoticeCharCount);
            
            modal.style.display = 'flex';
            setTimeout(() => textarea.focus(), 100);
        }
        
        // 隐藏群公告编辑模态框
        function hideGroupNoticeModal() {
            const modal = document.getElementById('group-notice-modal');
            const textarea = document.getElementById('group-notice-content');
            
            // 移除事件监听器
            textarea.removeEventListener('input', updateNoticeCharCount);
            
            modal.style.display = 'none';
        }
        
        // 更新字符计数
        function updateNoticeCharCount() {
            const textarea = document.getElementById('group-notice-content');
            const charCount = document.getElementById('notice-char-current');
            charCount.textContent = textarea.value.length;
            
            // 如果超过限制，变色提示
            if (textarea.value.length > 500) {
                charCount.style.color = '#ff3b30';
            } else if (textarea.value.length > 450) {
                charCount.style.color = '#ff9500';
            } else {
                charCount.style.color = '#007AFF';
            }
        }
        
        // 保存群公告
        function saveGroupNotice() {
            const textarea = document.getElementById('group-notice-content');
            const newDescription = textarea.value.trim();
            
            if (newDescription.length > 500) {
                alert('群公告内容不能超过500字');
                return;
            }
            
                // 更新当前群聊角色的描述
            currentChatCharacter.description = newDescription;
                
                // 如果是群聊，需要更新群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                    groupChats[groupIndex].description = newDescription;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 更新UI显示
                updateGroupChatInfo();
            hideGroupNoticeModal();
            
            // 显示成功提示
            showToast('✅ 群公告保存成功', 'success');
        }
        
        // 添加群成员 - 从现有角色中选择
        function addGroupMember() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup) return;
            
            // 获取所有角色列表
            if (!characters || characters.length === 0) {
                alert('暂无可邀请的角色，请先创建角色');
                return;
            }
            
            // 过滤掉已经在群里的角色
            const currentMemberIds = currentChatCharacter.members ? currentChatCharacter.members.map(m => m.id) : [];
            const availableCharacters = characters.filter(char => !currentMemberIds.includes(char.id));
            
            if (availableCharacters.length === 0) {
                alert('所有角色都已经在群里了');
                return;
            }
            
            // 创建美观的选择界面
            showCharacterSelectionModal(availableCharacters, '邀请群成员', '请选择要邀请进群的角色：', (selectedCharacter) => {
                // 添加到群成员列表
                if (!currentChatCharacter.members) {
                    currentChatCharacter.members = [];
                }
                currentChatCharacter.members.push({
                    id: selectedCharacter.id,
                    name: selectedCharacter.name,
                    avatarUrl: selectedCharacter.avatarUrl
                });
                
                // 保存群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].members = currentChatCharacter.members;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 更新UI
                updateGroupChatInfo();
                renderMessageList(); // 更新消息列表
                showToast(`✅ ${selectedCharacter.name} 已加入群聊`, 'success');
            });
        }
        
        // 移除群成员
        function removeGroupMember() {
            if (!currentChatCharacter || !currentChatCharacter.isGroup || !currentChatCharacter.members) return;
            
            if (currentChatCharacter.members.length <= 1) {
                alert('群聊至少需要保留一个角色成员（不包括用户自己）');
                return;
            }
            
            // 创建美观的选择界面
            showCharacterSelectionModal(currentChatCharacter.members, '移除群成员', '请选择要移出群聊的成员：', (selectedMember) => {
                if (confirm(`确定要将 ${selectedMember.name} 移出群聊吗？`)) {
                    // 从群成员列表中移除
                    const memberIndex = currentChatCharacter.members.findIndex(m => m.id === selectedMember.id);
                    if (memberIndex !== -1) {
                        currentChatCharacter.members.splice(memberIndex, 1);
                        
                        // 保存群聊数据
                        if (groupChats) {
                            const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                            if (groupIndex !== -1) {
                                groupChats[groupIndex].members = currentChatCharacter.members;
                                saveGroupChats(groupChats);
                            }
                        }
                        
                        // 更新UI
                        updateGroupChatInfo();
                        renderMessageList(); // 更新消息列表
                        showToast(`✅ ${selectedMember.name} 已被移出群聊`, 'success');
                    }
                }
            });
        }
        
        // 群公告功能
        function showGroupNotice() {
            const notice = currentChatCharacter?.description || '暂无群公告';
            alert(`📢 群公告\n\n${notice}\n\n点击群信息卡片的公告区域可以编辑群公告`);
        }
        

        
        // 群应用功能
        function showGroupVote() {
            alert('🗳️ 群投票功能开发中...\n\n将支持以下功能：\n• 创建投票话题\n• 设置投票选项\n• 实时投票结果\n• 投票截止时间');
        }
        
        function showGroupActivity() {
            alert('📅 群活动功能开发中...\n\n将支持以下功能：\n• 创建群活动\n• 活动报名统计\n• 活动提醒\n• 活动签到');
        }
        
        function showGroupTask() {
            alert('✅ 群任务功能开发中...\n\n将支持以下功能：\n• 发布群任务\n• 任务认领\n• 完成状态跟踪\n• 积分奖励系统');
        }
        
        function showMoreApps() {
            alert('🔧 更多群应用\n\n即将推出：\n• 群直播\n• 群游戏\n• 群红包\n• 群机器人\n• 群日程\n• 群笔记');
        }
        
        // 显示角色选择模态框
        function showCharacterSelectionModal(characterList, title, description, onSelect) {
            const modalHTML = `
                <div class="modal character-selection-modal" id="character-selection-modal" style="display: flex;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title">${title}</h3>
                            <button class="modal-close" onclick="hideCharacterSelectionModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <p class="selection-description">${description}</p>
                            <div class="character-selection-grid" id="character-selection-grid">
                                ${characterList.map(char => `
                                    <div class="character-selection-item" data-character-id="${char.id}">
                                        <div class="character-selection-avatar">
                                            <img src="${char.avatarUrl || createDefaultAvatar(char.name)}" alt="${char.name}">
                                        </div>
                                        <div class="character-selection-info">
                                            <div class="character-selection-name">${char.name}</div>
                                            <div class="character-selection-bio">${(char.description || char.bio || '暂无简介').substring(0, 30)}${(char.description || char.bio || '').length > 30 ? '...' : ''}</div>
                                        </div>
                                        <div class="character-selection-check">
                                            <i class="fas fa-check"></i>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-secondary" onclick="hideCharacterSelectionModal()">取消</button>
                            <button class="modal-primary" id="confirm-selection-btn" onclick="confirmCharacterSelection()" disabled>确定</button>
                        </div>
                    </div>
                </div>
            `;
            
            const existingModal = document.getElementById('character-selection-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            window.characterSelectionCallback = onSelect;
            window.selectedCharacterId = null;
            
            document.querySelectorAll('.character-selection-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelectorAll('.character-selection-item').forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    window.selectedCharacterId = this.dataset.characterId;
                    document.getElementById('confirm-selection-btn').disabled = false;
                });
            });
        }
        
        // 隐藏角色选择模态框
        function hideCharacterSelectionModal() {
            const modal = document.getElementById('character-selection-modal');
            if (modal) {
                modal.remove();
            }
            window.characterSelectionCallback = null;
            window.selectedCharacterId = null;
        }
        
        // 确认角色选择
        function confirmCharacterSelection() {
            if (!window.selectedCharacterId || !window.characterSelectionCallback) return;
            
            const allCharacters = [...characters, ...(currentChatCharacter.members || [])];
            const selectedCharacter = allCharacters.find(char => char.id === window.selectedCharacterId);
            
            if (selectedCharacter) {
                window.characterSelectionCallback(selectedCharacter);
                hideCharacterSelectionModal();
            }
        }
        
        // 🔥【新增】群成员头像更换功能
        function changeMemberAvatar(memberId, event) {
            event.stopPropagation(); // 阻止事件冒泡
            
            const member = currentChatCharacter.members.find(m => m.id === memberId);
            if (!member) return;
            
            // 显示头像更换模态框
            showMemberAvatarModal(member);
        }

        // 🔥【新增】显示群成员头像更换模态框
        function showMemberAvatarModal(member) {
            const modal = document.getElementById('member-avatar-modal');
            const preview = document.getElementById('member-avatar-preview');
            const memberName = document.getElementById('member-avatar-name');
            const uploadInput = document.getElementById('member-avatar-upload');
            
            // 设置当前成员信息
            window.currentEditingMember = member;
            memberName.textContent = member.name;
            preview.src = member.avatarUrl || createDefaultAvatar(member.name);
            
            // 重置文件输入
            uploadInput.value = '';
            
            modal.style.display = 'flex';
        }

        // 🔥【新增】隐藏群成员头像更换模态框
        function hideMemberAvatarModal() {
            const modal = document.getElementById('member-avatar-modal');
            modal.style.display = 'none';
            window.currentEditingMember = null;
        }

        // 🔥【新增】处理群成员头像上传
        function handleMemberAvatarUpload() {
            const uploadInput = document.getElementById('member-avatar-upload');
            uploadInput.click();
        }

        // 🔥【新增】保存群成员头像
        function saveMemberAvatar() {
            if (!window.currentEditingMember) return;
            
            const preview = document.getElementById('member-avatar-preview');
            const newAvatarUrl = preview.src;
            
            // 更新群成员头像
            const memberIndex = currentChatCharacter.members.findIndex(m => m.id === window.currentEditingMember.id);
            if (memberIndex !== -1) {
                currentChatCharacter.members[memberIndex].avatarUrl = newAvatarUrl;
                
                // 同时更新全局角色列表中的头像
                const characterIndex = characters.findIndex(c => c.id === window.currentEditingMember.id);
                if (characterIndex !== -1) {
                    characters[characterIndex].avatarUrl = newAvatarUrl;
                    saveCharacters(characters);
                }
                
                // 保存群聊数据
                if (groupChats) {
                    const groupIndex = groupChats.findIndex(g => g.id === currentChatCharacter.id);
                    if (groupIndex !== -1) {
                        groupChats[groupIndex].members = currentChatCharacter.members;
                        saveGroupChats(groupChats);
                    }
                }
                
                // 🔥【新增】在群聊消息中添加头像更换提示
                addAvatarChangeMessage(window.currentEditingMember.name);
                
                // 更新UI
                updateGroupChatInfo();
                renderGroupMembersGrid();
                refreshChatMessages(); // 刷新聊天消息显示新头像
                
                showToast(`✅ ${window.currentEditingMember.name} 的头像已更新`, 'success');
            }
            
            hideMemberAvatarModal();
        }

        // 🔥【新增】添加头像更换系统消息
        function addAvatarChangeMessage(memberName) {
            if (!currentChatCharacter || !chatMessages[currentChatCharacter.id]) {
                chatMessages[currentChatCharacter.id] = [];
            }
            
            const systemMessage = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `${memberName} 更换了头像`,
                timestamp: Date.now(),
                isSystem: true
            };
            
            chatMessages[currentChatCharacter.id].push(systemMessage);
            saveChatMessages();
            
            // 刷新聊天界面
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
        }

        // 🔥【新增】刷新聊天消息以显示新头像
        function refreshChatMessages() {
            if (currentChatCharacter) {
                renderChatMessages(currentChatCharacter.id);
            }
        }

        // 🔥【新增】重置群成员头像为默认
        function resetMemberAvatar() {
            if (!window.currentEditingMember) return;
            
            const preview = document.getElementById('member-avatar-preview');
            const defaultAvatar = createDefaultAvatar(window.currentEditingMember.name);
            preview.src = defaultAvatar;
        }

        // 🔥【新增】数据恢复检查和修复功能
        async function checkAndFixChatHistory() {
            try {
                console.log('开始检查聊天历史数据...');
                
                // 检查IndexedDB中的数据
                const dbMessages = await db.chatMessages.toArray();
                const memoryMessages = chatMessages;
                
                console.log('IndexedDB中的消息数:', dbMessages.length);
                console.log('内存中的聊天数:', Object.keys(memoryMessages).length);
                
                // 检查是否有localStorage的备份数据
                const localStorageBackup = localStorage.getItem('chatMessages');
                if (localStorageBackup) {
                    try {
                        const backupData = JSON.parse(localStorageBackup);
                        console.log('找到localStorage备份数据');
                        
                        // 比较数据时间戳，选择最新的
                        let shouldUseBackup = false;
                        let newerMessagesCount = 0;
                        
                        for (const [characterId, messages] of Object.entries(backupData)) {
                            if (messages && messages.length > 0) {
                                const latestBackupTime = Math.max(...messages.map(m => m.timestamp || 0));
                                const currentMessages = memoryMessages[characterId] || [];
                                const latestCurrentTime = currentMessages.length > 0 ? 
                                    Math.max(...currentMessages.map(m => m.timestamp || 0)) : 0;
                                
                                if (latestBackupTime > latestCurrentTime) {
                                    console.log(`角色 ${characterId} 的备份数据更新 (备份:${new Date(latestBackupTime)}, 当前:${new Date(latestCurrentTime)})`);
                                    shouldUseBackup = true;
                                    newerMessagesCount += messages.length - currentMessages.length;
                                }
                            }
                        }
                        
                        if (shouldUseBackup) {
                            const confirmRestore = confirm(`检测到localStorage中有更新的聊天记录！\n\n发现 ${newerMessagesCount} 条更新的消息\n\n是否恢复这些数据？`);
                            if (confirmRestore) {
                                // 恢复数据
                                Object.assign(chatMessages, backupData);
                                await saveChatMessages();
                                
                                // 重新渲染当前聊天
                                if (currentChatCharacter) {
                                    renderChatMessages(currentChatCharacter.id);
                                }
                                
                                showToast(`已恢复 ${newerMessagesCount} 条消息！`, 'success');
                                return true;
                            }
                        }
                    } catch (e) {
                        console.error('解析备份数据失败:', e);
                    }
                }
                
                // 检查是否有异常的时间戳（未来时间或过老时间）
                let fixedCount = 0;
                const now = Date.now();
                const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);
                
                for (const [characterId, messages] of Object.entries(chatMessages)) {
                    if (messages && Array.isArray(messages)) {
                        for (let i = 0; i < messages.length; i++) {
                            const msg = messages[i];
                            if (!msg.timestamp || msg.timestamp > now || msg.timestamp < oneWeekAgo) {
                                // 修复异常时间戳
                                const correctedTime = now - (messages.length - i) * 60000; // 按顺序递减1分钟
                                console.log(`修复消息时间戳: ${msg.timestamp} -> ${correctedTime}`);
                                msg.timestamp = correctedTime;
                                fixedCount++;
                            }
                        }
                        
                        // 重新排序消息
                        messages.sort((a, b) => a.timestamp - b.timestamp);
                    }
                }
                
                if (fixedCount > 0) {
                    await saveChatMessages();
                    showToast(`修复了 ${fixedCount} 条消息的时间戳`, 'info');
                }
                
                return false;
            } catch (error) {
                console.error('检查聊天历史失败:', error);
                return false;
            }
        }

        // 显示提示消息
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
                color: white;
                padding: 12px 24px;
                border-radius: 25px;
                font-size: 14px;
                z-index: 10000;
                opacity: 0;
                transition: all 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(-50%) translateY(10px)';
            }, 100);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(-50%) translateY(-10px)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // 文本截断函数
        function truncateText(text, maxLength = 80) {
            // 🔥【修复】确保text是字符串类型
            if (text === null || text === undefined) {
                return '';
            }
            
            // 如果不是字符串，转换为字符串
            if (typeof text !== 'string') {
                text = String(text);
            }
            
            if (!text || text.length <= maxLength) return text;
            
            // 按行分割文本
            const lines = text.split('\n');
            let result = '';
            let lineCount = 0;
            
            for (const line of lines) {
                // 限制最多显示3行
                if (lineCount >= 3) break;
                
                if (result.length + line.length + 1 <= maxLength) {
                    result += (result ? '\n' : '') + line;
                    lineCount++;
                } else {
                    // 如果这一行会超出长度限制，截断并添加省略号
                    const remaining = maxLength - result.length - 1;
                    if (remaining > 10) { // 确保有足够空间显示有意义的内容
                        result += (result ? '\n' : '') + line.substring(0, remaining - 3) + '...';
                    } else if (!result) {
                        // 如果是第一行就超长，直接截断
                        result = line.substring(0, maxLength - 3) + '...';
                    } else {
                        // 否则在当前结果后加省略号
                        result += '...';
                    }
                    break;
                }
            }
            
            return result;
        }
        
        // 🔥【新增】消息列表多选删除功能
        
        // 进入消息列表多选模式
        function enterMessageListMultiSelectMode(conversationId) {
            console.log('触发长按多选模式，对话ID:', conversationId); // 调试信息
            isMessageListMultiSelectMode = true;
            selectedConversations = [conversationId]; // 将触发长按的对话添加到选中列表
            renderMessageList(); // 重新渲染列表以显示多选界面
            showToast('已进入多选模式，可以选择多个对话进行删除', 'info');
        }
        
        // 退出消息列表多选模式
        function exitMessageListMultiSelectMode() {
            isMessageListMultiSelectMode = false;
            selectedConversations = [];
            renderMessageList(); // 重新渲染列表恢复正常状态
        }
        
        // 切换对话选择状态
        function toggleConversationSelection(conversationId) {
            const index = selectedConversations.indexOf(conversationId);
            if (index > -1) {
                selectedConversations.splice(index, 1);
            } else {
                selectedConversations.push(conversationId);
            }
            renderMessageList(); // 重新渲染以更新选择状态
        }
        
        // 删除选中的对话
        async function deleteSelectedConversations() {
            if (selectedConversations.length === 0) {
                showToast('请先选择要删除的对话', 'error');
                return;
            }
            
            const count = selectedConversations.length;
            const confirmText = `确定要删除选中的 ${count} 个对话吗？\n\n删除后将清空对话的所有聊天记录和专属设置，此操作不可恢复。`;
            
            if (confirm(confirmText)) {
                try {
                    // 使用 for...of 循环来确保异步操作一个接一个完成
                    for (const conversationId of selectedConversations) {
                        // 1. 删除聊天消息
                    if (chatMessages[conversationId]) {
                        delete chatMessages[conversationId];
                    }
                    
                        // 2. [核心修复] 从数据库中删除此对话的设置
                        await db.chatSettings.delete(conversationId);
                        //    同时从内存中也删除，保持同步
                        if (chatSettings[conversationId]) {
                            delete chatSettings[conversationId];
                        }
                        
                        // 2.1 [额外修复] 删除localStorage中的备份设置
                        localStorage.removeItem(`chatSettings_${conversationId}`);
                        
                        // 2.2 [彻底修复] 删除角色对象中的背景设置
                        const character = characters.find(c => c.id === conversationId);
                        if (character) {
                            character.background = null;
                            // 这里不需要立即保存，后面会统一保存
                        }

                        // 3. 正确处理单聊和群聊的删除
                    const groupIndex = groupChats.findIndex(g => g.id === conversationId);
                    if (groupIndex > -1) {
                            // 如果是群聊，从群聊列表中删除
                        groupChats.splice(groupIndex, 1);
                    } else {
                            // 如果是单聊，从联系人列表中移除
                        const contactIndex = contacts.indexOf(conversationId);
                        if (contactIndex > -1) {
                            contacts.splice(contactIndex, 1);
                        }
                    }
                    }

                    // 4. [异步保存] 等待所有数据保存操作完成
                    await Promise.all([
                        saveChatMessages(),
                        saveGroupChats(),
                        saveContacts(),
                        saveCharacters() // 确保保存角色数据，包括背景设置
                    ]);

                    // 5. 退出多选模式并刷新UI
                    exitMessageListMultiSelectMode(); // 这个函数内部会调用 renderMessageList()
                
                showToast(`✅ 已删除 ${count} 个对话`, 'success');

                } catch (error) {
                    console.error("删除对话时出错:", error);
                    showToast('删除失败，请检查控制台错误信息', 'error');
                }
            }
        }

    </script>
    
    <!-- 🔥【新增】群成员头像更换模态框 -->
    <div class="modal" id="member-avatar-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">更换成员头像</h3>
                <button class="modal-close" onclick="hideMemberAvatarModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="member-avatar-form">
                    <div class="current-member-info">
                        <h4 id="member-avatar-name" class="member-name-title">角色名称</h4>
                        <p class="member-info-desc">为该角色设置新的头像，将在群聊中立即生效</p>
                    </div>
                    
                    <div class="avatar-upload-section">
                        <div class="avatar-preview-large">
                            <img id="member-avatar-preview" src="" alt="头像预览" class="preview-image">
                        </div>
                        
                        <div class="upload-buttons">
                            <button class="upload-btn primary" onclick="handleMemberAvatarUpload()">
                                <i class="fas fa-upload"></i>
                                选择新头像
                            </button>
                            <button class="upload-btn secondary" onclick="resetMemberAvatar()">
                                <i class="fas fa-undo"></i>
                                重置默认
                            </button>
                        </div>
                        
                        <input type="file" id="member-avatar-upload" accept="image/*" style="display: none;">
                    </div>
                    
                    <div class="avatar-tips">
                        <div class="tips-header">
                            <i class="fas fa-info-circle"></i>
                            <span>头像更换说明</span>
                        </div>
                        <div class="tips-content">
                            • 支持JPG、PNG等常见图片格式<br>
                            • 建议使用正方形图片，效果更佳<br>
                            • 头像更换后将在群聊中立即显示<br>
                            • 角色也可以在聊天时自主更换头像
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-button modal-secondary" onclick="hideMemberAvatarModal()">取消</button>
                <button class="modal-button modal-primary" onclick="saveMemberAvatar()">保存更改</button>
            </div>
        </div>
    </div>

    <!-- 群公告编辑模态框 -->
    <div class="modal" id="group-notice-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">编辑群公告</h3>
                <button class="modal-close" onclick="hideGroupNoticeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="group-notice-form">
                    <div class="form-group">
                        <label class="form-label">群公告内容</label>
                        <textarea 
                            id="group-notice-content" 
                            class="form-textarea group-notice-textarea" 
                            placeholder="输入群公告内容...&#10;&#10;可以包括：&#10;• 群规则说明&#10;• 重要通知&#10;• 活动安排&#10;• 其他事项"
                            maxlength="500"></textarea>
                        <div class="notice-char-count">
                            <span id="notice-char-current">0</span>/500字
                        </div>
                    </div>
                    <div class="notice-tips">
                        <div class="tips-header">
                            <i class="fas fa-lightbulb"></i>
                            <span>公告小贴士</span>
                        </div>
                        <div class="tips-content">
                            • 简洁明了，突出重点<br>
                            • 使用友好的语调<br>
                            • 定期更新重要信息<br>
                            • 可以使用emoji增加趣味性
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideGroupNoticeModal()">取消</button>
                <button class="modal-primary" onclick="saveGroupNotice()">保存公告</button>
            </div>
        </div>
    </div>
    
    <!-- 定时发布时间设置模态框 -->
    <div class="modal" id="schedule-times-modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">定时发布时间设置</h3>
                <button class="modal-close" onclick="hideModal('schedule-times-modal')">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color: #666; font-size: 14px; margin-bottom: 15px;">
                    设置角色每天自动发布动态的时间点（最多10个）
                </p>
                <div id="schedule-times-modal-container">
                    <!-- 时间输入项将动态生成 -->
                </div>
                <button onclick="addScheduleTime()" style="margin-top: 10px; padding: 8px 16px; background: #007AFF; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    + 添加时间点
                </button>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideModal('schedule-times-modal')">取消</button>
                <button class="modal-primary" onclick="saveScheduleTimes()">保存</button>
            </div>
        </div>
    </div>

    <!-- 位置分享模态框 -->
    <div id="location-modal" class="modal" style="display: none;">
        <div class="modal-content location-modal-content">
            <div class="modal-header">
                <h3 class="modal-title">分享位置</h3>
                <button class="modal-close" onclick="hideLocationModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="location-input-section">
                    <label for="location-address">位置名称</label>
                    <input type="text" id="location-address" placeholder="请输入位置名称，如：咖啡厅、学校、家..." maxlength="50">
                    
                    <!-- 最近使用历史记录 -->
                    <div class="location-history" id="location-history">
                        <div class="location-history-title">📍 最近使用</div>
                        <div class="location-history-items" id="location-history-items">
                            <div class="location-history-empty">暂无历史记录</div>
                        </div>
                    </div>
                </div>
                <div class="virtual-map-container">
                    <div class="map-header" style="background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 100%);">
                        <div class="map-location-name" id="map-location-display" style="color: #52c41a;">请输入位置名称</div>
                        <div class="map-coordinates" style="color: #73d13d;">116.4074°E, 39.9042°N</div>
                    </div>
                    <div class="virtual-map">
                        <div class="map-background"></div>
                        <!-- 弯曲河流 -->
                        <div class="river" style="top: 8%; left: 55%; width: 25px; height: 4px; transform: rotate(30deg);"></div>
                        <div class="river-curve" style="top: 18%; left: 68%; width: 22px; height: 4px; transform: rotate(10deg);"></div>
                        <div class="river" style="top: 26%; left: 78%; width: 20px; height: 4px; transform: rotate(-10deg);"></div>
                        <div class="river-curve" style="top: 32%; left: 85%; width: 18px; height: 4px; transform: rotate(-30deg);"></div>
                        <div class="river" style="top: 60%; left: 5%; width: 28px; height: 4px; transform: rotate(-15deg);"></div>
                        <div class="river-curve" style="top: 68%; left: 25%; width: 25px; height: 4px; transform: rotate(5deg);"></div>
                        <div class="river" style="top: 75%; left: 42%; width: 22px; height: 4px; transform: rotate(20deg);"></div>
                        <!-- 公园绿地 -->
                        <div style="position: absolute; top: 25%; left: 65%; width: 25px; height: 20px; background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 50%, #b7eb8f 100%); border-radius: 3px; opacity: 0.6; z-index: 1;"></div>
                        <div style="position: absolute; top: 50%; left: 15%; width: 30px; height: 25px; background: linear-gradient(135deg, #f6ffed 0%, #d9f7be 50%, #b7eb8f 100%); border-radius: 3px; opacity: 0.6; z-index: 1;"></div>
                        <!-- 道路 -->
                        <div class="map-roads">
                            <div class="road road-horizontal" style="top: 30%; left: 0; width: 100%;"></div>
                            <div class="road road-vertical" style="left: 25%; top: 0; height: 100%;"></div>
                            <div class="road road-horizontal" style="top: 70%; left: 0; width: 100%;"></div>
                            <div class="road road-vertical" style="left: 75%; top: 0; height: 100%;"></div>
                        </div>
                        <!-- 建筑物 -->
                        <div class="map-buildings">
                            <div class="building" style="top: 10%; left: 35%; width: 20px; height: 15px; background: linear-gradient(135deg, #f0f0f0 0%, #d9d9d9 100%); border: 1px solid #bfbfbf; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 15%; left: 55%; width: 25px; height: 20px; background: linear-gradient(135deg, #e6f7ff 0%, #bae7ff 100%); border: 1px solid #91d5ff; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 40%; left: 10%; width: 18px; height: 12px; background: linear-gradient(135deg, #fff1f0 0%, #ffd8d6 100%); border: 1px solid #ffaaa5; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 45%; left: 85%; width: 22px; height: 18px; background: linear-gradient(135deg, #f0f0f0 0%, #d9d9d9 100%); border: 1px solid #bfbfbf; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 75%; left: 40%; width: 30px; height: 20px; background: linear-gradient(135deg, #e6f7ff 0%, #bae7ff 100%); border: 1px solid #91d5ff; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                            <div class="building" style="top: 80%; left: 15%; width: 20px; height: 15px; background: linear-gradient(135deg, #fff1f0 0%, #ffd8d6 100%); border: 1px solid #ffaaa5; border-radius: 1px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);"></div>
                        </div>
                        <!-- 树木 -->
                        <div style="position: absolute; top: 35%; left: 20%; width: 8px; height: 8px; background: radial-gradient(circle, #52c41a 0%, #389e0d 70%, #237804 100%); border-radius: 50%; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); z-index: 3;"></div>
                        <div style="position: absolute; top: 60%; left: 30%; width: 6px; height: 6px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <div style="position: absolute; top: 12%; left: 70%; width: 7px; height: 7px; background: radial-gradient(circle, #52c41a 0%, #389e0d 70%, #237804 100%); border-radius: 50%; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); z-index: 3;"></div>
                        <div style="position: absolute; top: 85%; left: 90%; width: 5px; height: 5px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <div style="position: absolute; top: 50%; left: 90%; width: 6px; height: 6px; background: radial-gradient(circle, #73d13d 0%, #52c41a 70%, #389e0d 100%); border-radius: 50%; box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.1); z-index: 3;"></div>
                        <!-- 位置标记 -->
                        <div class="map-marker" id="location-marker">
                            <div class="marker-pin" style="color: #1890ff;">📍</div>
                        </div>
                        <div class="map-current-location">
                            <div class="current-location-dot"></div>
                        </div>
                    </div>
                    <div class="map-footer">
                        <div class="map-scale">500m</div>
                        <div class="map-controls">
                            <button class="map-control-btn" onclick="randomizeMapPosition()">🎯 重新定位</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideLocationModal()">取消</button>
                <button class="modal-primary" onclick="sendLocationMessage()">发送位置</button>
            </div>
        </div>
    </div>
    </div>

    <script>
        // 🔥【新增】群成员头像上传事件监听
        document.addEventListener('DOMContentLoaded', function() {
            const memberAvatarUpload = document.getElementById('member-avatar-upload');
            if (memberAvatarUpload) {
                memberAvatarUpload.addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const file = e.target.files[0];
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const preview = document.getElementById('member-avatar-preview');
                            if (preview) {
                                preview.src = event.target.result;
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
        });
    </script>

    <!-- 🔥【永久修复】身份选择功能自动修复脚本 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔧 开始应用身份选择功能永久修复...');
            
            // 修复1: 重写showPersonaSelectionForSingleChat函数
            if (typeof showPersonaSelectionForSingleChat === 'function') {
                const originalShowPersonaSelectionForSingleChat = showPersonaSelectionForSingleChat;
                showPersonaSelectionForSingleChat = function() {
                    originalShowPersonaSelectionForSingleChat();
                    
                    // 延迟修复事件绑定，确保DOM已生成
                    setTimeout(() => {
                        const items = document.querySelectorAll('#persona-selection-modal .persona-selection-item');
                        console.log('🔧 修复身份选择事件绑定，找到元素:', items.length);
                        
                        items.forEach(item => {
                            // 移除旧的事件监听器
                            item.onclick = null;
                            
                            // 添加新的点击事件
                            item.addEventListener('click', function() {
                                console.log('身份选择点击:', this.dataset.personaId);
                                
                                // 移除所有选中状态
                                document.querySelectorAll('#persona-selection-modal .persona-selection-item').forEach(i => {
                                    i.classList.remove('selected');
                                });
                                
                                // 设置当前元素为选中
                                this.classList.add('selected');
                                
                                // 保存身份ID
                                window.selectedPersonaForChat = this.dataset.personaId;
                                console.log('设置selectedPersonaForChat:', window.selectedPersonaForChat);
                                
                                // 启用确认按钮
                                const confirmBtn = document.getElementById('confirm-persona-btn');
                                if (confirmBtn) {
                                    confirmBtn.disabled = false;
                                }
                            });
                        });
                    }, 100);
                };
            }
            
            // 修复2: 重写confirmPersonaAndShowCharacters函数
            if (typeof confirmPersonaAndShowCharacters === 'function') {
                confirmPersonaAndShowCharacters = function() {
                    console.log('confirmPersonaAndShowCharacters调用，身份ID:', window.selectedPersonaForChat);
                    
                    if (!window.selectedPersonaForChat) {
                        console.error('身份ID为空！');
                        return;
                    }
                    
                    // 保存身份ID
                    const savedPersonaId = window.selectedPersonaForChat;
                    
                    // 隐藏模态框
                    const modal = document.getElementById('persona-selection-modal');
                    if (modal) {
                        modal.remove();
                    }
                    
                    // 恢复身份ID
                    window.selectedPersonaForChat = savedPersonaId;
                    console.log('保护后的身份ID:', window.selectedPersonaForChat);
                    
                    showCharacterSelectionForSingleChat();
                };
            }
            
            // 修复3: 重写buildCharacterPrompt函数
            if (typeof buildCharacterPrompt === 'function') {
                const originalBuildCharacterPrompt = buildCharacterPrompt;
                buildCharacterPrompt = function(character, hasImage = false) {
                    // 调用原函数获取基础prompt
                    let characterPrompt = originalBuildCharacterPrompt(character, hasImage);
                    
                    // 移除原有的currentPersona逻辑，替换为从聊天设置读取
                    const chatSettings = getCurrentChatSettings();
                    if (chatSettings.selectedIdentityId) {
                        const selectedPersona = personas.find(p => p.id === chatSettings.selectedIdentityId);
                        if (selectedPersona) {
                            console.log('🔧 为角色', character.name, '使用身份:', selectedPersona.name);
                            
                            // 移除旧的身份信息（如果有）
                            const personaRegex = /\n\n# 对话者的角色设定：[\s\S]*?请根据用户的这个面具身份来进行对话。/;
                            characterPrompt = characterPrompt.replace(personaRegex, '');
                            
                            // 添加新的身份信息
                            const personaInfo = `\n\n# 对话者的角色设定：\n用户当前使用的面具是"${selectedPersona.name}"${selectedPersona.description ? `：${selectedPersona.description}` : ''}\n请根据用户的这个面具身份来进行对话。`;
                            
                            // 在角色设定后插入身份信息
                            const insertPoint = characterPrompt.indexOf('\n# 🔥【修复】表情包库信息');
                            if (insertPoint !== -1) {
                                characterPrompt = characterPrompt.slice(0, insertPoint) + personaInfo + characterPrompt.slice(insertPoint);
                            } else {
                                characterPrompt += personaInfo;
                            }
                        }
                    }
                    
                    return characterPrompt;
                };
            }
            
            console.log('✅ 身份选择功能永久修复已应用');
        });
    </script>

    <!-- 🔧【简单修复】群聊身份设置直接修复 -->
    <script>
        // 简单直接的群聊身份修复
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔧 [简单修复] 群聊身份设置修复启动...');
            
            // 重写createGroupChat函数，确保身份设置立即生效
            if (typeof window.createGroupChat === 'function') {
                const originalCreateGroupChat = window.createGroupChat;
                window.createGroupChat = async function(personaId) {
                    console.log('🔧 [修复] createGroupChat被调用，身份ID:', personaId);
                    
                    // 调用原函数，传递personaId参数
                    await originalCreateGroupChat.call(this, personaId);
                    
                    // 如果有选择身份，立即加载到内存
                    if (personaId && groupChats && groupChats.length > 0) {
                        const latestGroup = groupChats[groupChats.length - 1];
                        const savedSettings = localStorage.getItem(`chatSettings_${latestGroup.id}`);
                        
                        if (savedSettings) {
                            try {
                                const settings = JSON.parse(savedSettings);
                                window.chatSettings[latestGroup.id] = settings;
                                console.log('🔧 [修复] 群聊身份设置已加载到内存:', settings);
                            } catch (error) {
                                console.error('🔧 [修复] 解析群聊设置失败:', error);
                            }
                        }
                    }
                };
            }
            
            console.log('🔧 [简单修复] 群聊身份设置修复完成');
        });
    </script>

    <!-- 📱【移动端优化】输入框viewport行为修复 -->
    <script>
        // 移动端输入框优化
        (function() {
            'use strict';
            
            console.log('📱 [移动端优化] 输入框viewport行为修复启动...');
            
            let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            let isAndroid = /Android/.test(navigator.userAgent);
            let isMobile = isIOS || isAndroid;
            
            if (!isMobile) {
                console.log('📱 非移动端设备，跳过移动端优化');
                return;
            }
            
            // 获取所有可能的输入框
            function getAllInputs() {
                return document.querySelectorAll('textarea, input[type="text"], input[type="password"], input[type="email"], input[type="number"]');
            }
            
            // 防止iOS Safari自动缩放
            function preventZoom() {
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    viewportMeta.setAttribute('content', 
                        'width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no'
                    );
                }
            }
            
            // 恢复缩放功能
            function restoreZoom() {
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    viewportMeta.setAttribute('content', 
                        'width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=3.0, user-scalable=yes'
                    );
                }
            }
            
            // 输入框焦点处理
            function handleInputFocus(e) {
                console.log('📱 输入框获得焦点，防止自动缩放');
                
                // 防止iOS自动缩放
                if (isIOS) {
                    preventZoom();
                }
                
                // 确保输入框可见
                setTimeout(() => {
                    e.target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                }, 300);
            }
            
            // 输入框失焦处理
            function handleInputBlur(e) {
                console.log('📱 输入框失去焦点，恢复缩放功能');
                
                // 恢复缩放功能
                if (isIOS) {
                    setTimeout(() => {
                        restoreZoom();
                    }, 100);
                }
                
                // 滚动回顶部
                setTimeout(() => {
                    window.scrollTo(0, 0);
                }, 100);
            }
            
            // 绑定事件到所有输入框
            function bindInputEvents() {
                const inputs = getAllInputs();
                console.log(`📱 找到 ${inputs.length} 个输入框，正在绑定事件...`);
                
                inputs.forEach(input => {
                    // 移除旧的事件监听器（如果存在）
                    input.removeEventListener('focus', handleInputFocus);
                    input.removeEventListener('blur', handleInputBlur);
                    
                    // 添加新的事件监听器
                    input.addEventListener('focus', handleInputFocus, { passive: true });
                    input.addEventListener('blur', handleInputBlur, { passive: true });
                    
                    // 确保输入框字体大小至少16px（防止iOS缩放）
                    const computedStyle = window.getComputedStyle(input);
                    const fontSize = parseInt(computedStyle.fontSize);
                    if (fontSize < 16) {
                        input.style.fontSize = '16px';
                        console.log('📱 调整输入框字体大小为16px，防止iOS缩放');
                    }
                });
            }
            
            // 监听DOM变化，处理动态添加的输入框
            const observer = new MutationObserver(function(mutations) {
                let shouldRebind = false;
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1) { // Element node
                                if (node.matches && (node.matches('textarea') || node.matches('input'))) {
                                    shouldRebind = true;
                                } else if (node.querySelector) {
                                    const inputs = node.querySelectorAll('textarea, input');
                                    if (inputs.length > 0) {
                                        shouldRebind = true;
                                    }
                                }
                            }
                        });
                    }
                });
                
                if (shouldRebind) {
                    console.log('📱 检测到新的输入框，重新绑定事件...');
                    setTimeout(bindInputEvents, 100);
                }
            });
            
            // 开始监听DOM变化
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            // 页面加载完成后绑定事件
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', bindInputEvents);
            } else {
                bindInputEvents();
            }
            
            // 页面显示时重新绑定（处理从后台返回的情况）
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden) {
                    setTimeout(bindInputEvents, 100);
                }
            });
            
            console.log('📱 [移动端优化] 输入框viewport行为修复已启动');
        })();
    </script>

    <!-- 💰【转账功能优化】让AI根据人设自然回应 -->
    <script>
        // 转账功能优化 - 移除自动收款，让AI根据人设自然回应
        (function() {
            'use strict';
            
            console.log('💰 [转账优化] 移除自动收款逻辑，让AI根据人设自然回应...');
            
            // 🔥【重要修改】移除自动收款逻辑，让AI根据角色人设自然决定
            // 转账状态变化应该由AI的自然回复触发，而不是自动处理
            // AI会根据自己的人设（比如高冷、温柔、傲娇等）来决定是否收款
            
            console.log('💰 [转账优化] AI将根据角色人设自然回应转账，不再自动收款');
        })();
    </script>

    <!-- 🚫【拉黑系统】模态框 -->
    <div id="blacklist-settings-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">拉黑管理</h3>
                <button class="modal-close" onclick="hideBlacklistSettings()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <div class="section-header">
                        <i class="fas fa-user-slash section-icon"></i>
                        <span class="section-title">当前状态</span>
                    </div>
                    <div class="setting-card">
                        <div class="setting-item" id="current-blacklist-status">
                            <div class="setting-left">
                                <div class="setting-label">拉黑状态</div>
                                <div class="setting-desc" id="blacklist-status-desc">正常聊天中</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="section-header">
                        <i class="fas fa-cog section-icon"></i>
                        <span class="section-title">拉黑设置</span>
                    </div>
                    <div class="setting-card">
                        <div class="setting-item">
                            <div class="setting-left">
                                <div class="setting-label">冷静时间（分钟）</div>
                                <div class="setting-desc">拉黑后需要等待的时间才能申请好友</div>
                            </div>
                            <div class="setting-right">
                                <input type="number" id="cooldown-minutes" min="5" max="1440" value="30" style="width: 80px; padding: 5px; border: 1px solid #ddd; border-radius: 4px;">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="settings-section">
                    <div class="section-header">
                        <i class="fas fa-exclamation-triangle section-icon danger-section-icon"></i>
                        <span class="section-title danger-section-title">操作</span>
                    </div>
                    <div class="setting-card">
                        <div class="setting-item danger-item" id="block-action-item" onclick="performBlockAction()">
                            <div class="setting-left">
                                <div class="setting-label danger-color" id="block-action-label">拉黑此角色</div>
                                <div class="setting-desc" id="block-action-desc">阻止该角色向你发送消息</div>
                            </div>
                            <div class="setting-right">
                                <i class="fas fa-chevron-right danger-color"></i>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideBlacklistSettings()">关闭</button>
            </div>
        </div>
    </div>

    <!-- 🚫【好友申请】模态框 -->
    <div id="friend-request-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">好友申请</h3>
                <button class="modal-close" onclick="hideFriendRequestModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">申请理由（可选）</label>
                    <textarea id="friend-request-message" class="form-textarea" placeholder="请输入申请理由..." maxlength="200"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-secondary" onclick="hideFriendRequestModal()">取消</button>
                <button class="modal-primary" onclick="sendFriendRequestConfirm()">发送申请</button>
            </div>
        </div>
    </div>

    <!-- 🚫【拉黑系统】JavaScript核心功能 -->
    <script>
        // 拉黑系统全局变量 - 检查是否已存在，避免重复声明
        if (typeof blacklistData === 'undefined') {
            var blacklistData = []; 
            var friendRequestsData = []; 
            var characterStatusData = [];
            var defaultCooldownMinutes = 30;
        }

        // 加载拉黑系统数据
        async function loadBlacklistData() {
            try {
                blacklistData = await db.blacklist.orderBy('timestamp').reverse().toArray();
                console.log('拉黑数据加载完成:', blacklistData);
            } catch (error) {
                console.error('加载拉黑数据失败:', error);
                blacklistData = [];
            }
        }

        // 检查是否被拉黑
        function isBlocked(blockerId, blockedId) {
            return blacklistData.some(record => 
                record.blockerId === blockerId && 
                record.blockedId === blockedId && 
                !record.unblocked
            );
        }

        // 检查是否在冷静期
        function isInCooldown(blockerId, blockedId) {
            const record = blacklistData.find(r => 
                r.blockerId === blockerId && 
                r.blockedId === blockedId && 
                r.unblocked
            );
            
            if (!record || !record.unblockTimestamp) return false;
            
            const cooldownEnd = new Date(new Date(record.unblockTimestamp).getTime() + (record.cooldownMinutes * 60 * 1000));
            return new Date() < cooldownEnd;
        }

        // 拉黑角色
        async function blockCharacter(characterId, reason = '', cooldownMinutes = null) {
            try {
                const now = new Date();
                const cooldown = cooldownMinutes || defaultCooldownMinutes;
                
                if (isBlocked('user', characterId)) {
                    showToast('该角色已被拉黑', 'warning');
                    return;
                }
                
                const blockRecord = {
                    id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    blockerId: 'user',
                    blockedId: characterId,
                    timestamp: now.toISOString(),
                    reason: reason,
                    cooldownMinutes: cooldown,
                    unblocked: false
                };
                
                blacklistData.unshift(blockRecord);
                await db.blacklist.add(blockRecord);
                
                const character = characters.find(c => c.id === characterId);
                showToast(`已拉黑 ${character?.name || '角色'}`, 'success');
                
                // 🔥【新增】通知角色被拉黑了
                await notifyCharacterBlocked(characterId, reason);
                
                // 立即更新聊天界面显示
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    updateChatBlockedStatus();
                }
                
                renderContactList();
                renderMessageList();
                
            } catch (error) {
                console.error('拉黑角色失败:', error);
                showToast('拉黑失败', 'error');
            }
        }

        // 解除拉黑
        async function unblockCharacter(characterId) {
            try {
                const blockRecord = blacklistData.find(r => 
                    r.blockerId === 'user' && 
                    r.blockedId === characterId && 
                    !r.unblocked
                );
                
                if (!blockRecord) {
                    showToast('该角色未被拉黑', 'warning');
                    return;
                }
                
                blockRecord.unblocked = true;
                blockRecord.unblockTimestamp = new Date().toISOString();
                
                await db.blacklist.put(blockRecord);
                
                const character = characters.find(c => c.id === characterId);
                showToast(`已解除对 ${character?.name || '角色'} 的拉黑`, 'success');
                
                // 🔥【新增】通知角色被解除拉黑了
                await notifyCharacterUnblocked(characterId);
                
                // 刷新聊天界面显示
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    renderChatMessages(currentChatCharacter.id);
                    updateChatBlockedStatus();
                }
                
                renderContactList();
                renderMessageList();
                
            } catch (error) {
                console.error('解除拉黑失败:', error);
                showToast('解除拉黑失败', 'error');
            }
        }

        // 更新角色状态
        async function updateCharacterStatus(characterId, status, activity = '', location = '') {
            try {
                let statusRecord = characterStatusData.find(s => s.characterId === characterId);
                
                if (!statusRecord) {
                    statusRecord = {
                        id: `status_${characterId}`,
                        characterId: characterId,
                        status: status,
                        activity: activity,
                        location: location,
                        lastUpdate: new Date().toISOString()
                    };
                    characterStatusData.push(statusRecord);
                } else {
                    statusRecord.status = status;
                    statusRecord.activity = activity;
                    statusRecord.location = location;
                    statusRecord.lastUpdate = new Date().toISOString();
                }
                
                await db.characterStatus.put(statusRecord);
                
            } catch (error) {
                console.error('更新角色状态失败:', error);
            }
        }

        // 获取角色状态
        function getCharacterStatus(characterId) {
            return characterStatusData.find(s => s.characterId === characterId) || {
                status: 'online',
                activity: '在线',
                location: '',
                lastUpdate: new Date().toISOString()
            };
        }

        // 角色拉黑用户
        async function aiBlockUser(characterId, reason = '') {
            try {
                const now = new Date();
                
                // 检查是否已经拉黑
                if (isBlocked(characterId, 'user')) {
                    return;
                }
                
                const blockRecord = {
                    id: `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    blockerId: characterId,
                    blockedId: 'user',
                    timestamp: now.toISOString(),
                    reason: reason,
                    cooldownMinutes: 0, // 角色拉黑用户不需要冷静时间
                    unblocked: false
                };
                
                blacklistData.unshift(blockRecord);
                await db.blacklist.add(blockRecord);
                
                // 更新聊天界面显示
                if (currentChatCharacter && currentChatCharacter.id === characterId) {
                    updateChatBlockedStatus();
                }
                
                const character = characters.find(c => c.id === characterId);
                showToast(`${character?.name || '角色'} 已将你拉黑`, 'warning');
                
            } catch (error) {
                console.error('角色拉黑用户失败:', error);
            }
        }

        // 发送好友申请
        async function sendFriendRequest(characterId, message = '') {
            try {
                const request = {
                    id: `request_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    fromId: 'user',
                    toId: characterId,
                    timestamp: new Date().toISOString(),
                    status: 'pending',
                    type: 'friend',
                    message: message
                };
                
                friendRequestsData.unshift(request);
                await db.friendRequests.add(request);
                
                showToast('好友申请已发送', 'success');
                
            } catch (error) {
                console.error('发送好友申请失败:', error);
                showToast('发送申请失败', 'error');
            }
        }

        // 更新聊天界面的拉黑状态显示
        function updateChatBlockedStatus() {
            if (!currentChatCharacter) return;
            
            const characterId = currentChatCharacter.id;
            const isUserBlocked = isBlocked('user', characterId);
            const isCharacterBlocked = isBlocked(characterId, 'user');
            
            // 移除现有的拉黑提示
            const existingBlockedUI = document.querySelector('.blocked-status-overlay');
            if (existingBlockedUI) {
                existingBlockedUI.remove();
            }
            
            if (isUserBlocked || isCharacterBlocked) {
                // 创建拉黑状态覆盖层
                const chatScreen = document.getElementById('api-chat-screen');
                const blockedOverlay = document.createElement('div');
                blockedOverlay.className = 'blocked-status-overlay';
                
                let statusText, buttonText, buttonAction, buttonClass;
                
                if (isUserBlocked) {
                    statusText = `你已将 ${currentChatCharacter.name} 拉黑`;
                    buttonText = '解除拉黑';
                    buttonAction = () => unblockCharacter(characterId);
                    buttonClass = 'blocked-status-button unblock-style';
                } else {
                    statusText = `你被 ${currentChatCharacter.name} 拉黑了`;
                    buttonText = '重新申请添加好友';
                    buttonAction = () => showFriendRequestModal();
                    buttonClass = 'blocked-status-button';
                }
                
                blockedOverlay.innerHTML = `
                    <div class="blocked-status-content">
                        <div class="blocked-status-text">${statusText}</div>
                        <button class="${buttonClass}" onclick="this.clickHandler()">${buttonText}</button>
                    </div>
                `;
                
                // 绑定按钮事件
                const button = blockedOverlay.querySelector('.blocked-status-button');
                button.clickHandler = buttonAction;
                
                chatScreen.appendChild(blockedOverlay);
            }
        }

        // 显示拉黑设置
        function showBlacklistSettings() {
            if (!currentChatCharacter) {
                showToast('请先选择一个角色', 'warning');
                return;
            }
            
            const characterId = currentChatCharacter.id;
            const isUserBlocked = isBlocked('user', characterId);
            
            const statusDesc = document.getElementById('blacklist-status-desc');
            const actionLabel = document.getElementById('block-action-label');
            const actionDesc = document.getElementById('block-action-desc');
            
            if (isUserBlocked) {
                statusDesc.textContent = '你已拉黑此角色';
                actionLabel.textContent = '解除拉黑';
                actionDesc.textContent = '恢复与该角色的正常聊天';
            } else {
                statusDesc.textContent = '正常聊天中';
                actionLabel.textContent = '拉黑此角色';
                actionDesc.textContent = '阻止该角色向你发送消息';
            }
            
            document.getElementById('cooldown-minutes').value = defaultCooldownMinutes;
            document.getElementById('blacklist-settings-modal').style.display = 'flex';
        }

        // 隐藏拉黑设置
        function hideBlacklistSettings() {
            document.getElementById('blacklist-settings-modal').style.display = 'none';
        }

        // 显示好友申请模态框
        function showFriendRequestModal() {
            if (!currentChatCharacter) return;
            
            // 检查是否在冷静期
            if (isInCooldown(currentChatCharacter.id, 'user')) {
                showToast('还在冷静期内，请稍后再试', 'warning');
                return;
            }
            
            document.getElementById('friend-request-message').value = '';
            document.getElementById('friend-request-modal').style.display = 'flex';
        }

        // 隐藏好友申请模态框
        function hideFriendRequestModal() {
            document.getElementById('friend-request-modal').style.display = 'none';
        }

        // 发送好友申请确认
        async function sendFriendRequestConfirm() {
    if (!currentChatCharacter) return;
    
    const message = document.getElementById('friend-request-message').value.trim();
    const characterId = currentChatCharacter.id;

    // 1. 先在数据库中记录这个申请事件
    await sendFriendRequest(characterId, message);
    hideFriendRequestModal();
    
    // 2. 🔥【核心新增】立刻调用API，让AI处理这个好友申请
    showToast('申请已发送，等待对方回应...', 'info');
    await processAIFriendRequestResponse(characterId, message); 
}

        // 执行拉黑操作
        function performBlockAction() {
            if (!currentChatCharacter) return;
            
            const characterId = currentChatCharacter.id;
            const isUserBlocked = isBlocked('user', characterId);
            const cooldownMinutes = parseInt(document.getElementById('cooldown-minutes').value) || 30;
            
            if (isUserBlocked) {
                if (confirm(`确定要解除对 ${currentChatCharacter.name} 的拉黑吗？`)) {
                    unblockCharacter(characterId);
                    hideBlacklistSettings();
                }
            } else {
                if (confirm(`确定要拉黑 ${currentChatCharacter.name} 吗？\n\n冷静时间：${cooldownMinutes}分钟`)) {
                    blockCharacter(characterId, '', cooldownMinutes);
                    hideBlacklistSettings();
                }
            }
        }

        // 在应用初始化时加载拉黑系统数据
        document.addEventListener('DOMContentLoaded', async function() {
            setTimeout(async () => {
                try {
                    await Promise.all([
                        loadBlacklistData(),
                        loadFriendRequestsData(),
                        loadCharacterStatusData()
                    ]);
                    console.log('🚫 拉黑系统数据加载完成');
                } catch (error) {
                    console.error('拉黑系统数据加载失败:', error);
                }
            }, 1000);
        });

        // 加载好友申请数据
        async function loadFriendRequestsData() {
            try {
                friendRequestsData = await db.friendRequests.orderBy('timestamp').reverse().toArray();
                console.log('好友申请数据加载完成:', friendRequestsData);
            } catch (error) {
                console.error('加载好友申请数据失败:', error);
                friendRequestsData = [];
            }
        }

        // 加载角色状态数据
        async function loadCharacterStatusData() {
            try {
                characterStatusData = await db.characterStatus.toArray();
                console.log('角色状态数据加载完成:', characterStatusData);
            } catch (error) {
                console.error('加载角色状态数据失败:', error);
                characterStatusData = [];
            }
        }

        // 📱【角色状态显示】相关功能
        // 渲染角色状态
        function renderCharacterStatus(characterId, container) {
            const chatSettings = getCurrentChatSettings();
            if (!chatSettings.characterStatusEnabled) {
                // 如果关闭了状态显示，移除现有的状态元素
                if (container) {
                    const existingStatus = container.querySelector('.character-status');
                    if (existingStatus) {
                        existingStatus.remove();
                    }
                }
                return; 
            }
            
            const status = getCharacterStatus(characterId);
            const isUserBlocked = isBlocked('user', characterId);
            const isCharacterBlocked = isBlocked(characterId, 'user');
            
            let statusClass = 'online';
            let statusText = status.activity || '在线';
            
            if (isUserBlocked || isCharacterBlocked) {
                statusClass = 'blocked';
                statusText = '已拉黑';
            } else if (status.status === 'busy') {
                statusClass = 'busy';
            }
            
            const statusHtml = `
                <div class="character-status">
                    <div class="status-indicator ${statusClass}"></div>
                    <span class="status-text">${statusText}</span>
                </div>
            `;
            
            // 如果容器存在，添加状态显示
            if (container) {
                // 先移除现有的状态显示
                const existingStatus = container.querySelector('.character-status');
                if (existingStatus) {
                    existingStatus.remove();
                }
                
                // 🔥【修复】判断容器类型，使用不同的插入策略
                if (container.classList.contains('header')) {
                    // 聊天界面的.header容器：直接添加到容器中，使用CSS绝对定位
                    container.insertAdjacentHTML('beforeend', statusHtml);
                } else if (container.classList.contains('app-header')) {
                    // 其他界面的.app-header容器：添加到.app-title内部
                    const titleElement = container.querySelector('.app-title');
                    if (titleElement) {
                        titleElement.insertAdjacentHTML('afterend', statusHtml);
                    } else {
                        container.insertAdjacentHTML('beforeend', statusHtml);
                    }
                } else {
                    // 其他容器：默认添加到末尾
                    container.insertAdjacentHTML('beforeend', statusHtml);
                }
            }
        }

        // AI生成角色状态
        async function generateCharacterStatus(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;
                
                // 获取聊天设置和最近聊天记录
                const chatSettings = await getAsyncChatSettings(characterId);
                const messages = chatMessages[characterId] || [];
                const recentMessages = messages.slice(-5); // 最近5条消息
                
                // 构建上下文信息
                let chatContext = '';
                if (recentMessages.length > 0) {
                    chatContext = '最近的聊天记录：\n' + 
                        recentMessages.map(msg => {
                            if (msg.sender === 'user') return `用户：${msg.content}`;
                            if (msg.sender === 'ai') return `${character.name}：${msg.content}`;
                            return '';
                        }).filter(Boolean).join('\n') + '\n\n';
                }
                
                // 获取世界书内容作为背景
                let worldBookContext = '';
                if (chatSettings?.linkedWorldBookIds && chatSettings.linkedWorldBookIds.length > 0) {
                    try {
                        const worldBooks = await Promise.all(
                            chatSettings.linkedWorldBookIds.map(id => db.worldbooks.get(id))
                        );
                        const validWorldBooks = worldBooks.filter(book => book && book.content);
                        if (validWorldBooks.length > 0) {
                            worldBookContext = '背景设定：\n' + 
                                validWorldBooks.map(book => `${book.name}：${book.content}`).join('\n\n') + '\n\n';
                        }
                    } catch (error) {
                        console.error('获取世界书内容失败:', error);
                    }
                }
                
                // 随机选择状态类型：活动或心情
                const statusType = Math.random() < 0.5 ? 'activity' : 'mood';
                
                let prompt;
                if (statusType === 'activity') {
                    // 生成活动状态
                    prompt = `你是${character.name}，人设如下：${character.bio}

${worldBookContext}${chatContext}请根据你的人设、当前剧情和聊天记录，生成一个符合你当前状况的活动状态。要求：
1. 10-20字内，简洁明了
2. 符合你的性格和身份设定
3. 基于最近的聊天内容或剧情发展
4. 格式：在[地点][做什么]
5. 要真实反映角色当下可能在做的事情
6. 如果没有具体聊天记录，则根据人设推测合理的日常活动

示例格式：在图书馆整理资料、在训练场练习剑术、在房间里沉思、在花园中散步等

请生成一个活动状态：`;
                } else {
                    // 生成心情状态
                    prompt = `你是${character.name}，人设如下：${character.bio}

${worldBookContext}${chatContext}请根据你的人设、当前剧情和聊天记录，生成一个符合你当前心情的状态。要求：
1. 10-20字内，简洁明了
2. 符合你的性格特点
3. 基于最近的对话内容或情感变化
4. 表达你当下的真实情感状态
5. 要有角色的个性色彩
6. 如果没有具体聊天记录，则根据人设推测基本心情

示例格式：心情愉悦、略感困惑、正在专注思考、感到有些疲惫、对未来充满期待等

请生成一个心情状态：`;
                }
                
                // 使用AI生成状态
                const statusText = await generateAIResponse(prompt, character);
                
                if (statusText && statusText.trim()) {
                    const cleanStatus = statusText.trim().replace(/^["""''「」『』【】]|["""''「」『』【】]$/g, '');
                    await updateCharacterStatus(characterId, 'online', cleanStatus);
                    console.log(`为${character.name}生成${statusType === 'activity' ? '活动' : '心情'}状态: ${cleanStatus}`);
                } else {
                    // 如果AI生成失败，使用基于人设的默认状态
                    const fallbackStatus = generateFallbackStatus(character, statusType);
                    await updateCharacterStatus(characterId, 'online', fallbackStatus);
                    console.log(`为${character.name}使用默认${statusType === 'activity' ? '活动' : '心情'}状态: ${fallbackStatus}`);
                }
                
            } catch (error) {
                console.error('生成角色状态失败:', error);
                // 错误时使用简单的默认状态
                const fallbackStatus = generateFallbackStatus(character, 'activity');
                await updateCharacterStatus(characterId, 'online', fallbackStatus);
            }
        }
        
        // 生成基于人设的备用状态
        function generateFallbackStatus(character, statusType) {
            const bio = (character.bio || '').toLowerCase();
            
            if (statusType === 'activity') {
                // 基于人设关键词的活动状态
                if (bio.includes('学者') || bio.includes('研究') || bio.includes('书')) {
                    return '在书房研读典籍';
                } else if (bio.includes('战士') || bio.includes('剑') || bio.includes('战斗')) {
                    return '在训练场练习';
                } else if (bio.includes('医生') || bio.includes('治疗')) {
                    return '在诊所整理药品';
                } else if (bio.includes('商人') || bio.includes('买卖')) {
                    return '在店铺忙碌';
                } else if (bio.includes('艺术') || bio.includes('画') || bio.includes('音乐')) {
                    return '在工作室创作';
                } else if (bio.includes('厨') || bio.includes('料理')) {
                    return '在厨房准备食材';
                } else {
                    return '在房间里休息';
                }
            } else {
                // 基于人设关键词的心情状态
                if (bio.includes('开朗') || bio.includes('活泼') || bio.includes('乐观')) {
                    return '心情愉悦';
                } else if (bio.includes('冷静') || bio.includes('理性') || bio.includes('沉着')) {
                    return '内心平静';
                } else if (bio.includes('严肃') || bio.includes('认真')) {
                    return '专注思考中';
                } else if (bio.includes('温柔') || bio.includes('善良')) {
                    return '心境温和';
                } else if (bio.includes('神秘') || bio.includes('深沉')) {
                    return '若有所思';
                } else {
                    return '状态良好';
                }
            }
        }

        // 🔥【修复】状态更新定时器管理
        let characterStatusTimer = null;
        
        // 获取状态更新间隔时间（毫秒）
        function getStatusUpdateInterval() {
            // 优先使用当前聊天角色的设置，如果没有则使用默认设置
            let frequency = 'medium'; // 默认中频
            
            if (currentChatCharacter) {
                const chatSettings = getCurrentChatSettings();
                frequency = chatSettings.statusUpdateFrequency || 'medium';
            }
            
            // 将频率转换为毫秒间隔
            const intervals = {
                'high': 60000,      // 1分钟
                'medium-high': 120000, // 2分钟
                'medium': 180000,   // 3分钟
                'medium-low': 300000, // 5分钟
                'low': 600000       // 10分钟
            };
            
            return intervals[frequency] || intervals['medium'];
        }
        
        // 清除状态更新定时器
        function clearCharacterStatusTimer() {
            if (characterStatusTimer) {
                clearInterval(characterStatusTimer);
                characterStatusTimer = null;
                console.log('角色状态更新定时器已清除');
            }
        }
        
        // 启动状态更新定时器
        function startCharacterStatusTimer() {
            clearCharacterStatusTimer(); // 先清除现有定时器
            
            const interval = getStatusUpdateInterval();
            console.log('启动角色状态更新定时器，间隔:', interval / 1000, '秒');
            
            characterStatusTimer = setInterval(async () => {
                // 🔥【修复】首先检查是否有任何角色启用了状态显示
                let hasStatusEnabled = false;
                
                for (const character of characters) {
                    if (contacts.includes(character.id)) {
                        // 检查该角色的聊天设置中是否启用了状态显示
                        const chatSettings = await getAsyncChatSettings(character.id);
                        if (chatSettings.characterStatusEnabled) {
                            hasStatusEnabled = true;
                            
                            // 检查是否需要更新状态
                            const shouldUpdate = await shouldUpdateCharacterStatus(character.id);
                            if (shouldUpdate) {
                                await generateCharacterStatus(character.id);
                            }
                        }
                    }
                }
                
                // 如果没有任何角色启用状态显示，跳过后续操作
                if (!hasStatusEnabled) {
                    return;
                }
                
                // 刷新当前显示的状态（仅当当前角色启用了状态显示时）
                if (currentChatCharacter) {
                    const currentChatSettings = getCurrentChatSettings();
                    if (currentChatSettings.characterStatusEnabled) {
                        const headerContainer = document.querySelector('#api-chat-screen .header');
                        if (headerContainer) {
                            renderCharacterStatus(currentChatCharacter.id, headerContainer);
                        }
                    }
                }
            }, interval);
        }
        
        // 重启状态更新定时器
        function restartCharacterStatusTimer() {
            console.log('重启角色状态更新定时器');
            startCharacterStatusTimer();
        }
        
        // 向后兼容的函数名
        function startStatusUpdateTimer() {
            startCharacterStatusTimer();
        }
        
        // 判断是否应该更新角色状态
        async function shouldUpdateCharacterStatus(characterId) {
            try {
                const currentStatus = getCharacterStatus(characterId);
                const lastUpdate = new Date(currentStatus.lastUpdate);
                const now = new Date();
                const timeDiff = now - lastUpdate;
                
                // 如果状态超过15分钟没更新，有较高概率更新
                if (timeDiff > 15 * 60 * 1000) {
                    return Math.random() < 0.3; // 30%概率
                }
                
                // 如果最近有聊天活动，提高更新概率
                const messages = chatMessages[characterId] || [];
                if (messages.length > 0) {
                    const lastMessage = messages[messages.length - 1];
                    const lastMessageTime = new Date(lastMessage.timestamp);
                    const messageTimeDiff = now - lastMessageTime;
                    
                    // 如果最近5分钟内有聊天，有更高概率更新状态
                    if (messageTimeDiff < 5 * 60 * 1000) {
                        return Math.random() < 0.4; // 40%概率
                    }
                    
                    // 如果最近30分钟内有聊天，有一定概率更新状态
                    if (messageTimeDiff < 30 * 60 * 1000) {
                        return Math.random() < 0.2; // 20%概率
                    }
                }
                
                // 默认概率
                return Math.random() < 0.1; // 10%概率
                
            } catch (error) {
                console.error('判断角色状态更新失败:', error);
                return Math.random() < 0.05; // 5%概率
            }
        }
        
        // 在发送/接收消息后触发状态更新
        async function triggerStatusUpdateAfterMessage(characterId) {
            // 🔥【修复】首先检查是否开启了角色状态显示
            const chatSettings = await getAsyncChatSettings(characterId);
            if (!chatSettings.characterStatusEnabled) {
                console.log(`角色 ${characterId} 未启用状态显示，跳过状态更新`);
                return;
            }
            
            // 延迟更新，模拟角色响应聊天内容后的状态变化
            setTimeout(async () => {
                // 再次检查状态显示设置（防止在延迟期间被关闭）
                const currentSettings = await getAsyncChatSettings(characterId);
                if (!currentSettings.characterStatusEnabled) {
                    console.log(`角色 ${characterId} 状态显示已关闭，取消状态更新`);
                    return;
                }
                
                if (Math.random() < 0.6) { // 60%概率在聊天后更新状态
                    await generateCharacterStatus(characterId);
                    
                    // 如果是当前聊天角色，刷新显示
                    if (currentChatCharacter && currentChatCharacter.id === characterId) {
                        const headerContainer = document.querySelector('#api-chat-screen .header');
                        if (headerContainer) {
                            renderCharacterStatus(characterId, headerContainer);
                        }
                    }
                }
            }, Math.random() * 10000 + 5000); // 5-15秒后随机更新
        }

        // 在应用初始化时启动状态更新定时器
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                startStatusUpdateTimer();
            }, 5000); // 延迟5秒启动
        });

        console.log('🚫 拉黑系统核心功能已加载');

        // AI心率管理功能
        let heartrateInterval = null;
        let currentHeartrate = 72; // 基础心率

        function updateAiHeartrate() {
            const heartrateDisplay = document.getElementById('ai-heartrate-display');
            if (!heartrateDisplay) return;
            
            const chatSettings = getCurrentChatSettings();
            
            // 检查是否启用心率监测且不是群聊
            if (!chatSettings.aiHeartrateEnabled || (currentChatCharacter && currentChatCharacter.isGroup)) {
                hideAiHeartrate();
                return;
            }
            
            // 显示心率
            heartrateDisplay.style.display = 'block';
            
            // 计算基础心率（基于角色人设）
            const persona = (currentChatCharacter.bio || '').toLowerCase();
            const name = (currentChatCharacter.name || '').toLowerCase();
            let baseHeartrate = 72;
            
            // 根据角色特征调整基础心率
            if (persona.includes('紧张') || persona.includes('害羞') || persona.includes('敏感') || 
                persona.includes('羞涩') || persona.includes('容易脸红') || persona.includes('内向')) {
                baseHeartrate = 85; // 容易紧张的角色心率更高
            } else if (persona.includes('冷静') || persona.includes('理性') || persona.includes('成熟') || 
                       persona.includes('沉稳') || persona.includes('内敛') || persona.includes('严肃')) {
                baseHeartrate = 65; // 冷静的角色心率更低
            } else if (persona.includes('活泼') || persona.includes('兴奋') || persona.includes('热情') || 
                       persona.includes('开朗') || persona.includes('外向') || persona.includes('爱笑')) {
                baseHeartrate = 82; // 活泼的角色心率偏高
            } else if (persona.includes('运动') || persona.includes('健身') || persona.includes('体育') || 
                       persona.includes('运动员') || persona.includes('活跃')) {
                baseHeartrate = 58; // 运动型角色心率最低
            } else if (persona.includes('温柔') || persona.includes('甜美') || persona.includes('可爱') || 
                       persona.includes('软萌') || persona.includes('小鸟依人') || persona.includes('乖巧')) {
                baseHeartrate = 75; // 温柔型角色心率适中偏高
            } else if (persona.includes('冷酷') || persona.includes('高冷') || persona.includes('傲娇') || 
                       persona.includes('女王') || persona.includes('强势') || persona.includes('霸道')) {
                baseHeartrate = 68; // 高冷型角色心率偏低
            } else if (persona.includes('热血') || persona.includes('冲动') || persona.includes('急性子') || 
                       persona.includes('火爆') || persona.includes('暴躁') || persona.includes('易怒')) {
                baseHeartrate = 88; // 热血型角色心率很高
            } else if (persona.includes('神秘') || persona.includes('深沉') || persona.includes('安静') || 
                       persona.includes('文静') || persona.includes('内向')) {
                baseHeartrate = 70; // 神秘型角色心率正常偏低
            }
            
            // 根据角色名字进一步微调
            if (name.includes('小') || name.includes('萌') || name.includes('可爱')) {
                baseHeartrate += 3; // 可爱名字的角色心率稍高
            } else if (name.includes('冰') || name.includes('雪') || name.includes('静') || 
                       name.includes('冷') || name.includes('凉')) {
                baseHeartrate -= 5; // 冷系名字的角色心率更低
            } else if (name.includes('火') || name.includes('热') || name.includes('烈')) {
                baseHeartrate += 5; // 火系名字的角色心率更高
            }
            
            // 根据最近对话内容调整心率
            const recentMessages = (chatMessages[currentChatCharacter.id] || []).slice(-8); // 分析最近8条消息
            let emotionAdjustment = 0;
            
            recentMessages.forEach(msg => {
                // 安全地处理消息内容
                let content = '';
                if (typeof msg.content === 'string') {
                    content = msg.content.toLowerCase();
                } else if (Array.isArray(msg.content)) {
                    content = '';
                } else {
                    content = '';
                }
                
                // 高度亲密词汇 - 大幅提高心率
                if (content.includes('爱你') || content.includes('我爱你') || content.includes('love you') || 
                    content.includes('喜欢你') || content.includes('想你') || content.includes('想抱你') ||
                    content.includes('想吻你') || content.includes('亲亲') || content.includes('抱抱') ||
                    content.includes('宝贝') || content.includes('darling') || content.includes('honey') ||
                    content.includes('亲爱的') || content.includes('想要你') || content.includes('需要你') ||
                    content.includes('离不开你') || content.includes('想和你') || content.includes('想见你')) {
                    emotionAdjustment += 15;
                }
                
                // 表白和甜蜜词汇
                if (content.includes('表白') || content.includes('喜欢') || content.includes('心动') || 
                    content.includes('心跳') || content.includes('脸红') || content.includes('害羞') ||
                    content.includes('可爱') || content.includes('甜') || content.includes('温柔') ||
                    content.includes('美丽') || content.includes('漂亮') || content.includes('迷人') ||
                    content.includes('魅力') || content.includes('吸引') || content.includes('心仪')) {
                    emotionAdjustment += 10;
                }
                
                // 撒娇和亲昵词汇
                if (content.includes('撒娇') || content.includes('嘤嘤') || content.includes('哼') ||
                    content.includes('人家') || content.includes('讨厌') || content.includes('不要') ||
                    content.includes('好不好') || content.includes('求你') || content.includes('拜托') ||
                    content.includes('陪我') || content.includes('陪陪') || content.includes('一起')) {
                    emotionAdjustment += 8;
                }
                
                // 兴奋和开心词汇
                if (content.includes('开心') || content.includes('高兴') || content.includes('快乐') || 
                    content.includes('兴奋') || content.includes('激动') || content.includes('好棒') || 
                    content.includes('厉害') || content.includes('哇') || content.includes('太好了') ||
                    content.includes('amazing') || content.includes('wonderful') || content.includes('great')) {
                    emotionAdjustment += 6;
                }
                
                // 负面情绪词汇 - 同样会让心率加快
                if (content.includes('难过') || content.includes('生气') || content.includes('担心') || 
                    content.includes('害怕') || content.includes('紧张') || content.includes('焦虑') ||
                    content.includes('不开心') || content.includes('郁闷') || content.includes('烦') ||
                    content.includes('压力') || content.includes('累') || content.includes('疲惫')) {
                    emotionAdjustment += 8;
                }
            });
            
            // 计算最终心率
            currentHeartrate = Math.max(50, Math.min(140, baseHeartrate + emotionAdjustment));
            
            // 启动心率更新
            if (heartrateInterval) clearInterval(heartrateInterval);
            heartrateInterval = setInterval(() => {
                // 添加自然的心率波动（±4 bpm）
                const fluctuation = Math.floor(Math.random() * 9) - 4;
                const displayHeartrate = Math.max(50, Math.min(140, currentHeartrate + fluctuation));
                
                // 根据心率高低添加视觉效果
                heartrateDisplay.className = '';
                if (displayHeartrate >= 110) {
                    heartrateDisplay.classList.add('very-high-heartrate');
                } else if (displayHeartrate >= 95) {
                    heartrateDisplay.classList.add('high-heartrate');
                }
                
                heartrateDisplay.innerHTML = `♥️ <span class="heartrate-number">${displayHeartrate}</span> <span class="heartrate-unit">bpm</span>`;
            }, 1500 + Math.random() * 1000); // 1.5-2.5秒更新一次
            
            // 立即显示初始心率
            heartrateDisplay.innerHTML = `♥️ <span class="heartrate-number">${currentHeartrate}</span> <span class="heartrate-unit">bpm</span>`;
        }

        function hideAiHeartrate() {
            const heartrateDisplay = document.getElementById('ai-heartrate-display');
            if (heartrateDisplay) {
                heartrateDisplay.style.display = 'none';
            }
            
            if (heartrateInterval) {
                clearInterval(heartrateInterval);
                heartrateInterval = null;
            }
        }

        // 当发送消息时更新心率
        function adjustHeartrateForMessage(content, isUserMessage = false) {
            if (!heartrateInterval) return; // 心率监测未启用
            
            let adjustment = 0;
            let lowerContent = '';
            let recoveryTime = 3000; // 默认恢复时间
            
            // 安全地处理内容
            if (typeof content === 'string') {
                lowerContent = content.toLowerCase();
            } else if (Array.isArray(content)) {
                lowerContent = '';
            } else {
                lowerContent = '';
            }
            
            if (isUserMessage) {
                // 用户发送消息时，AI的心率会有相应反应
                
                // 高度亲密词汇 - 强烈心跳加速
                if (lowerContent.includes('爱你') || lowerContent.includes('我爱你') || lowerContent.includes('love you') || 
                    lowerContent.includes('喜欢你') || lowerContent.includes('想你') || lowerContent.includes('想抱你') ||
                    lowerContent.includes('想吻你') || lowerContent.includes('亲亲') || lowerContent.includes('抱抱') ||
                    lowerContent.includes('宝贝') || lowerContent.includes('darling') || lowerContent.includes('honey') ||
                    lowerContent.includes('亲爱的') || lowerContent.includes('想要你') || lowerContent.includes('需要你') ||
                    lowerContent.includes('离不开你') || lowerContent.includes('想和你') || lowerContent.includes('想见你')) {
                    adjustment = 20; // 大幅增加
                    recoveryTime = 8000; // 更长的恢复时间
                }
                // 表白和甜蜜词汇
                else if (lowerContent.includes('表白') || lowerContent.includes('喜欢') || lowerContent.includes('心动') || 
                    lowerContent.includes('心跳') || lowerContent.includes('脸红') || lowerContent.includes('害羞') ||
                    lowerContent.includes('可爱') || lowerContent.includes('甜') || lowerContent.includes('温柔') ||
                    lowerContent.includes('美丽') || lowerContent.includes('漂亮') || lowerContent.includes('迷人') ||
                    lowerContent.includes('魅力') || lowerContent.includes('吸引') || lowerContent.includes('心仪')) {
                    adjustment = 15;
                    recoveryTime = 6000;
                }
                // 撒娇和亲昵词汇
                else if (lowerContent.includes('撒娇') || lowerContent.includes('嘤嘤') || lowerContent.includes('哼') ||
                    lowerContent.includes('人家') || lowerContent.includes('讨厌') || lowerContent.includes('不要') ||
                    lowerContent.includes('好不好') || lowerContent.includes('求你') || lowerContent.includes('拜托') ||
                    lowerContent.includes('陪我') || lowerContent.includes('陪陪') || lowerContent.includes('一起')) {
                    adjustment = 12;
                    recoveryTime = 5000;
                }
                // 兴奋和开心词汇
                else if (lowerContent.includes('开心') || lowerContent.includes('高兴') || lowerContent.includes('快乐') || 
                    lowerContent.includes('兴奋') || lowerContent.includes('激动') || lowerContent.includes('好棒') || 
                    lowerContent.includes('厉害') || lowerContent.includes('哇') || lowerContent.includes('太好了')) {
                    adjustment = 8;
                    recoveryTime = 4000;
                }
                // 负面情绪词汇 - 紧张导致心率加快
                else if (lowerContent.includes('生气') || lowerContent.includes('不开心') || lowerContent.includes('难过') ||
                    lowerContent.includes('担心') || lowerContent.includes('害怕') || lowerContent.includes('紧张') ||
                    lowerContent.includes('焦虑') || lowerContent.includes('郁闷') || lowerContent.includes('烦')) {
                    adjustment = 10;
                    recoveryTime = 6000;
                }
                // 普通问候
                else if (lowerContent.includes('你好') || lowerContent.includes('hi') || lowerContent.includes('hello') ||
                    lowerContent.includes('早上好') || lowerContent.includes('晚安')) {
                    adjustment = 5;
                    recoveryTime = 3000;
                }
                
            } else {
                // AI自己发送消息后的心率变化
                if (lowerContent.includes('害羞') || lowerContent.includes('脸红') || lowerContent.includes('不好意思')) {
                    adjustment = 10;
                    recoveryTime = 5000;
                } else if (lowerContent.includes('兴奋') || lowerContent.includes('开心') || lowerContent.includes('激动')) {
                    adjustment = 8;
                    recoveryTime = 4000;
                } else if (lowerContent.includes('紧张') || lowerContent.includes('担心') || lowerContent.includes('焦虑')) {
                    adjustment = 12;
                    recoveryTime = 6000;
                } else if (lowerContent.includes('爱') || lowerContent.includes('喜欢') || lowerContent.includes('想')) {
                    adjustment = 15;
                    recoveryTime = 7000;
                }
            }
            
            // 应用调整
            currentHeartrate = Math.max(55, Math.min(130, currentHeartrate + adjustment));
            
            // 更自然的恢复机制
            setTimeout(() => {
                const recoveryRate = Math.floor(adjustment * 0.6); // 恢复60%
                currentHeartrate = Math.max(65, currentHeartrate - recoveryRate);
                
                // 继续缓慢恢复
                setTimeout(() => {
                    const finalRecovery = Math.floor(adjustment * 0.3); // 再恢复30%
                    currentHeartrate = Math.max(65, currentHeartrate - finalRecovery);
                }, recoveryTime * 0.5);
                
            }, recoveryTime);
        }

        /**
 * 🔥【新增】处理AI对好友申请的回应
 * @param {string} characterId - AI角色的ID
 * @param {string} requestMessage - 用户发送的申请理由
 */
async function processAIFriendRequestResponse(characterId, requestMessage) {
    const character = characters.find(c => c.id === characterId);
    if (!character) return;

    // 构建一个专门用于决策的Prompt
    const decisionPrompt = `
# 指令：好友申请决策
你之前拉黑了用户。现在用户向你发来好友申请。
- 你的身份: ${character.name}
- 你的设定: ${character.bio}
- 用户的申请理由: "${requestMessage || '对方没有填写理由。'}"

# 你的任务:
根据你的角色性格和用户给出的理由，决定是否同意加回好友。
你的回答必须非常简洁，只能是以下两个词之一：
- "同意"
- "拒绝"

请现在做出你的决定：
`;

    try {
        // 使用通用的API调用函数
        const response = await callChatAPI(decisionPrompt, character);
        // AI的回复通常是 `["同意"]` 或 `["拒绝"]`，我们只需要第一个元素
        const decision = Array.isArray(response) ? response[0].toLowerCase() : response.toLowerCase();

        console.log(`🤖 AI对好友申请的决策: ${decision}`);

        if (decision.includes('同意')) {
            // AI同意了
            await aiUnblockUser(characterId);
            
            const systemMsg = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `${character.name} 同意了你的好友申请，现在你们可以正常聊天了。`,
                timestamp: Date.now()
            };
            addMessageToChat(systemMsg);
            
            showToast(`✅ ${character.name} 同意了你的好友申请`, 'success');
            
        } else {
            // AI拒绝了
            const systemMsg = {
                id: 'system_' + Date.now(),
                sender: 'system',
                content: `${character.name} 拒绝了你的好友申请。`,
                timestamp: Date.now()
            };
            addMessageToChat(systemMsg);
            
            showToast(`❌ ${character.name} 拒绝了你的好友申请`, 'warning');
        }

    } catch (error) {
        console.error('处理AI好友申请回应失败:', error);
        showToast('对方没有回应，请稍后再试', 'error');
    }
}


/**
 * 🔥【新增】AI解除对用户的拉黑
 * @param {string} characterId - AI角色的ID（拉黑者）
 */
async function aiUnblockUser(characterId) {
    try {
        const blockRecord = blacklistData.find(r => 
            r.blockerId === characterId && 
            r.blockedId === 'user' && 
            !r.unblocked
        );

        if (!blockRecord) {
            console.warn('未找到该角色的拉黑记录');
            return;
        }

        blockRecord.unblocked = true;
        blockRecord.unblockTimestamp = new Date().toISOString();
        
        await db.blacklist.put(blockRecord);
        console.log(`✅ ${characterId} 已解除对用户的拉黑`);

        // 刷新聊天界面的拉黑状态
        if (currentChatCharacter && currentChatCharacter.id === characterId) {
            updateChatBlockedStatus();
        }
        
        // 刷新联系人列表和消息列表的UI状态
        renderContactList();
        renderMessageList();

    } catch (error) {
        console.error('AI解除拉黑失败:', error);
    }
}
        console.log('📱 角色状态显示功能已加载');

        // 🔥【新增】通知角色被拉黑
        async function notifyCharacterBlocked(characterId, reason = '') {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 构建被拉黑通知的prompt
                const blockNotificationPrompt = `[系统消息：用户将你拉黑了${reason ? `，理由：${reason}` : '，未说明理由'}]

你是${character.name}，人设如下：${character.bio}

用户刚刚将你拉黑了。请根据你的性格做出反应。你可以：
1. 表达你的感受（困惑、伤心、愤怒、无所谓等）
2. 思考可能的原因
3. 决定是否要道歉或反省
4. 或者表现出符合你性格的其他反应

请用1-2句话表达你的反应，要符合你的性格设定：`;

                // 调用AI生成反应
                const response = await callChatAPI(blockNotificationPrompt, character);
                const reactions = parseAiResponse(response);

                // 添加角色的反应消息到聊天记录
                for (let i = 0; i < reactions.length; i++) {
                    const reactionData = reactions[i];
                    
                    // 跳过拉黑指令对象
                    if (typeof reactionData === 'object' && reactionData !== null && reactionData.type === 'block_user') {
                        continue;
                    }

                    let reactionMessage;
                    if (typeof reactionData === 'string') {
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: reactionData,
                            timestamp: Date.now() + i * 100,
                            isBlockReaction: true // 标记为拉黑反应消息
                        };
                    } else if (typeof reactionData === 'object' && reactionData !== null) {
                        // 处理其他类型的消息对象
                        const content = reactionData.content || reactionData.message || reactionData.text || '[角色反应]';
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: content,
                            timestamp: Date.now() + i * 100,
                            isBlockReaction: true
                        };
                    }

                    if (reactionMessage) {
                        // 添加到聊天记录
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        chatMessages[characterId].push(reactionMessage);
                        
                        // 如果当前正在与该角色聊天，显示消息
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            addMessageWithAnimation(reactionMessage, characterId);
                        }
                    }
                }

                await saveChatMessages();
                console.log(`✅ ${character.name} 对被拉黑做出了反应`);

            } catch (error) {
                console.error('通知角色被拉黑失败:', error);
            }
        }

        // 🔥【新增】通知角色被解除拉黑
        async function notifyCharacterUnblocked(characterId) {
            try {
                const character = characters.find(c => c.id === characterId);
                if (!character) return;

                // 构建解除拉黑通知的prompt
                const unblockNotificationPrompt = `[系统消息：用户将你从黑名单中移除了]

你是${character.name}，人设如下：${character.bio}

用户刚刚将你从黑名单中移除，现在你们可以正常聊天了。请根据你的性格做出反应。你可以：
1. 表达高兴或解脱的心情
2. 询问为什么之前被拉黑
3. 道歉或表示会改正
4. 表现出符合你性格的态度（可能还在生气，也可能很开心等）
5. 主动开启新的话题

请用1-2句话表达你的反应，要符合你的性格设定：`;

                // 调用AI生成反应
                const response = await callChatAPI(unblockNotificationPrompt, character);
                const reactions = parseAiResponse(response);

                // 添加角色的反应消息到聊天记录
                for (let i = 0; i < reactions.length; i++) {
                    const reactionData = reactions[i];
                    
                    // 跳过拉黑指令对象
                    if (typeof reactionData === 'object' && reactionData !== null && reactionData.type === 'block_user') {
                        continue;
                    }

                    let reactionMessage;
                    if (typeof reactionData === 'string') {
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: reactionData,
                            timestamp: Date.now() + i * 100,
                            isUnblockReaction: true // 标记为解除拉黑反应消息
                        };
                    } else if (typeof reactionData === 'object' && reactionData !== null) {
                        // 处理其他类型的消息对象
                        const content = reactionData.content || reactionData.message || reactionData.text || '[角色反应]';
                        reactionMessage = {
                            id: (Date.now() + i).toString(),
                            sender: 'received',
                            content: content,
                            timestamp: Date.now() + i * 100,
                            isUnblockReaction: true
                        };
                    }

                    if (reactionMessage) {
                        // 添加到聊天记录
                        if (!chatMessages[characterId]) {
                            chatMessages[characterId] = [];
                        }
                        chatMessages[characterId].push(reactionMessage);
                        
                        // 如果当前正在与该角色聊天，显示消息
                        if (currentChatCharacter && currentChatCharacter.id === characterId) {
                            addMessageWithAnimation(reactionMessage, characterId);
                        }
                    }
                }

                await saveChatMessages();
                console.log(`✅ ${character.name} 对被解除拉黑做出了反应`);

            } catch (error) {
                console.error('通知角色被解除拉黑失败:', error);
            }
        }

        console.log('🚫 角色拉黑/解除拉黑通知功能已加载');
        
        // 🔥【修复脚本】解决数据导入失败和引用消息刷新后消失的问题
        console.log('🔧 正在应用系统修复...');
        
        // 修复数据导入问题
        (function fixImportIssues() {
            const originalImport = window.importDataFromFile;
            window.importDataFromFile = function() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = async function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    try {
                        showToast('🔍 验证文件格式...', 'info');
                        const text = await file.text();
                        
                        let data;
                        try {
                            data = JSON.parse(text);
                        } catch (parseError) {
                            throw new Error(`JSON格式错误: ${parseError.message}\n请确保文件是有效的备份文件`);
                        }
                        
                        if (!data || typeof data !== 'object') {
                            throw new Error('无效的备份文件格式');
                        }
                        
                        const items = [];
                        if (data.characters?.length) items.push(`角色: ${data.characters.length}个`);
                        if (data.chatMessages?.length) items.push(`消息: ${data.chatMessages.length}条`);
                        if (data.chatSettings?.length) items.push(`设置: ${data.chatSettings.length}个`);
                        
                        const msg = items.length ? `准备导入:\n${items.join('\n')}\n\n确定继续？` : '文件无有效数据，继续？';
                        if (!confirm(msg)) return;
                        
                        showToast('⚡ 导入中...', 'info');
                        let success = 0;
                        let errors = [];
                        
                        // 修复角色导入
                        if (data.characters?.length) {
                            try {
                                await db.characters.clear();
                                const chars = data.characters.filter(c => c?.name).map(c => ({
                                    ...c,
                                    id: c.id || `char_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                    groupId: c.groupId || 'my_friends'
                                }));
                                await db.characters.bulkPut(chars);
                                success++;
                            } catch (e) {
                                errors.push(`角色: ${e.message}`);
                            }
                        }
                        
                        // 修复消息导入（包含引用消息）
                        if (data.chatMessages?.length) {
                            try {
                                await db.chatMessages.clear();
                                const msgs = data.chatMessages.filter(m => m?.content).map(m => {
                                    const msg = {
                                        ...m,
                                        id: m.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                        characterId: m.characterId || 'unknown'
                                    };
                                    
                                    // 修复引用消息
                                    if (m.replyTo) {
                                        msg.replyTo = {
                                            id: m.replyTo.id || 'unknown',
                                            content: m.replyTo.content || '[已删除]',
                                            sender: m.replyTo.sender || 'unknown',
                                            senderName: m.replyTo.senderName || '未知',
                                            timestamp: m.replyTo.timestamp || Date.now(),
                                            _fixed: true
                                        };
                                    }
                                    return msg;
                                });
                                await db.chatMessages.bulkPut(msgs);
                                success++;
                            } catch (e) {
                                errors.push(`消息: ${e.message}`);
                            }
                        }
                        
                        // 导入设置
                        if (data.chatSettings?.length) {
                            try {
                                await db.chatSettings.clear();
                                const settings = data.chatSettings.map(s => ({
                                    ...s,
                                    id: s.id || `set_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                                }));
                                await db.chatSettings.bulkPut(settings);
                                success++;
                            } catch (e) {
                                errors.push(`设置: ${e.message}`);
                            }
                        }
                        
                        // 重新加载
                        await loadCharacters();
                        await loadChatMessages();
                        await loadChatSettings();
                        renderCharacterList();
                        renderMessageList();
                        
                        const result = success > 0 
                            ? `🎉 导入成功 ${success} 项${errors.length ? `\n⚠️ ${errors.length} 项失败` : ''}`
                            : `❌ 导入失败\n${errors.join('\n')}`;
                        showToast(result, success > 0 ? 'success' : 'error');
                        
                    } catch (error) {
                        showToast(`❌ 导入失败: ${error.message}`, 'error');
                        if (error.message.includes('JSON')) {
                            setTimeout(() => alert('文件格式错误！请确保是从"导出所有数据"生成的备份文件'), 1000);
                        }
                    }
                };
                input.click();
            };
        })();
        
        // 修复引用消息问题
        (function fixReplyIssues() {
            const originalGenerate = window.generateReplyHTML;
            window.generateReplyHTML = function(replyTo) {
                if (!replyTo) return '';
                
                let safe = {
                    id: replyTo.id || 'unknown',
                    senderName: replyTo.senderName || '未知',
                    content: replyTo.content || '[已删除]'
                };
                
                // 尝试恢复引用内容
                if (replyTo.id !== 'unknown' && currentChatCharacter) {
                    const msgs = chatMessages[currentChatCharacter.id] || [];
                    const original = msgs.find(m => m.id === replyTo.id);
                    if (original) {
                        safe.content = original.content || '[图片]';
                        safe.senderName = getSenderDisplayName(original);
                    }
                }
                
                const display = truncateText(safe.content, 40);
                return `
                    <div class="reply-reference" data-reply-id="${safe.id}">
                        <div class="reply-reference-line"></div>
                        <div class="reply-reference-content">
                            <div class="reply-reference-sender">${safe.senderName}</div>
                            <div class="reply-reference-message">${display}</div>
                        </div>
                    </div>
                `;
            };
        })();
        
        console.log('✅ 修复已应用: 数据导入错误处理、引用消息恢复机制');
        setTimeout(() => {
            if (typeof showToast === 'function') {
                showToast('🔧 系统已修复数据导入和引用消息问题', 'success');
            }
        }, 2000);
        
    </script>
</body>
</html>